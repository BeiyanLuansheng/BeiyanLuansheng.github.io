<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="2 应用层" /><meta name="author" content="BeiyanLuansheng" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="2.1 基本原理" /><meta property="og:description" content="2.1 基本原理" /><link rel="canonical" href="https://beiyanluansheng.github.io//posts/2-ApplicationLayer/" /><meta property="og:url" content="https://beiyanluansheng.github.io//posts/2-ApplicationLayer/" /><meta property="og:site_name" content="XuJian" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-08T21:41:25+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="2 应用层" /><meta name="twitter:site" content="@BeiyanLuansheng" /><meta name="twitter:creator" content="@BeiyanLuansheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BeiyanLuansheng"},"dateModified":"2020-12-08T21:41:25+08:00","datePublished":"2020-12-08T21:41:25+08:00","description":"2.1 基本原理","headline":"2 应用层","mainEntityOfPage":{"@type":"WebPage","@id":"https://beiyanluansheng.github.io//posts/2-ApplicationLayer/"},"url":"https://beiyanluansheng.github.io//posts/2-ApplicationLayer/"}</script><title>2 应用层 | XuJian</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XuJian"><meta name="application-name" content="XuJian"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XuJian</a></div><div class="site-subtitle font-italic">BeiyanLuansheng</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/BeiyanLuansheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/BeiyanLuansheng" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['beiyanluansheng','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>2 应用层</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>2 应用层</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BeiyanLuansheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2020-12-08, 21:41 +0800" >2020-12-08<i class="unloaded">2020-12-08T21:41:25+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7506 字">41 分钟 阅读</span></div></div><div class="post-content"><h2 id="21-基本原理">2.1 基本原理</h2><h3 id="211-网络应用的体系结构">2.1.1 网络应用的体系结构</h3><ul><li><p><strong>客户机/服务器结构(Client-Server, C/S)</strong></p><p>服务器：7*24小时提供服务；永久性访问地址/域名；利用大量服务器实现可扩展性</p><p>客户机：与服务器通信，使用服务器提供的服务；间歇性接入网络；可能使用动态IP地址；不会与其他客户机直接通信</p><blockquote><p>Web应用</p></blockquote><li><p><strong>点对点结构(Peer-to-peer, P2P)</strong></p><p>没有永远在线的服务器，任意端系统/节点之间可以直接通讯，节点间歇性接入网络，节点可能改变IP地址</p><p>优点在于<strong>高度可伸缩</strong>，缺点在于<strong>难于管理</strong></p><blockquote><p>文件传输应用</p></blockquote><li><p><strong>混合结构(Hybrid)</strong></p><p>文件传输使用P2P结构，文件的搜索采用C/S结构——集中式</p><p>每个节点向中央服务器登记自己的内容，而在查找感兴趣的内容时向中央服务器提交查询请求</p><blockquote><p>Napster</p></blockquote></ul><h3 id="212-网络应用进程通信">2.1.2 网络应用进程通信</h3><p><strong>同一主机</strong>上运行的进程之间由<strong>操作系统提供进程间通信机制</strong></p><p><strong>不同主机</strong>上运行的进程间靠<strong>消息交换</strong>通信，进程间通信<strong>利用socket发送/接收消息</strong>实现</p><ul><li><p><strong>进程寻址</strong>：通过标识符(<strong>IP地址+端口号</strong>)在不同主机上的进程间通信</p><ul><li><p>使用IP地址对主机寻址</p><li><p>为主机上每个需要通信的进程分配一个端口号，使用端口号对主机上的进程寻址</p><blockquote><ul><li>HTTP Server: 80<li>Mail Server：25</ul></blockquote></ul><li><p><strong>应用层协议</strong>：网络应用需遵循应用层协议</p><ul><li><strong>公开协议</strong>：由RFC定义的，允许互操作的协议(HTTP、SMTP)</ul><li><p><strong>私有协议</strong>：多数P2P文件共享应用</p><li><p><strong>应用层协议内容</strong></p><ul><li>消息的类型(type)：请求消息、响应消息<li>消息的语法(syntax)/格式：消息中有哪些字段(field)、每个字段如何描述<li>字段的语义(semantics)：字段中信息的含义<li>规则(rules)：进程何时发送/响应消息、进程如何发送/响应消息</ul></ul><h3 id="213-网络应用的服务需求">2.1.3 网络应用的服务需求</h3><ul><li><strong>数据丢失(data loss)/可靠性(reliability)</strong><ul><li>某些网络应用能够容忍一定的数据丢失：网络电话<li>某些网络应用要求100%可靠的数据传输：文件传输，telnet</ul><li><strong>时间(timing)/延迟(delay)</strong><ul><li>有些应用只有在延迟足够低时才“有效”，如：网络电话/网络游戏</ul><li><strong>带宽(bandwidth)</strong><ul><li>某些应用只有在带宽达到最低要求时才“有效”：网络视频<li>某些应用能够适应任何带宽——弹性应用：email</ul></ul><div class="table-wrapper"><table><thead><tr><th> <th><strong>TCP服务</strong><th><strong>UDP服务</strong><tbody><tr><td>连接<td>面向连接: 客户机/服务器进程间需要建立连接<td>无连接<tr><td>传输<td>可靠的传输<td>不可靠的数据传输<tr><td>流量控制<td>发送方不会发送速度过快，超过接收方的处理能力<td>不提供<tr><td>拥塞控制<td>当网络负载过重时能够限制发送方的发送速度<td>不提供<tr><td>时间/延迟保障<td>不提供<td>不提供<tr><td>带宽保障<td>不提供最小带宽保障<td>不提供</table></div><h2 id="22-web应用">2.2 web应用</h2><h3 id="221-http连接">2.2.1 HTTP连接</h3><ul><li><p>HTTP连接<strong>使用TCP</strong>传输服务：</p><ol><li><p>服务器在80端口等待客户的请求</p><li><p>浏览器发起到服务器的TCP连接(创建套接字Socket)</p><li><p>服务器接受来自浏览器的TCP连接</p><li><p>浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP消息</p><li><p>关闭TCP连接</p></ol><li><p>HTTP协议是<strong>无状态的</strong>，服务器不维护任何有关客户端过去所发请求的信息。</p><blockquote><p>有协议的更复杂，需要维护每个用户的历史信息状态，而且当客户或者服务器失效会产生状态的不一致，解决这种不一致代价高</p></blockquote></ul><div class="table-wrapper"><table><thead><tr><th>HTTP1.0<th>HTTP1.1<tbody><tr><td><strong>非持久性连接</strong>(Nonpersistent HTTP)<br />每个TCP连接最多允许传输<strong>一个对象</strong><td><strong>持久性连接</strong>(Persistent HTTP)<br />每个TCP连接允许传输<strong>多个对象</strong><tr><td>每个对象需要2个RTT<br />操作系统需要为每个TCP连接开销资源(overhead)<td>发送响应后，服务器保持TCP连接的打开</table></div><div class="table-wrapper"><table><thead><tr><th>无流水(pipelining)的持久性连接<th>带有流水机制的持久性连接(HTTP 1.1的默认选项)<tbody><tr><td>客户端只有收到前一个响应后才发送新的请求<td>客户端只要遇到一个引用对象就尽快发出请求<tr><td>每个被引用的对象耗时1个RTT<td>理想情况下，收到所有的引用对象只需耗时约1个RTT</table></div><ul><li><p><strong>RTT</strong>(Round Trip Time)：从客户端发送一个很小的数据包到服务器并返回所经历的时间</p><li><p><strong>响应时间</strong> = 建立TCP连接的1个RTT + 发送HTTP请求消息到HTTP响应消息的前几个字节到达的1个RTT + 响应消息中所含的文件/对象传输时间 = 2RTT + 文件发送时间</p></ul><h3 id="222-http消息格式">2.2.2 HTTP消息格式</h3><h4 id="2221-请求消息request">2.2.2.1 请求消息(request)</h4><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201208194117521.png" alt="image-20201208194117521" /></p><ul><li>HTTP 1.0<ul><li>GET方法： 输入信息通过request行的URL字段上传<li>POST方法：网页经常需要填写表格(form)，在请求消息的消息体(entity body)中上传客户端的输<li>HEAD方法：请Server不要将所请求的对象放入响应消息中</ul><li>HTTP 1.1<ul><li>GET, POST, HEAD<li>PUT：将消息体中的文件上传到URL字段所指定的路径<li>DELETE：删除URL字段所指定的文件</ul></ul><h4 id="2222-响应消息response">2.2.2.2 响应消息(response)</h4><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201208194932414.png" alt="image-20201208194932414" /></p><p>HTTP响应状态代码，响应消息的第一行：</p><ul><li>200 OK<li>301 Moved Permanently<li>400 Bad Request<li>404 Not Found<li>505 HTTP Version Not Supported</ul><h3 id="223-cookie技术">2.2.3 Cookie技术</h3><blockquote><p>HTTP协议无状态，但很多应用需要服务器掌握客户端的状态</p></blockquote><p><strong>Cookie技术</strong>：某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)。</p><p><strong>Cookie的组件</strong>：</p><ul><li>TTP响应消息的cookie头部行<li>HTTP请求消息的cookie头部行<li>保存在客户端主机上的cookie文件，由浏览器管理<li>Web服务器端的后台数据库</ul><p>Cookie能够用于：身份认证、购物车、推荐、Web e-mail、……</p><blockquote><p>但是cookie存在用户隐私泄露的问题</p></blockquote><h3 id="224-web缓存代理服务器技术条件get">2.2.4 Web缓存/代理服务器技术：条件GET</h3><blockquote><p>为了<strong>缩短客户请求的响应时间、减少机构/组织的流量、在大范围内(Internet)实现有效的内容分发</strong>，所以提出了在不访问服务器的前提下满足客户端的HTTP请求的技术——Web缓存/代理服务器技术。</p></blockquote><p>浏览器向缓存/代理服务器发送所有的HTTP请求：如果所请求对象在缓存中，缓存返回对象；否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象。所以缓存既充当客户端，也充当服务器，<em>一般由ISP(Internet服务提供商)架设</em>。</p><p><strong>条件性GET方法</strong></p><p>目标：如果缓存有最新的版本，则不需要发送请求对象</p><p>缓存：在HTTP请求消息中声明所持有版本的日期(在HTTP请求消息有 <strong>If-modified-since: &lt;date&gt;</strong>)</p><p>服务器：如果缓存的版本是最新的，则响应消息中不包含对象(响应消息为 <strong>HTTP/1.0 304 Not Modified</strong>)，如果不是最新的，正常返回请求对象</p><blockquote><p>在HTTP响应消息中有一行 <strong><code class="language-plaintext highlighter-rouge">Last-Modified</code></strong> header line，表明最后一次的修改时间</p></blockquote><h2 id="23-email应用">2.3 Email应用</h2><p>Email应用的构成组件</p><ul><li><p>邮件客户端(user agent)：Client应用或者Web页面</p><li><p>邮件服务器</p><li><p>SMTP协议(Simple Mail Transfer Protocol)：在邮件服务器之间传递消息使用的协议</p><ul><li>客户端：发送消息的服务器<li>服务器：接收消息的服务器</ul></ul><h3 id="231-smtp协议">2.3.1 SMTP协议</h3><p>使用TCP在25端口建立持久性连接进行email消息的可靠传输，传输过程的三个阶段：握手、消息的传输、关闭。</p><p><strong>命令/响应交互模式</strong>：</p><ul><li><p>命令(command)：ASCII文本</p><li><p>响应(response)：状态代码和语句</p></ul><p>Email消息只能包含7位ASCII码</p><p>SMTP服务器利用<code class="language-plaintext highlighter-rouge">CRLF.CRLF</code>确定消息的结束。</p><blockquote><p>SMTP与HTTP对比：</p><ul><li><p>HTTP是拉式(pull)，而SMTP是推式(push)</p><li><p>HTTP的每个对象封装在独立的响应消息中，SMTP的多个对象在由多个部分构成的消息中发送</p><li><p>都使用命令/响应交互模式</p><li><p>命令和状态代码都是ASCII码</p></ul></blockquote><h3 id="232-email消息格式">2.3.2 Email消息格式</h3><p>Email消息由三部分组成：</p><ul><li>头部行(header)<ul><li>To<li>From<li>Subject</ul><li>空白行<li>消息体：消息本身，只能是ASCII字符</ul><p>而为了传输非文本类型的数据，对如上的消息做出了扩展。</p><p><strong>MIME：多媒体邮件扩展</strong>。通过在邮件头部增加额外的行以声明MIME的内容类型。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201208204051074.png" alt="image-20201208204051074" /></p><h3 id="233-邮件访问协议">2.3.3 邮件访问协议</h3><p>邮件访问协议：从服务器获取邮件</p><ul><li>POP (Post Office Protocol)：认证/授权(客户端&lt;—-&gt;服务器)和下载<li>IMAP (Internet Mail Access Protocol)：更多功能、更加复杂、能够操纵服务器上存储的消息<ul><li>所有消息统一保存在一个地方：服务器<li>允许用户利用文件夹组织消息<li>支持跨会话(Session)的用户状态：文件夹的名字、文件夹与消息ID之间的映射等</ul><li>HTTP：163, QQ Mail等(网页版使用)</ul><h4 id="2331-pop3协议">2.3.3.1 POP3协议</h4><ul><li>认证过程<ul><li>客户端命令<ul><li>User：声明用户名<li>Pass：声明密码</ul><li>服务器响应<ul><li>+OK<li>-ERR</ul></ul><li>事务阶段<ul><li>List：列出消息数量<li>Retr：用编号获取消息<li>Dele：删除消息<li>Quit</ul></ul><p>POP协议有两种模式：</p><ul><li><p>“下载并删除”模式：用户如果换了客户端软件，无法重读该邮件</p><li><p>“下载并保持”模式：不同客户端都可以保留消息的拷贝</p></ul><blockquote><p><strong>POP3是无状态的</strong></p></blockquote><h4 id="2332-imap协议">2.3.3.2 IMAP协议</h4><p>所有消息统一保存在一个地方：服务器</p><p>允许用户利用文件夹组织消息，支持跨会话(Session)的用户状态：文件夹的名字、文件夹与消息ID之间的映射等</p><h2 id="24-dns应用">2.4 DNS应用</h2><p>DNS：Domain Name System 域名解析系统</p><ul><li>多层命名服务器构成的分布式数据库<li>应用层协议：完成名字的解析。Internet核心功能，用应用层协议实现</ul><p>DNS服务：域名向IP地址的翻译；主机别名；邮件服务器别名；Web服务器负载均衡</p><h3 id="241-分布式层次式数据库">2.4.1 分布式层次式数据库</h3><p><strong>根域名服务器</strong>：本地域名解析服务器无法解析域名时，访问根域名服务器。</p><p><strong>顶级域名服务器</strong>(TLD, top-level domain)：负责com, org, net,edu等顶级域名和国家顶级域名，例如cn, uk, fr等。</p><p><strong>权威(Authoritative)域名服务器</strong>：组织的域名解析服务器，提供组织内部服务器的解析服务。组织或服务提供商负责维护。</p><p><strong>本地域名解析服务器</strong>：不严格属于层级体系，每个ISP有一个本地域名服务器，是默认域名解析服务器。</p><p>当主机进行DNS查询时，查询被发送到本地域名服务器，作为代理(proxy)，将查询转发给(层级式)域名解析服务器系统。</p><ul><li><strong>迭代查询</strong>：被查询服务器返回域名解析服务器的名字。“我不认识这个域名，但是你可以问题这服务器”<li><strong>递归查询</strong>：将域名解析的任务交给所联系的服务器</ul><blockquote><p>只要域名解析服务器获得域名—IP映射，即缓存这一映射，一段时间过后，缓存条目失效(删除)</p><p>本地域名服务器一般会缓存顶级域名服务器的映射，因此根域名服务器不经常被访问</p></blockquote><h3 id="242-dns记录">2.4.2 DNS记录</h3><p>资源记录(RR, resource records)，RR format: (Name, Value, Type, TTL)</p><ul><li>Type=A<ul><li>Name：主机域名<li>Value：IP地址</ul><li>Type=NS<ul><li>Name：域(edu.cn)<li>Value：该域权威域名解析服务器的主机域名</ul><li>Type=CNAME<ul><li>Name：某一真实域名的别名，如 www.ibm.com – servereast.backup2.ibm.com<li>Value：真实域名</ul><li>Type=MX<ul><li>Value是与name相对应的邮件服务器</ul></ul><h3 id="243-dns协议和消息格式">2.4.3 DNS协议和消息格式</h3><p>DNS协议：查询 (query) 和回复 (reply) 消息，消息格式相同</p><p>消息头部：</p><ul><li>Identification：16位查询编号，回复使用相同的编号<li>flags：查询或回复、期望递归、递归可用、权威回答</ul><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201208211249849.png" alt="image-20201208211249849" /></p><p>为公司 “Network Utopia”注册域名：</p><ul><li><p>在域名管理机构(如Network Solutions)注册域名networkutopia.com。向域名管理机构提供你的权威域名解析服务器的名字和IP地址，域名管理机构向com顶级域名解析服务器中插入两条记录</p><p><code class="language-plaintext highlighter-rouge">(networkutopia.com, dns1.networkutopia.com, NS)</code></p><p><code class="language-plaintext highlighter-rouge">(dns1.networkutopia.com, 212.212.212.1, A)</code></p><li><p>在权威域名解析服务器中为www.networkuptopia.com加入Type A记录，为networkutopia.com加入Type MX记录</p></ul><h2 id="25-ftp">2.5 FTP</h2><p>file transfer protocol，基于C/S架构。</p><p>FTP有<strong>两个连接，一个用于控制，一个用于数据传输</strong>。FTP客户端使用TCP在端口21联系FTP服务器，通过控制连接授权客户端，客户端浏览远程目录，通过控制连接发送命令，当服务器接收文件传输命令时，服务器打开第二个TCP数据连接(用于文件)到客户端，传输一个文件后，服务器关闭数据连接。</p><p>控制连接被称为<strong>带外传输</strong></p><h2 id="26-p2p应用">2.6 P2P应用</h2><h3 id="261-原理">2.6.1 原理</h3><ul><li>没有服务器<li>任意端系统之间直接通信<li>节点阶段接入Internet<li>节点可能更换IP地址</ul><p><strong>问题</strong>：从一个服务器向N个节点分发一个文件F需要多长时间？</p><ul><li>设：<ul><li>u~s~ ——服务器上传带宽<li>u~i~ ——节点i的上传带宽<li>d~i~ ——节点i的下载带宽</ul><li><strong>C/S架构</strong><ul><li>服务器发送N个副本的时间：NF/u~s~<li>客户机i的下载时间：F/d~i~<li>分发N个F所需时间：d~cs~=max{ NF/u~s~ , F/min{d~i~} }——时间关于N是<strong>线性增长</strong>的</ul><li><strong>P2P</strong><ul><li>服务器必须发送一个副本(最小的消耗时间)：F/u~s~<li>客户机i的下载时间：F/d~i~<li>下载总量：NF bits<li>最快的上传速率(服务器和所有的节点都在上传)：u~s~ + Σu~i~<li>分发N个F所需要的时间：d~P2P~ = max { F/u~s~, F/min(d~i~) , NF/(u~s~ + Σu~i~) }——非线性的</ul></ul><h3 id="262-文件分发bittorrent">2.6.2 文件分发：BitTorrent</h3><ul><li><strong>洪流(torrent)</strong>：参与一个特定文件分发的所有对等方的集合<li><strong>文件块(chunk)</strong>：一个洪流中的对等方下载等长度的文件块，典型长度<strong>256KB</strong><li><strong>追踪器(tracker)</strong>：一个对等方加入一个洪流时，它向追踪器注册自己并周期性地通知追踪器它还在线</ul><p><strong>BitTorrent</strong></p><ul><li><p>文件划分为256KB的chunk</p><li><p>节点加入torrent时没有chunk，但是会逐渐积累；每个节点向tracker注册以获得节点清单，与某些节点(“邻居”)建立连接</p><li><p>下载的同时，节点需要向其他节点上传chunk</p><li><p>节点可能加入或离开：一旦节点获得完整的文件，它可能(自私地)离开或(无私地)留下</p><li><p>获取chunk</p><ul><li>给定任一时刻，不同的节点持有文件的不同chunk集合<li>节点(Alice)定期查询每个邻居所持有的chunk列表<li>节点发送请求，请求获取缺失的chunk：稀缺优先</ul><li><p>发送chunk：tit-for-tat</p><ul><li>Alice向正在向其发送Chunk且速率最快的4个邻居发送chunk：每10秒重新评估top 4<li>每30秒随机选择一个其他节点，向其发送chunk：新选择节点可能加入top 4，“optimistically unchoke”</ul></ul><h3 id="263-索引技术">2.6.3 索引技术</h3><h4 id="2631-集中式索引">2.6.3.1 集中式索引</h4><ol><li><p>节点加入时，通知中央服务器：<strong>IP地址</strong>和<strong>内容</strong></p><li><p>Alice查找“Hey Jude”</p><li><p>Alice从Bob处请求文件</p></ol><p>存在的问题：内容和文件传输是分布式的，但是内容定位是高度集中式的</p><ul><li>单点失效问题<li>性能瓶颈<li>版权问题</ul><h4 id="2632-洪泛式查询query-flooding">2.6.3.2 洪泛式查询：Query flooding</h4><p><strong>完全分布式架构</strong>(Gnutella采用这种架构)——每个节点对它共享的文件进行索引，且只对它共享的文件进行索引、</p><p><strong>覆盖网络</strong>(overlay network)：Graph</p><ul><li><p>节点X与Y之间如果有TCP连接，那么构成一个边</p><li><p>所有的活动节点和边构成覆盖网络</p><li><p>边：虚拟链路</p><li><p>节点一般邻居数少于10个</p></ul><p><strong>查询消息</strong>通过已有的TCP连接发送，节点转发查询消息，如果查询命中，则利用反向路径发回查询节点。</p><h4 id="2633-层次是覆盖网络">2.6.3.3 层次是覆盖网络</h4><p>介于集中式索引和洪泛查询之间的方法</p><p>每个节点或者是一个超级节点，或者被分配一个超级节点</p><p>节点和超级节点间维持TCP连接，某些超级节点对之间维持TCP连接</p><p>超级节点负责跟踪子节点的内容</p><h2 id="27-socket编程">2.7 Socket编程</h2><h3 id="271-应用编程接口api">2.7.1 应用编程接口(API)</h3><blockquote><ul><li>应用层(Application)：Web/RPC/中间件编程<ul><li>Socket编程<li>NetBIOS编程——Windows</ul><li>传输层(Transport)<li>网络层(Network)<ul><li>基于NDIS网络编程——Windows<li>基于LibPcap/WinPcap、Libnet、Libnids、Libicmp编程</ul><li>数据链路层(Data link)<ul><li>直接网卡编程，硬件相关的<li>基于Packet Driver编程，屏蔽网卡细节，适用于所有网卡</ul><li>物理层(Physical)</ul></blockquote><p><strong>API</strong>：为了使应用层的应用进程可以和相邻层(传输层)传递数据，需要一个接口，即API。所以API就是<strong>应用进程的控制权</strong>和<strong>操作系统的控制权</strong>进行<strong>转换</strong>的一个系统调用接口</p><p><strong>典型的应用编程接口</strong>：</p><ul><li><strong>socket interface(socket、套接字)</strong>——Berkeley UNIX<li><p><strong>Windows Socket Interface(WINSOCK)</strong>——微软</p><li><strong>Transport Layer Interface(TLI)</strong>——AT&amp;T UNIX 系统 V</ul><h3 id="272-socket-api概述">2.7.2 Socket API概述</h3><ul><li><p>标识通信端点(对外)：IP地址+端口号(16位整数)</p><li><p>操作系统/进程管理套接字(对内)：套接字描述符(socket descriptor)——小整数</p></ul><p><strong>Socket抽象</strong></p><ul><li><p>类似于文件的抽象：当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息，操作系统返回套接字描述符</p><li><p>操作系统维护一个套接字描述符表，存储的是指向套接字数据结构的指针</p><li><p>地址结构：<code class="language-plaintext highlighter-rouge">sockaddr_in</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">aockaddr_in</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">sin_len</span><span class="p">;</span>				<span class="cm">/*地址长度*/</span>
    <span class="n">u_char</span> <span class="n">sin_family</span><span class="p">;</span>			<span class="cm">/*地址族*/</span>
    <span class="n">u_short</span> <span class="n">sin_port</span><span class="p">;</span>			<span class="cm">/*端口号*/</span>
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> 	<span class="cm">/*IP地址*/</span>
    <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/*未用(置0)*/</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><strong>地址族</strong>：为了适应不同协议的变化，引入了地址族，其<strong>在TCP/IP</strong>下使用的值为<strong>AF_INET</strong></p></blockquote></ul><h3 id="273-socket-api函数">2.7.3 Socket API函数</h3><p>所有的API都是在WINSOCK中的，与UNIX下的socket大同小异</p><h4 id="2731-wsastartup">2.7.3.1 WSAStartup</h4><p><code class="language-plaintext highlighter-rouge">int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</code></p><ul><li>使用Socket的应用程序在使用Socket之前必须首先调用此函数加载DLL<li>第一个参数指明程序请求使用的<strong>WinSock版本</strong>：高位字节指明副版本、低位字节指明主版本<li>第二个参数是返回<strong>实际的WinSock的版本信息</strong>：指向WSADATA结构的指针</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cm">/* 例 */</span>
<span class="n">wVersionRequested</span> <span class="o">=</span> <span class="n">MAKEWORD</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">WSAStartup</span><span class="p">(</span><span class="n">wVersionRequested</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wsaData</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="2732-wsacleanup">2.7.3.2 WSACleanup</h4><p><code class="language-plaintext highlighter-rouge">int WSACleanup (void);</code></p><p>应用程序在完成对请求的Socket库的使用，最后要调用WSACleanup函数<strong>解除与Socket库的绑定</strong>，<strong>释放Socket库所占用的系统资源</strong></p><h4 id="2733-socket">2.7.3.3 socket</h4><p><code class="language-plaintext highlighter-rouge">sd = socket(protofamily,type,proto);</code></p><ul><li><p>用于创建套接字</p><li>操作系统返回<strong>套接字描述符</strong>(sd)<li>第一个参数指明<strong>协议族</strong>：在<strong>TCP/IP下</strong>为<strong>PF_INET</strong><li>第二个参数指明<strong>套接字类型</strong>：在<strong>TCP/IP下</strong>可以为<strong>SOCK_STREAM</strong>、<strong>SOCK_DGRAM</strong>或<strong>SOCK_RAW</strong><li>第三个参数指明<strong>协议号</strong>：默认为0，当某类套接字只面向一类协议时直接使用0即可，而面向多个协议时就需要指定协议号了</ul><blockquote><p>Socket面向TCP/IP的服务类型</p><p>应用层 ———– 应用进程</p><div class="table-wrapper"><table><tbody><tr><td>​ /<td>\</table></div><div class="table-wrapper"><table><tbody><tr><td><strong>SOCK_STREAM</strong><td><strong>SOCK_DGRAM</strong></table></div><p>​ / <strong>SOCK_RAW</strong> \</p><div class="table-wrapper"><table><tbody><tr><td>传输层–TCP<td>UDP</table></div><p>网络层———-IP/ICMP/IGMP</p></blockquote><h4 id="2734-closesocket">2.7.3.4 Closesocket</h4><p><code class="language-plaintext highlighter-rouge">int closesocket(SOCKET sd)</code></p><ul><li>unix下该函数名是<code class="language-plaintext highlighter-rouge">close</code>，也就是关闭文件的函数<li>该函数是关闭描述符为sd的套接字<ul><li>但如果多个进程共享一个套接字，调用该函数是将套接字引用计数减1，减至0才关闭，它清除掉的只是该进程中对它的引用<li>而一个进程中的多线程对一个套接字的使用是无计数的，也就是说，在一个线程中关闭了一个套接字意味着其他线程也不能再访问该套接字了</ul><li>返回0表示成功，返回SOCKET_ERROR表示失败</ul><h4 id="2735-bind">2.7.3.5 bind</h4><p><code class="language-plaintext highlighter-rouge">int bind(sd, localadr, addrlen);</code></p><ul><li>绑定套接字的本地端点地址：IP地址+端口号<ul><li>由于在创建SOCKET的时候可能没有对应的地址信息，所以要进行地址信息的绑定</ul><li>客户程序一般不需要调用bind函数，操作系统自动设置<li>服务端需要绑定端口号，而不能绑定特定的IP，一旦绑定了特定IP意味着其他IP就不能访问该服务器了，所以为了解决该问题，服务端绑定的是一个地址通配符<strong>INADDR_ANY</strong></ul><h4 id="2736-listen">2.7.3.6 listen</h4><p><code class="language-plaintext highlighter-rouge">int listen(sd, queuesize);</code></p><ul><li>C/S架构下将服务器端的流套接字置为监听状态，所以此函数<strong>仅被服务器调用</strong>，仅用于面向连接(TCP)的<strong>流套接字</strong><li>第二个参数设置连接请求队列的大小，服务器从队列中提取<li>返回0表示成功，返回SOCKET_ERROR表示失败</ul><h4 id="2737-connect">2.7.3.7 connect</h4><p><code class="language-plaintext highlighter-rouge">connect(sd,saddr,saddrlen);</code></p><ul><li><p>使客户套接字(sd)与特定计算机的特定端口(saddr)的套接字(服务)进行连接</p><li><p>仅用于<strong>客户端</strong>，可用于TCP客户端，也可用于UDP客户端</p><ul><li>TCP客户端：建立TCP连接，客户端调用此函数对服务器发起连接请求<li>UDP客户端：指定服务器端点地址，UDP是无连接的，所以即使调用<code class="language-plaintext highlighter-rouge">commect</code> 成功，也有可能无法与服务器通信</ul></ul><h4 id="2738-accept">2.7.3.8 accept</h4><p><code class="language-plaintext highlighter-rouge">newsock = accept(sd,caddr,caddrlen);</code></p><ul><li>服务程序调用<code class="language-plaintext highlighter-rouge">accept</code>从处于监听状态的流套接字sd的客户连接请求队列中取出排在最前的一个客户请求，并且<strong>创建一个新的套接字</strong>来与客户套接字创建连接通道<ul><li>如果直接使用服务器的主套接字则服务器在同一时刻只能与一个客户端连接，所以使用创建新套接字来达到并行连接的目的(并发的TCP服务器)</ul><li>仅用于<strong>服务器</strong>，仅用于<strong>TCP套接字</strong></ul><h4 id="2739-send-sendto">2.7.3.9 send, sendto</h4><p><code class="language-plaintext highlighter-rouge">send(sd,*buf,len,flags);</code></p><p><code class="language-plaintext highlighter-rouge">sendto(sd,*buf,len,flags,destaddr,addrlen);</code></p><ul><li><code class="language-plaintext highlighter-rouge">send</code>是没有指定服务器的地址的，也就是说连接已经建立了，故可用于：<ul><li>TCP套接字(客户端与服务器端均可)<li>调用了 <code class="language-plaintext highlighter-rouge">connect</code> 的UDP客户端的套接字(连接模式的UDP套接字)</ul><li><code class="language-plaintext highlighter-rouge">sendto</code>函数用于UDP服务器端套接字与未调用<code class="language-plaintext highlighter-rouge">connect</code>函数的UDP客户端套接字</ul><h4 id="27310-recv-recvfrom">2.7.3.10 recv, recvfrom</h4><p><code class="language-plaintext highlighter-rouge">recv(sd,*buffer,len,flags);</code></p><p><code class="language-plaintext highlighter-rouge">recvfrom(sd,*buf,len,flags,senderaddr,saddrlen);</code></p><ul><li><code class="language-plaintext highlighter-rouge">recv</code>函数从<strong>TCP连接的另一端</strong>接收数据，或者从<strong>调用了<code class="language-plaintext highlighter-rouge">connect</code>函数的UDP客户端套接字</strong>接收服务器发来的数据<li><code class="language-plaintext highlighter-rouge">recvfrom</code>函数用于从<strong>UDP服务器端套接字</strong>与<strong>未调用<code class="language-plaintext highlighter-rouge">connect</code>函数的UDP客户端套接字</strong>接收对端数据</ul><h4 id="27311-setsockopt-getsockopt">2.7.3.11 setsockopt, getsockopt</h4><p><code class="language-plaintext highlighter-rouge">int setsockopt(int sd, int level, int optname, *optval, int optlen);</code></p><p><code class="language-plaintext highlighter-rouge">int getsockopt(int sd, int level, int optname, *optval, socklen_t *optlen);</code></p><ul><li><code class="language-plaintext highlighter-rouge">setsockopt</code>函数用来设置套接字sd的选项参数<li><code class="language-plaintext highlighter-rouge">getsockopt</code>函数用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optval</ul><h3 id="274-网络字节顺序">2.7.4 网络字节顺序</h3><p>由于五层网络模型中不存在表示层，所以无法进行不同机器间的表示转化，于是TCP/IP定义了标准的用于协议头中的二进制整数表示：<strong>网络字节顺序(network byte order)</strong></p><p>某些Socket API函数的<strong>参数</strong>需要<strong>存储为网络字节顺序</strong>(如IP地址、端口号等)，因此实现本地字节顺序与网络字节顺序间转换的函数有：</p><ul><li><strong>htons</strong>：本地字节顺序→网络字节顺序(16bits)<li><strong>ntohs</strong>：网络字节顺序→本地字节顺序(16bits)<li><strong>htonl</strong>：本地字节顺序→网络字节顺序(32bits)<li><strong>ntohl</strong>：网络字节顺序→本地字节顺序(32bits)</ul><h3 id="275-客户端软件设计">2.7.5 客户端软件设计</h3><h4 id="2751-解析服务器ip地址">2.7.5.1 解析服务器IP地址</h4><p>由于客户端可能使u用域名或IP地址来标识服务器，而IP协议需要32位的二进制IP地址，所以需要将域名或IP地址转换为32位的IP地址。</p><ul><li>函数<code class="language-plaintext highlighter-rouge">inet_addr()</code> 实现点分十进制IP地址到32位IP地址转换<li>函数<code class="language-plaintext highlighter-rouge">gethostbyname()</code> 实现域名到32位IP地址转换，返回一个指向结构<strong>hostent</strong>的指针</ul><p>以上两个函数得到的已经是网络字节顺序，可以直接使用。</p><h4 id="2752-解析服务器端口号">2.7.5.2 解析服务器端口号</h4><p>客户端还可能使用服务名(如HTTP)标识服务器端口，因此需要将服务名转换为熟知端口号。</p><ul><li>函数<code class="language-plaintext highlighter-rouge">getservbyname()</code>，返回一个指向结构<strong>servent</strong>的指针</ul><h4 id="2753-解析协议号">2.7.5.3 解析协议号</h4><p>客户端可能使用协议名(如:TCP)指定协议，因此需要将协议名转换为协议号(如：6)</p><ul><li>函数<code class="language-plaintext highlighter-rouge">getprotobyname()</code>实现协议名到协议号的转换，返回一个指向结构<strong>protoent</strong>的指针</ul><h4 id="2754-tcpudp客户端软件流程">2.7.5.4 TCP/UDP客户端软件流程</h4><p><strong>TCP</strong>：</p><ol><li><p>确定服务器<strong>IP地址</strong>与<strong>端口号</strong></p><li>创建套接字<li><em>分配本地端点地址(IP地址+端口号)</em>——不需要设计软件时手动来做，系统自动完成<li>连接服务器(套接字)——<code class="language-plaintext highlighter-rouge">connect()</code><li>遵循应用层协议进行通信——根据协议确定客户端和服务器哪方先发信息<li>关闭/释放连接</ol><p><strong>UDP</strong>：</p><ol><li>确定服务器<strong>IP地址</strong>与<strong>端口号</strong>——并非只是每次的第一步做，之后可能每次都需要做<li>创建套接字<li><em>分配本地端点地址(IP地址+端口号)</em>——自动完成<li>指定服务器端点地址，构造UDP数据报——<code class="language-plaintext highlighter-rouge">connect()</code>，构造的UDP数据报可以发给不同的服务器，此时需要重复做第一步<li>遵循应用层协议进行通信——一定是UDP客户端先给服务器发信息<li>关闭/释放套接字</ol><h3 id="276-服务器软件设计">2.7.6 服务器软件设计</h3><ul><li><p><strong>循环无连接</strong>(Iterative connectionless)服务器，基本流程：</p><ol><li>创建套接字<li>绑定端点地址(INADDR_ANY+端口号)<li>反复接收来自客户端的请求<li>遵循应用层协议，构造响应报文，发送给客户</ol><blockquote><p>数据发送：</p><ul><li>服务器端不能使用<code class="language-plaintext highlighter-rouge">connect()</code>函数<li>无连接服务器使用<code class="language-plaintext highlighter-rouge">sendto()</code>函数发送数据报</ul><p>获取客户端点地址：</p><ul><li>调用<code class="language-plaintext highlighter-rouge">recvfrom()</code>函数接收数据时，自动提取</ul></blockquote><li><p><strong>循环面向连接</strong>(Iterative connection-oriented)服务器，基本流程：</p><ol><li>创建(主)套接字，并绑定熟知端口号；<li>设置(主)套接字为被动监听模式，准备用于服务器；<li>调用<code class="language-plaintext highlighter-rouge">accept()</code>函数接收下一个连接请求(通过主套接字)，创建新套接字用于与该客户建立连接；<li>遵循应用层协议，反复接收客户请求，构造并发送响应(通过新套接字)；<li>完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3.</ol><li><p><strong>并发无连接</strong>(Concurrent connectionless)服务器，基本流程：</p><ul><li><p>主线程1：创建套接字，并绑定熟知端口号；</p><li><p>主线程2：反复调用<code class="language-plaintext highlighter-rouge">recvfrom()</code>函数，接收下一个客户请求，并创建新线程处理该客户响应；</p><li><p>子线程1：接收一个特定请求；</p><li><p>子线程2：依据应用层协议构造响应报文，并调用<code class="language-plaintext highlighter-rouge">sendto()</code>发送；</p><li><p>子线程3：退出(一个子线程处理一个请求后即终止)。</p></ul><li><p><strong>并发面向连接</strong>(Concurrent connection-oriented)服务器，基本流程：</p><ul><li><p>主线程1：创建(主)套接字，并绑定熟知端口号；</p><li><p>主线程2：设置(主)套接字为被动监听模式，准备用于服务器；</p><li><p>主线程3：反复调用<code class="language-plaintext highlighter-rouge">accept()</code>函数接收下一个连接请求(通过主套接字)，并创建一个新的子线程处理该客户响应；</p><li><p>子线程1：接收一个客户的服务请求(通过新创建的套接字)；</p><li><p>子线程2：遵循应用层协议与特定客户进行交互；</p><li><p>子线程3：关闭/释放连接并退出(线程终止)。</p></ul></ul><blockquote><p>客户端与服务器的实现范例参见PPT</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a> <a href="/tags/hitcn/" class="post-tag no-text-decoration" >HITCN</a> <a href="/tags/2020%E7%A7%8B/" class="post-tag no-text-decoration" >2020秋</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=2 应用层 - XuJian&url=https://beiyanluansheng.github.io//posts/2-ApplicationLayer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=2 应用层 - XuJian&u=https://beiyanluansheng.github.io//posts/2-ApplicationLayer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=2 应用层 - XuJian&url=https://beiyanluansheng.github.io//posts/2-ApplicationLayer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nas/">使用Docker部署NAS</a><li><a href="/posts/route/">使用Docker部署OpenWRT旁路由</a><li><a href="/posts/10-dockerDeploy/">OES之十：Dcoker部署</a><li><a href="/posts/9-file/">OES之九：文件上传下载</a><li><a href="/posts/5-passValue/">OES之五：请求接口</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT-FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-Introdution/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T10:56:33+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1 概述</h3><div class="text-muted small"><p> 1.1 计算机网络 1.1.1 计算机网络与Internet 计算机网络：计算机网络就是互连的、自治的计算机集合。 自治：无主从关系 互连：互联互通——通信链路。通过交换网络互连主机，在距离远、数量大时保证互连。 Internet：全球最大的互联网络。ISP(Internet Service Provider) 网络互连的“网络之网络” 数以百万计的互连的计算设备...</p></div></div></a></div><div class="card"> <a href="/posts/3-TransportLayer/"><div class="card-body"> <span class="timeago small" >2020-12-09<i class="unloaded">2020-12-09T14:22:08+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>3 传输层</h3><div class="text-muted small"><p> 网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制 3.1 多路复用和多路分用 多路复用（发送端）：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络层 多路分用（接收端）：传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程工作方式： 主机接收IP数据报：每个数据报携带源IP地...</p></div></div></a></div><div class="card"> <a href="/posts/4-NetworkLayer/"><div class="card-body"> <span class="timeago small" >2020-12-10<i class="unloaded">2020-12-10T22:55:52+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>4 网络层</h3><div class="text-muted small"><p> 4.1 网络层服务 网络层：从发送主机向接收主机传送数据段（segment），发送主机将数据段封装到数据报（datagram）中；接收主机向传输层交付数据段（segment）。每个主机和路由器都运行网络层协议（非端到端的），路由器检验所有穿越它的IP数据报的头部域，以决策如何处理IP数据报。 网络层核心功能：转发与路由 转发(forwarding)：将分组从路由器的输入端口转移到...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/1-Introdution/" class="btn btn-outline-primary" prompt="上一篇"><p>1 概述</p></a> <a href="/posts/3-TransportLayer/" class="btn btn-outline-primary" prompt="下一篇"><p>3 传输层</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.facebook.com/BeiyanLuansheng">XuJian</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
