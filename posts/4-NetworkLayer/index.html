<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="4 网络层" /><meta name="author" content="BeiyanLuansheng" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="4.1 网络层服务" /><meta property="og:description" content="4.1 网络层服务" /><link rel="canonical" href="https://beiyanluansheng.github.io//posts/4-NetworkLayer/" /><meta property="og:url" content="https://beiyanluansheng.github.io//posts/4-NetworkLayer/" /><meta property="og:site_name" content="XuJian" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-10T22:55:52+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="4 网络层" /><meta name="twitter:site" content="@BeiyanLuansheng" /><meta name="twitter:creator" content="@BeiyanLuansheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BeiyanLuansheng"},"dateModified":"2020-12-10T22:55:52+08:00","datePublished":"2020-12-10T22:55:52+08:00","description":"4.1 网络层服务","headline":"4 网络层","mainEntityOfPage":{"@type":"WebPage","@id":"https://beiyanluansheng.github.io//posts/4-NetworkLayer/"},"url":"https://beiyanluansheng.github.io//posts/4-NetworkLayer/"}</script><title>4 网络层 | XuJian</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XuJian"><meta name="application-name" content="XuJian"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XuJian</a></div><div class="site-subtitle font-italic">BeiyanLuansheng</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/BeiyanLuansheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/BeiyanLuansheng" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['beiyanluansheng','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>4 网络层</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>4 网络层</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BeiyanLuansheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2020-12-10, 22:55 +0800" >2020-12-10<i class="unloaded">2020-12-10T22:55:52+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8946 字">49 分钟 阅读</span></div></div><div class="post-content"><h2 id="41-网络层服务">4.1 网络层服务</h2><p>网络层：从发送主机向接收主机传送数据段（segment），发送主机将数据段封装到数据报（datagram）中；接收主机向传输层交付数据段（segment）。每个主机和路由器都运行网络层协议（<strong>非端到端的</strong>），路由器检验所有穿越它的IP数据报的头部域，以决策如何处理IP数据报。</p><p>网络层<strong>核心功能：转发与路由</strong></p><ul><li>转发(forwarding)：将分组从路由器的输入端口转移到合适的输出端口<ul><li>转发表确定在本路由器如何转发分组</ul><li>路由(routing)：确定分组从源到目的经过的路径<ul><li>路由算法(协议)（routing algorithms）确定通过网络的端到端路径</ul></ul><blockquote><p>某些网络（如ATM, 帧中继, X.25）的重要功能：<strong>连接建立</strong>——数据分组传输之前两端主机需要首先建立虚拟/逻辑连接。网络设备（如路由器）参与连接的建立。</p><p>网络层连接与传输层连接的<strong>对比</strong>：</p><ul><li><p>网络层连接：两个主机之间 (路径上的路由器等网络设备参与其中)</p><li><p>传输层连接：两个应用进程之间（对中间网络设备透明）</p></ul></blockquote><p><strong>无连接服务(connection-less service)</strong>：如<strong>数据报网络(datagram network)</strong></p><ul><li><p>不事先为系列分组的传输确定传输路径</p><li><p>每个分组独立确定传输路径</p><li><p>不同分组可能传输路径不同</p></ul><p><strong>连接服务(connection service)</strong>：如<strong>虚电路网络(virtual-circuit network)</strong></p><ul><li><p>首先为系列分组的传输确定从源到目的经过的路径 (建立连接)</p><li><p>然后沿该路径（连接）传输系列分组，系列分组传输路径相同</p><li><p>传输结束后拆除连接</p></ul><blockquote><p>数据报网络与虚电路网络是典型两类分组交换网络</p><p>类似于传输层的无连接服务（UDP）和面向连接服务（TCP），但是网络层服务<strong>既有主机到主机的服务，也有网络核心的实现</strong></p></blockquote><h2 id="42-虚电路网络">4.2 虚电路网络</h2><p><strong>虚电路：一条从源主机到目的主机，类似于电路的路径(逻辑连接)</strong></p><ul><li><p>分组交换</p><li><p>每个分组的传输利用链路的全部带宽（实际的电路交换利用的是链路的部分资源，频率或时隙等）</p><li><p>源到目的路径经过的网络层设备共同完成虚电路功能</p></ul><p><strong>通信过程</strong>：呼叫建立(call setup)→数据传输→拆除呼叫</p><ul><li>1.初始呼叫 –&gt; 2. 呼叫到达 –&gt; 3.接受呼叫 –&gt; 4.呼叫建立 –&gt; 5.数据流开始 –&gt; 6.接收数据</ul><p>每条虚电路包括：</p><ol><li>从源主机到目的主机的一条路径<li>虚电路号 (VCID)， 沿路每段链路一个编号<li>沿路每个网络层设备（如路由器），<strong>利用转发表记录经过的每条虚电路</strong><ul><li>沿某条虚电路传输的分组，<strong>携带对应虚电路的VCID，而不是目的地址</strong>。因为同一条VC ，在每段链路上的VCID通常不同。路由器转发分组时依据转发表改写/替换虚电路号。</ul></ol><p><strong>虚电路经过的每个网络设备（如路由器），维护每条经过它的虚电路连接状态</strong></p><p>链路、网络设备资源(如带宽、缓存等)可以面向VC进行预分配</p><p><strong>虚电路信令协议(signaling protocols)</strong>：用于VC的建立、维护与拆除 (路径选择)；应用于虚电路网络，如ATM、帧中继 (frame-relay) 网络等；目前的Internet不采用</p><h2 id="43-数据报网络">4.3 数据报网络</h2><p>数据报网络是网络层无连接的，所以<strong>每个分组携带目的地址</strong>，路由器根据分组的目的地址转发分组。</p><p>路由器基于路由协议/算法构建转发表，检索转发表转发数据报，而转发表更新导致了每个分组独立选路。</p><p>转发表确定在本路由器如何转发分组，所以对于Internet网络来说，路由器就需要保存40多亿IP地址，显然检索效率会大大降低，所以它<strong>维护的是一个地址范围</strong>(聚合转发表入口)。如：</p><div class="table-wrapper"><table><thead><tr><th>目的地址范围<th>链路接口<tbody><tr><td>从11001000 00010111 00010<strong>000 00000000</strong><br />至11001000 00010111 00010<strong>111 11111111</strong><td>0<tr><td>从11001000 00010111 000110<strong>00 00000000</strong><br />至11001000 00010111 000110<strong>11 11111111</strong><td>1<tr><td>从11001000 00010111 000111<strong>00 00000000</strong><br />至11001000 00010111 000111<strong>11 11111111</strong><td>2<tr><td>其他（默认路由，默认路径）<td>3</table></div><p><strong>最长前缀匹配优先</strong>：在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口（entry）。</p><p>数据报网络与VC网络对比：</p><div class="table-wrapper"><table><thead><tr><th>Internet (数据报网络)<th>ATM (VC网络)<tbody><tr><td>链路类型众多，特点、性能各异，统一服务困难<td>电话网络演化而来<tr><td>计算机之间的数据交换：<br />“弹性”服务，没有严格时间需求<td>核心业务是实时对话：<br />严格的时间、可靠性需求，需要有保障的服务<tr><td>“智能”端系统 (计算机)<br />可以自适应、性能控制、差错恢复<td>“哑(dumb)” 端系统（非智能）<br />电话机、传真机<tr><td>简化网络，复杂“边缘”<td>简化“边缘”，复杂网络</table></div><h2 id="44-ip协议">4.4 IP协议</h2><p>Internet网络层主机、路由器网络层主要功能：</p><ul><li><p><strong>路由协议</strong>进行路径选择，生成路由表</p><li><p><strong>IP协议</strong>做出了寻址规约(conventions)，定义了数据报(分组)格式以及分组处理规约</p><li><p><strong>ICMP(互联网控制报文)协议</strong>提供差错报告、路由器“信令”</p></ul><blockquote><p>ICMP协议相当于IP协议的伴随协议，实现IP协议的同时一般也要实现ICMP协议</p></blockquote><h3 id="441-ip数据报">4.4.1 IP数据报</h3><div class="language-html highlighter-rouge"><div class="code-header"> <span text-data=" HTML "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="nt">&lt;table&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td&gt;</span>0<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>4<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>8<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>12<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>16<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>20<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>24<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td&gt;</span>31<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"4"</span><span class="nt">&gt;&lt;b&gt;</span>版本号<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>4→IPv4<span class="nt">&lt;br/&gt;</span>6 → IPv6<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"4"</span><span class="nt">&gt;&lt;b&gt;</span>首部长度<span class="nt">&lt;/b&gt;</span>：IP分组首部长度，以4字节为单位<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>服务类型(TOS)<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>指示期望获得哪种类型的服务，只有在网络提供区分服务时使用，一般情况下不使用，Internet不提供区分服务，所以通常IP分组里该值为00H<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"16"</span><span class="nt">&gt;&lt;b&gt;</span>总长度<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>IP分组的总字节数(首部+数据)<span class="nt">&lt;br/&gt;</span>最大65535B，最小20B<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"16"</span> <span class="na">rowspan=</span><span class="s">"2"</span><span class="nt">&gt;&lt;b&gt;</span>标识<span class="nt">&lt;/b&gt;</span>：IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"3"</span><span class="nt">&gt;&lt;b&gt;</span>标志位<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>DF(Don'tFragment)为1禁止分片；为0允许分片;<span class="nt">&lt;br/&gt;</span>MF(MoreFragment)为1非最后一片；为0最后一片(或未分片)<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"12"</span> <span class="na">rowspan=</span><span class="s">"2"</span><span class="nt">&gt;&lt;b&gt;</span>片偏移<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>一个IP分组分片封装原IP分组数据的
相对偏移量，片偏移字段以8字节为单位<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td&gt;</span>保留<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td&gt;</span>DF<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td&gt;</span>MF<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>生存时间(TTL)<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>IP分组在网络中可以通过的路由器数(跳步数)，路由器转发一次分组，TTL减1；如果TTL=0，路由器则丢弃该IP分组并向源主机发送一个ICMP数据包<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>协议<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>指示IP分组封装的是哪个协议的数据包，它实现复用/分解<span class="nt">&lt;br/&gt;</span>6为TCP，表示封装的为TCP段；17为UDP，表示封装的是UDP数据报<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"16"</span><span class="nt">&gt;&lt;b&gt;</span>首部检验和<span class="nt">&lt;/b&gt;</span>：<span class="nt">&lt;br/&gt;</span>实现对IP分组首部的差错检测。计算校验和时，该字段置全0；采用反码算数运算求和，和的反码作为首部校验和字段；逐跳计算、逐跳校验<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;&lt;b&gt;</span>源IP地址<span class="nt">&lt;/b&gt;</span>：标识发送分组的源主机/路由器(网络接口)的IP地址<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;&lt;b&gt;</span>目的IP地址<span class="nt">&lt;/b&gt;</span>：标识接收分组的目的主机/路由器(网络接口)的IP地址<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"24"</span><span class="nt">&gt;&lt;b&gt;</span>选项字段<span class="nt">&lt;/b&gt;</span>：长度可变，范围在1~40B之间：携带安全、源选路径、时间戳和路由记录等内容，但实际上很少被使用<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>填充<span class="nt">&lt;/b&gt;</span>：范围在0~3B之间：补齐整个首部，符合32位对齐，即保证首部长度是4字节的倍数<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;</span>数据<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20211201192004289.png" alt="image-20211201192004289" /></p><h3 id="442-ip分片">4.4.2 IP分片</h3><p><strong>最大传输单元</strong>(MTU)：链路层数据帧<strong>可封装数据</strong>的上限。不同链路的MTU不同，所以就导致一个分组在一条链路上可以传输，但在下一条链路上传输可能需要被拆分。</p><blockquote><p>1个IP分组分为多片IP分组，IP分片<strong>到达目的主机后进“重组”</strong>(reassembled)</p><p>IP首部的相关字段用于标识分片以及确定分片的相对顺序：总长度、标识、标志位和片偏移</p></blockquote><p><strong>分片过程</strong>：假设原IP分组总长度为L，待转发链路的MTU为M。若L&gt;M，且DF=0，则可以/需要分片。通常分片时，<strong>每个分片的标识复制原IP分组的标识</strong>，除最后一个分片，其他分片均分为MTU允许的最大分片。</p><p>一个最大分片可封装的数据应该是8的倍数，因此，一个最大分片可封装的数据为：$\displaystyle d=\lfloor\frac {M-20} 8\rfloor\times 8$</p><p>需要的总片数为：$\displaystyle n=\lceil\frac {L-20} d \rceil$</p><p>每片的片偏移字段取值为：$\displaystyle F_i=\frac d 8 \times (i-1),\; 1\le i\le n$</p><p>每片的总长度字段为：$L_i=\begin{cases} d+20 &amp; 1\le i\le n \\ L-(n-1)d &amp; i=n \end{cases}$</p><p>每片的MF标志位为：$MF_i=\begin{cases}1&amp;1\le i\lt n \\ 0 &amp; i=n\end{cases}$</p><h3 id="443-ip编址">4.4.3 IP编址</h3><p><strong>接口(interface)</strong>：主机/路由器与物理链路的连接。它实现网络层功能。</p><p><strong>IP地址</strong>：32比特(IPv4)编号标识主机、路由器的接口。IP地址与每个接口关联，由于一个主机通常只有一个接口，所以通常也叫主机地址而不是接口地址。</p><blockquote><p>路由器通常有多个接口，而主机通常只有一个或两个接口 (e.g.，有线的以太网接口，无线的802.11接口)</p></blockquote><p>将IP地址的高位比特称为<strong>网络号(NetID)</strong>，低位比特称为**主机号(HostID) **。</p><p><strong>IP子网</strong>：IP地址具有相同网络号的设备接口，不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口。</p><h3 id="444-有类ip地址">4.4.4 有类IP地址</h3><p>“有类”编址：</p><ul><li><p>A类地址 (50%)：NetID(8位) HostID(24位)，最高位为0</p><blockquote><p>0.0.0.0~127.255.255.255</p></blockquote><li><p>B类地址 (25%)：NetID(16位) HostID(16位)，最高两位为10</p><blockquote><p>128.0.0.0~191.255.255.255</p></blockquote><li><p>C类地址 (12.5%)：NetID(24位) HostID(8位)，最高三位为110</p><blockquote><p>192.0.0.0~223.255.255.255</p></blockquote><li><p>D类地址 (6.25%)：32位HostID，最高四位为1110</p><blockquote><p>224.0.0.0~239.255.255.255</p></blockquote><li><p>E类地址 (6.25%)：32位HostID，最高四位为1111</p><blockquote><p>240.0.0.0~255.255.255.255</p></blockquote></ul><blockquote><p>D类地址不再区分网络号和主机号，用于标识互联网中的一组主机，这些主机理论上可以分布在互联网的每个地方。只能作为目的地址，称为多播地址。</p><p>E类地址保留，作为研究使用。</p></blockquote><h4 id="4441-特殊ip地址">4.4.4.1 特殊IP地址</h4><div class="table-wrapper"><table><thead><tr><th>NetID<th>HostID<th>作为IP分组源地址<th>作为IP分组目的地址<th>用途<tbody><tr><td>全0<td>全0<td>可以<td>不可以<td>在本网范围内表示本机；在路由表中用于表示默认路由(相当于表示整个Internet网络)<tr><td>全0<td>特定值<td>不可以<td>可以<td>表示本网内某个特定主机<tr><td>全1<td>全1<td>不可以<td>可以<td><strong>本网广播</strong>地址(路由器不转发)<tr><td>特定值<td>全0<td>不可以<td>可以<td>网络地址，表示一个网络<tr><td>特定值<td>全1<td>不可以<td>可以<td><strong>直接广播</strong>地址，对特定网络上的所有主机进行广播<tr><td>127<td>非全0或非全1的任何数<td>可以<td>可以<td>用于本地软件环回测试，称为环回地址</table></div><h4 id="4442-私有ip地址">4.4.4.2 私有IP地址</h4><div class="table-wrapper"><table><thead><tr><th>Class<th>NetID<th>Blocks<tbody><tr><td>A<td>10<td>1<tr><td>B<td>172.16 到 172.31<td>16<tr><td>C<td>192.168.0 到 192.168.255<td>256</table></div><h3 id="445-ip子网划分与子网掩码">4.4.5 IP子网划分与子网掩码</h3><p><strong>子网划分</strong>：ABC类IP子网还是过大，继续划分一个IP子网为更小范围网络。</p><p><strong>IP地址</strong>：高位比特为网络号(NetID) ；<strong>原网络主机号部分高位比特为子网号(SubID)</strong>；低位比特为主机号(HostID)。</p><p><strong>子网掩码</strong>：形如IP地址，也是32位，写成点分十进制形式。取值：NetID、SubID位全取1，HostID位全取0</p><blockquote><ul><li><p>A网的默认子网掩码为：255.0.0.0</p><li><p>B网的默认子网掩码为：255.255.0.0</p><li><p>C网的默认子网掩码为：255.255.255.0</p><li><p>借用3比特划分子网的B网的子网掩码为：255.255.224.0</p></ul></blockquote><p>利用<strong>子网地址+子网掩码</strong>准确确定子网大小，将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址。</p><blockquote><p>例：目的IP地址：172.32.1.112，子网掩码：255.255.254.0</p><p>172.32.1.112 = 10101100 00100000 00000001 01110000</p><p>255.255.254.0= 11111111 11111111 11111110 00000000</p><p>位与运算：10101100 00100000 00000000 00000000 = 172.32.0.0</p><ul><li>子网地址：172.32.0.0(子网掩码：255.255.254.0)<li>地址范围：172.32.0.0~172.32.1.255<li>可分配地址范围：172.32.0.1~172.32.1.254<li>广播地址：172.32.1.255</ul></blockquote><p>子网的划分会导致一些损失，因为使得每个子网的开头(子网地址)和末尾(广播地址)的地址不能分配给路由器或主机使用，但带来了性能的提升。</p><h3 id="446-cidr与路由聚集">4.4.6 CIDR与路由聚集</h3><p><strong>无类域间路由(CIDR：Classless InterDomain Routing)</strong>：</p><ul><li><p>消除传统的 A 类、B 类和 C 类地址界限：NetID+SubID→Network Prefix (Prefix)可以任意长度。</p><li><p>融合子网地址与子网掩码，方便子网划分：无类地址格式：a.b.c.d/x，其中x为前缀长度</p><blockquote><p>例如：子网201.2.3.64，255.255.255.192 → 201.2.3 .64/26</p></blockquote><li>提高IPv4 地址空间分配效率<li>提高路由效率： 将多个子网聚合为一个较大的子网，构造超网(supernetting)；<strong>路由聚合(route aggregation)</strong></ul><p><strong>选用更具体的路由：最长前缀匹配优先！</strong>路由聚合以后，如果聚合后的子网缺少了一部分，则在路由器的路由表中一定会有多条路由表项，于是在路由的时候就需要最长前缀匹配优先。</p><h2 id="45-dhcp协议">4.5 DHCP协议</h2><p><strong>动态主机配置协议(DHCP：Dynamic Host Configuration Protocol)</strong>：</p><ul><li><p>从服务器动态获取：IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址</p><li><p>“即插即用”</p><li><p>允许地址重用</p><li><p>支持在用地址续租</p><li><p>支持移动用户加入网络</p></ul><p><strong>DHCP工作过程</strong>：</p><ul><li>主机广播<strong>“DHCP discover”(发现报文)</strong><li>DHCP服务器利用<strong>“DHCP offer” (提供报文)</strong> 进行响应<li>主机请求IP地址：<strong>“DHCP request” (请求报文)</strong><li>DHCP服务器分配IP地址：<strong>“DHCP ack” (确认报文)</strong></ul><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201015230343218.png" alt="image-20201015230343218" /></p><p><strong>DHCP协议在应用层实现</strong>：请求报文封装到UDP数据报中 –&gt; IP广播 –&gt; 链路层广播(e.g. 以太网广播)</p><p><strong>DHCP服务器构造ACK报文</strong>：包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址</p><h2 id="46-nat">4.6 NAT</h2><p>设计动机：</p><ul><li>只需从ISP申请一个IP地址：由于IPv4地址耗尽<li>本地网络设备IP地址的变更，无需通告外界网络<li>变更ISP时，无需修改内部网络设备IP地址<li>内部网络设备对外界网络不可见，即不可直接寻址(安全)</ul><p>实现：</p><ol><li>替换：利用<strong>(NAT IP地址,新端口号)</strong>替换每个外出IP数据报的<strong>(源IP地址,源端口号)</strong><li>记录：将每对<strong>(NAT IP地址, 新端口号)</strong>与<strong>(源IP地址, 源端口号)</strong>的替换信息存储到<strong>NAT转换表</strong>中<li>替换：根据NAT转换表，利用<strong>(源IP地址, 源端口号)</strong>替换每个进入内网IP数据报的<strong>(目的IP地址,目的端口号)</strong>，即(NAT IP地址, 新端口号)</ol><p>NAT存在的争议：</p><ul><li>路由器应该只处理第3层功能，但NAT更改了第四层的数据。<li>违背端到端通信原则：传输层是端到端的，即对第三层设备路由器等应该是透明的，应用开发者必须考虑到NAT的存在，e.g., P2P应用<li>地址短缺问题应该由IPv6来解决</ul><p>NAT穿透的解决方案：</p><ol><li>静态配置NAT，将特定端口的连接请求转发给服务器。<ul><li>例如(138.76.29.7, 2500)总是转发给(10.0.0.1, 25000)</ul><li>利用UPnP(Universal Plug and Play)互联网网关设备协议 (IGD-Internet Gateway Device )自动配置。<ul><li>学习到NAT公共IP地址(138.76.29.7)，然后在NAT转换表中，(自动)增删端口映射</ul><li>中继(如Skype)。NAT内部的客户与中继服务器建立连接；外部客户也与中继服务器建立连接；中继服务器桥接两个连接的分组。</ol><h2 id="47-icmp">4.7 ICMP</h2><p><strong>互联网控制报文协议 ICMP</strong> (Internet Control Message Protocol)支持主机或路由器完成<strong>差错(或异常)报告</strong>和<strong>网络探询</strong>。</p><h3 id="471-icmp报文">4.7.1 ICMP报文</h3><ul><li>差错报告报文 (5种)<ul><li>目的不可达：无法到达目的或已到达但无法交付给目的<li>源抑制(Source Quench)：用于网络层的拥塞控制，路由器发现缓存已满时构造此类报文发给源主机，但目前的Internet中并无此类拥塞控制<li>超时/超期：TTL超时后，路由器丢弃报文并构造此类报文发给源主机<li>参数问题：报文头部某些字段头问题<li>重定向 (Redirect)：在路由器看来此报文不应由自己来转发，而应由其他路由器转发</ul><li>网络探询报文<ul><li>回声(Echo)请求与应答报文(Reply)：探测网络是否可达<li>时间戳请求与应答报文：获取时间戳</ul></ul><blockquote><p>几种 ICMP 报文已不再使用：信息请求与应答报文；子网掩码请求和应答报文；路由器询问和通告报文</p></blockquote><p>几种<strong>不发送 ICMP差错报告报文的特殊情况</strong>：</p><ul><li><p>对ICMP差错报告报文不再发送 ICMP差错报告报文</p><li><p>除第1个IP数据报分片外，对所有后续分片均不发送ICMP差错报告报文</p><li><p>对所有多播IP数据报均不发送 ICMP差错报告报文</p><li><p>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的IP数据报不发送ICMP 差错报告报文</p></ul><h3 id="472-icmp报文格式">4.7.2 ICMP报文格式</h3><p>ICMP报文封装到IP数据报中传输</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201021221510753.png" alt="image-20201021221510753" /></p><p>ICMP差错报告报文数据封装</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201021222028966.png" alt="image-20201021222028966" /></p><ul><li>IP数据报的数据字段是<strong>UDP数据报</strong>时，前8个字节就是整个UDP头<li>IP数据报的数据字段是<strong>TCP数据报</strong>时，前8个字节包含了源地址、源端口号，目的地址、目的端口号等重要信息</ul><h3 id="473-icmp的应用traceroute">4.7.3 ICMP的应用：Traceroute</h3><p>探测路径上的所有路由器：</p><ol><li><p>源主机向目的主机发送一系列UDP数据报：第1组IP数据报TTL =1，第2组IP数据报TTL=2, …。要保证目的端口号为不可能使用的端口号。</p><li><p>这样当第n组数据报(TTL=n)到达第n个路由器时：路由器丢弃数据报，向源主机发送<strong>携带路由器名称和IP地址信息</strong>的ICMP报文(type=11, code=0)。当ICMP报文返回到源主机时，记录RTT</p><li><p><strong>停止准则</strong>：UDP数据报最终到达目的主机，目的主机返回“目的端口不可达”ICMP报文 (type=3,code=3)，此时源主机停止。</p></ol><h2 id="48-ipv6">4.8 IPv6</h2><p>最初动机：32位IPv4地址空间已分配殆尽</p><p>其他动机：改进首部格式——支持快速处理/转发数据报；支持QoS</p><h3 id="481-ipv6数据报格式">4.8.1 IPv6数据报格式</h3><p>固定长度的40字节基本首部</p><p>不允许分片：只能由源主机分，目的主机组</p><div class="language-html highlighter-rouge"><div class="code-header"> <span text-data=" HTML "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="nt">&lt;table&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td&gt;</span>0<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>4<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>8<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>12<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>16<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>20<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;</span>
        <span class="nt">&lt;td&gt;</span>24<span class="nt">&lt;/td&gt;&lt;td/&gt;&lt;td/&gt;&lt;td&gt;</span>31<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"4"</span><span class="nt">&gt;&lt;b&gt;</span>版本号<span class="nt">&lt;/b&gt;&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>优先级(priority)<span class="nt">&lt;/b&gt;</span>：标识数据报的优先级<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"20"</span><span class="nt">&gt;&lt;b&gt;</span>流标签(flow Label)<span class="nt">&lt;/b&gt;</span>: 标识同一“流”中的数据报<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"16"</span>  <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;&lt;b&gt;</span>载荷长度<span class="nt">&lt;/b&gt;</span>：最大64KB<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>下一个首部<span class="nt">&lt;/b&gt;</span>：标识下一个选项首部或上层协议首部(如TCP首部)。如果有扩展首部则指向扩展首部位置，同时每个扩展首部的此字段指向下个扩展首部，最后一个扩展首部指向上层协议首部<span class="nt">&lt;/td&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"8"</span><span class="nt">&gt;&lt;b&gt;</span>跳步限制<span class="nt">&lt;/b&gt;</span>: 对应于TTL<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;&lt;b&gt;</span>源IP地址<span class="nt">&lt;/b&gt;</span>(128位)<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;&lt;b&gt;</span>目的IP地址<span class="nt">&lt;/b&gt;</span>(128位)<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td</span> <span class="na">colspan=</span><span class="s">"32"</span><span class="nt">&gt;</span>载荷（扩展首部+数据）<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20211201192049799.png" alt="image-20211201192049799" /></p><p>与IPv4相比的变化：</p><ul><li>校验和(checksum)：彻底移除，以减少每跳处理时间<li>选项(options)：允许，但是从基本首部移出，定义多个选项首部，通过“下一个首部”字段指示<li>ICMPv6：新版ICMP<ul><li>附加报文类型，e.g. “Packet Too Big”——分组过大直接丢弃，发送此报文<li>多播组管理功能</ul></ul><h3 id="482-ipv6地址">4.8.2 IPv6地址</h3><p><strong>IPv6地址表示形式</strong></p><ul><li><p>一般形式：1080:0:FF:0:8:800:200C:417A</p><li><p>压缩形式：FF01:0:0:0:0:0:0:43，压缩→FF01::43</p><li><p>IPv4-嵌入形式：0:0:0:0:0:FFFF:13.1.68.3 或 ::FFFF:13.1.68.3</p><li><p>地址前缀：2002:43c:476b::/48</p><blockquote><p>IPv6不再使用掩码，统一使用CIDR</p></blockquote><li><p>URLs：http://[3FFE::1:800:200C:417A]:8000</p></ul><p><strong>IPv6基本地址类型</strong></p><ul><li><p>单播(unicast)：一对一通信</p><li><p>多播(multicast)：一对多通信</p><li><p>任意播(anycast)：一对一组之一（最近一个）通信</p></ul><blockquote><p>没有广播地址，定义为一个特殊的多播地址。</p></blockquote><p>不可能在某个时刻所有路由器同时被更新为IPv6，所以IPv4和IPv6路由器共存，使用隧道协议使其共存。</p><p><strong>隧道(tunneling)</strong>：IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络</p><h2 id="49-路由算法">4.9 路由算法</h2><p>网络抽象：图G = (N, E)，N = 路由器集合，E = 链路集合</p><p>费用(Costs)：每段链路的费用可以总是1，或者是，带宽的倒数、拥塞程度等</p><blockquote><p>图的抽象在网络领域应用很广泛 e.g.:P2P，其中，N是 peers集合，而E是TCP连接集合</p></blockquote><p>关键问题：源到目的（如u到z）的最小费用路径是什么？</p><p>路由算法：寻找最小费用路径的算法</p><p><strong>路由算法分类</strong></p><ul><li><p><strong>静态</strong>路由：手工配置；路由更新慢；优先级高</p><li><p><strong>动态</strong>路由：路由更新快；定期更新；及时响应链路费用或网络拓扑变化</p><li><p><strong>全局信息</strong>：所有路由器掌握完整的网络拓扑和链路费用信息。e.g. 链路状态(LS)路由算法</p><li><p><strong>分散(decentralized)信息</strong>：路由器只掌握物理相连的邻居以及链路费用，邻居间信息交换、运算的迭代过程。e.g. 距离向量(DV)路由算法</p></ul><h3 id="491-链路状态路由算法">4.9.1 链路状态路由算法</h3><p><strong>Dijkstra 算法</strong></p><ul><li><p>所有结点(路由器)掌握网络拓扑和链路费用：通过“链路状态广播”；所有结点拥有相同信息</p><li><p>计算从一个结点(“源”)到达所有其他结点的最短路径：获得该结点的转发表</p><li><p>迭代：k次迭代后，得到到达k个目的结点的最短路径</p></ul><blockquote><p><strong>c(x,y)</strong>：结点x到结点y链路费用；如果x和y不直接相连，则=∞</p><p><strong>D(v)</strong>：从源到目的v的当前路径费用值</p><p><strong>p(v)</strong>：沿从源到v的当前路径，v的前序结点</p><p><strong>N’</strong>：已经找到最小费用路径的结点集合</p></blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>初始化:
N' = {u}
for 所有结点v
	if v毗邻u
		then D(v) = c(u,v)
	else D(v) = ∞

Loop
	找出不在 N’中的w ，满足D(w)最小
	将w加入N'
	更新w的所有不在N’中的邻居v的D(v) :
 		D(v) = min( D(v), D(w) + c(w,v) )
	 /*到达v的新费用或者是原先到达v的费用，或者是已知的到达w的最短路径费用加上w到v的费用 */
until 所有结点在N’中
</pre></table></code></div></div><p>算法存在<strong>震荡</strong>(oscillations)可能：假设链路费用是该链路承载的通信量。初始为图1，此时会认为图2的代价更小，更新路由表为图2，又认为图3的代价更小，更新路由表为图3，又认为图2的代价更小，如此往复。如果一个B发往A的数据报恰好遇上了每次更新路由表，那么它将一直在B和B和D之间转发，直到TTL耗尽。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201023125543508.png" alt="image-20201023125543508" /></p><h3 id="492-距离向量路由算法">4.9.2 距离向量路由算法</h3><p><strong>核心：Bellman-Ford方程</strong>(动态规划)</p><p>令d~x~(y)=从x到y最短路径的费用（距离），则d~x~(y) = min~v~ {c(x,v) + d~v~(y) }</p><p>x到邻居v的费用 + 从邻居v到达目的y的费用（距离），在x的所有邻居v中取最小值</p><p><strong>重点：结点获得最短路径的下一跳, 该信息用于转发表中</strong></p><p>由于从结点x到结点y的最小费用未知，则需要对其估计，D~x~(y) = 从结点x到结点y的最小费用估计。x维护距离向量(DV)：D~x~ = [D~x~(y): y є N ]</p><p>结点x已知到达每个邻居的费用为c(x,v)，就能维护其所有邻居的距离向量：D~v~ = [D~v~(y): y є N ]</p><p><strong>核心思想</strong>：每个结点不定时地将其自身的DV估计发送给其邻居，当x接收到邻居的新的DV估计时，即依据B-F更新其自身的距离向量估计：D~x~(y) ← min~v~{c(x,v) + D~v~(y)} for each node y ∊ N。D~x~(y)将最终收敛于实际的最小费用 d~x~(y)。</p><p><strong>距离向量路由算法的特点</strong>：</p><ul><li><p><strong>异步迭代</strong>：引发每次局部迭代的因素：局部链路费用改变或来自邻居的DV更新。</p><li><p><strong>分布式</strong>：每个结点只当DV<strong>变化时才通告给邻居</strong>，邻居在必要时（其DV更新后发生改变）再通告它们的邻居。</p></ul><blockquote><p>好消息(链路费用降低)传播快，坏消息(链路费用增大)传播慢——<strong>无穷计数问题</strong></p></blockquote><p>消除无穷计数问题：</p><ul><li><strong>毒性逆转(poisoned reverse)</strong>：如果一个结点到达某目的的最小费用路径是通过某个邻居，则通告给该邻居结点到达该目的的距离为<strong>无穷大</strong><li><strong>定义最大度量(maximum metric)</strong>：定义一个最大的有效费用值，如15跳步，16跳步表示∞</ul><h3 id="483-层次路由">4.8.3 层次路由</h3><p>将任意规模网络抽象为一个图计算路由过于理想化，标识所有路由器，将整个网络抽象成一个“扁平”网络在实际网络（尤其是大规模网络）中不可行：</p><ul><li><p><strong>网络规模</strong>：考虑6亿目的结点的网络：路由表几乎无法存储，路由计算过程的信息（e.g. 链路状态分组、DV）交换量巨大，会淹没链路。</p><li><p><strong>管理自治</strong>：每个网络的管理可能都期望自主控制其网内的路由；互联网(internet) = 网络之网络(network of networks)</p></ul><p>为此提出了<strong>层次路由</strong>。</p><p><strong>聚合路由器为一个区域——自治系统AS(autonomous systems)</strong>：同一AS内的路由器运行相同的路由协议(算法)</p><ul><li><p>自治系统内部路由协议(“intra-AS” routing protocol)：只知道自己系统内的网络拓扑结构。</p><li><p>不同自治系统内的路由器可以运行不同的AS内部路由协议</p></ul><p><strong>网关路由器(gateway router)</strong>：在不同AS之间路由，位于AS“边缘”；通过链路连接其他AS的网关路由器</p><p><strong>自治系统间(Inter-AS)路由任务</strong>：</p><ul><li>确定路由器应该将该数据报转发给哪个网关路由器：网关路由器必须学习到哪些目的网络可以通过那个邻网到达，并将这些网络可达性信息传播给本网络内部路由器。<li>到达某网络有多条路径，需要去确定在多AS间选择。策略：<strong>热土豆路由</strong>：将分组发送给最近的网关路由器.</ul><h3 id="484-internet路由">4.8.4 Internet路由</h3><p>Internet采用层次路由</p><p>AS内部路由协议也称为内部网络协议<strong>IGP</strong>(interior gateway protocols)，最常见的AS内部路由协议：</p><ul><li><p>路由信息协议：RIP(Routing Information Protocol)</p><li><p>开放最短路径优先：OSPF(Open Shortest Path First)</p><li><p>内部网关路由协议：IGRP(Interior Gateway Routing Protocol)：Cisco私有协议</p></ul><h4 id="4841-rip">4.8.4.1 RIP</h4><p>基于距离向量路由算法：</p><ul><li><p>距离度量：跳步数 (max = 15 hops)，每条链路1个跳步</p><li><p>每隔30秒，邻居之间交换一次DV，成为通告(advertisement)</p><li><p>每次通告：最多25个目的子网(IP地址形式)</p></ul><p><strong>链路失效、恢复</strong>：如果<strong>180秒没有收到通告则推断邻居/链路失效</strong>，经过该邻居的路由不可用，重新计算路由；向邻居发送新的通告；邻居再依次向外发送通告（如果转发表改变）；可能发生无穷计数问题 (定义最大度量技术)；毒性逆转技术用于预防乒乓(ping-pong)环路(另外：无穷大距离 = 16 hops)</p><blockquote><p>适用于小规模的自治系统，超过15跳的系统RIP不再适用。</p></blockquote><p>RIP路由表是利用一个称作route-d (daemon)的应用层进程进行管理，告报文周期性地通过UDP数据报发送。</p><h4 id="4842-ospf">4.8.4.2 OSPF</h4><blockquote><p>OSPF (Open Shortest Path First) “开放”：公众可用，非私有。</p></blockquote><p>采用链路状态路由算法</p><ul><li>LS分组扩散（通告）<li>每个路由器构造完整的网络(AS)拓扑图<li>利用Dijkstra算法计算路由<li>OSPF通告中每个入口对应一个邻居<li>OSPF通告在整个AS范围泛洪，<strong>OSPF报文直接封装到IP数据报中</strong></ul><blockquote><p>与OSPF极其相似的一个路由协议：<strong>IS-IS路由协议</strong></p></blockquote><p>OSPF优点：</p><ul><li>安全(security)：所有OSPF报文可以被认证(预防恶意入侵)<li>允许使用<strong>多条相同费用的路径</strong> (RIP只能选一条)：负载均衡<li>对于每条链路，可以针对不同的TOS设置多个不同的费用度量 (e.g., 卫星链路可以针对“尽力”(best effort) ToS设置“低”费用；针对实时ToS设置“高”费用)：实现不同类型数据的分流<li>集成单播路由与多播路由：多播OSPF协议(MOSPF) 与OSPF利用相同的网络拓扑数据<li><strong>OSPF支持对大规模AS分层(hierarchical)</strong></ul><p><strong>分层的OSPF</strong>：两级分层</p><ul><li><strong>局部区(Area)，主干区(Backbone)</strong><ul><li>链路状态通告只限于区内<li>每个路由器掌握所在区的详细拓扑<li>只知道去往其他区网络的“方向” (最短路径)</ul><li><strong>区边界路由器(Area Border Routers)</strong>：“汇总”到达所在区网络的距离，通告给其他区边界路由器。<li><strong>主干路由器(Backbone Routers)</strong>：在主干区内运行OSPF路由算法。<li><strong>AS边界路由器(AS boundary routers)</strong>：连接其他AS。</ul><h4 id="4843-bgp">4.8.4.3 BGP</h4><p><strong>Internet AS间路由协议：边界网关协议</strong>BGP (Border Gateway Protocol)，事实上的标准域间路由协议，将Internet “粘合”为一个整体的关键。</p><p>BGP为每个AS提供了一种手段：</p><ul><li><p><strong>eBGP</strong>：从邻居AS获取子网可达性信息.</p><li><strong>iBGP</strong>：向所有AS内部路由器传播子网可达性信息.<li>基于可达性信息与策略，确定到达其他网络的 “好”路径</ul><p><strong>容许子网向Internet其余部分通告它的存在。</strong></p><p><strong>BGP会话(session)</strong>：两个BGP路由器 (“Peers”)交换BGP报文：实现通告去往不同目的<strong>前缀（prefix）的路径 **(路径向量(path vector)协议)。报文交换基于</strong>半永久的TCP**连接。</p><p><strong>BGP报文</strong>：</p><ul><li>OPEN：与peer建立TCP连接，并认证发送方<li>UPDATE：通告新路径 (或撤销原路径)<li>KEEPALIVE：在无UPDATE时，保活连接；也用于对OPEN请求的确认<li>NOTIFICATION：报告先前报文的差错；也被用于关闭连接</ul><blockquote><p>当AS3通告一个前缀给AS1时：AS3承诺可以将数据报转发给该子网；AS3在通告中会聚合网络前缀。</p></blockquote><p><strong>路径属性与BGP路由</strong>：通告的前缀信息包括BGP属性：前缀+属性= “路由”</p><p>两个重要属性：</p><ul><li><p><strong>AS-PATH(AS路径)</strong>：包含前缀通告所经过的AS序列。e.g., AS 67,AS 17</p><li><p><strong>NEXT-HOP(下一跳)</strong>：开始一个AS-PATH的路由器接口，指向下一跳AS。</p><blockquote><p>可能从当前AS到下一跳AS存在多条链路</p></blockquote></ul><p><strong>BGP路由选择</strong>，<strong>基于策略(policy-based) 路由</strong>：网关路由器收到路由通告后，利用其<strong>输入策略</strong>(import policy)决策接受/拒绝该路由。e.g., 从不将流量路由到AS x。</p><p>路由器可能获知到达某目的AS的多条路由，基于以下准则选择：</p><ol><li>本地偏好(preference)值属性：<strong>策略决策</strong>(policydecision)<li><strong>最短AS-PATH</strong><li><strong>最近NEXT-HOP</strong>路由器：热土豆路由(hot potato routing)<li>附加准则</ol><blockquote><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201026092054246.png" alt="image-20201026092054246" /></p><ul><li><p>A,B,C是提供商网络/AS(provider network/AS)</p><li><p>X,W,Y是客户网络(customer network/AS)</p><li>W,Y是桩网络(stub network/AS)：只与一个其他AS相连<li>X是双宿网络(dual-homed network/AS)：连接两个其他AS X不期望经过他路由B到C的流量，因此，X不会向B通告任何一条到达C的路由<li>A向B通告一条路径：AW<li>B向X通告路径：BAW<li>B不应该向C通告路径BAW，因为B路由CBAW的流量没有任何“收益”，因为W和C均不是B的客户。B期望强制C通过A向W路由流量；期望只路由去往/来自其客户的流量！</ul></blockquote><p>采用不同的AS内与AS间路由协议的原因：</p><ul><li>策略(policy)：<ul><li>inter-AS：期望能够管理控制流量如何被路由，谁路由经过其网络等.<li>intra-AS：单一管理，无需策略决策</ul><li>规模(scale)：<ul><li>层次路由节省路由表大小，减少路由更新流量<li>适应大规模互联网</ul><li>性能(performance)：<ul><li>intra-AS：侧重性能<li>inter-AS：策略主导</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a> <a href="/tags/hitcn/" class="post-tag no-text-decoration" >HITCN</a> <a href="/tags/2020%E7%A7%8B/" class="post-tag no-text-decoration" >2020秋</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=4 网络层 - XuJian&url=https://beiyanluansheng.github.io//posts/4-NetworkLayer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=4 网络层 - XuJian&u=https://beiyanluansheng.github.io//posts/4-NetworkLayer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=4 网络层 - XuJian&url=https://beiyanluansheng.github.io//posts/4-NetworkLayer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nas/">使用Docker部署NAS</a><li><a href="/posts/route/">使用Docker部署OpenWRT旁路由</a><li><a href="/posts/10-dockerDeploy/">OES之十：Dcoker部署</a><li><a href="/posts/9-file/">OES之九：文件上传下载</a><li><a href="/posts/5-passValue/">OES之五：请求接口</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT-FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-Introdution/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T10:56:33+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1 概述</h3><div class="text-muted small"><p> 1.1 计算机网络 1.1.1 计算机网络与Internet 计算机网络：计算机网络就是互连的、自治的计算机集合。 自治：无主从关系 互连：互联互通——通信链路。通过交换网络互连主机，在距离远、数量大时保证互连。 Internet：全球最大的互联网络。ISP(Internet Service Provider) 网络互连的“网络之网络” 数以百万计的互连的计算设备...</p></div></div></a></div><div class="card"> <a href="/posts/2-ApplicationLayer/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T21:41:25+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2 应用层</h3><div class="text-muted small"><p> 2.1 基本原理 2.1.1 网络应用的体系结构 客户机/服务器结构(Client-Server, C/S) 服务器：7*24小时提供服务；永久性访问地址/域名；利用大量服务器实现可扩展性 客户机：与服务器通信，使用服务器提供的服务；间歇性接入网络；可能使用动态IP地址；不会与其他客户机直接通信 Web应用 ...</p></div></div></a></div><div class="card"> <a href="/posts/3-TransportLayer/"><div class="card-body"> <span class="timeago small" >2020-12-09<i class="unloaded">2020-12-09T14:22:08+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>3 传输层</h3><div class="text-muted small"><p> 网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制 3.1 多路复用和多路分用 多路复用（发送端）：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络层 多路分用（接收端）：传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程工作方式： 主机接收IP数据报：每个数据报携带源IP地...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/3-TransportLayer/" class="btn btn-outline-primary" prompt="上一篇"><p>3 传输层</p></a> <a href="/posts/5-DataLinkLayer/" class="btn btn-outline-primary" prompt="下一篇"><p>5 数据链路层</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.facebook.com/BeiyanLuansheng">XuJian</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
