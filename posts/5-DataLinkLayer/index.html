<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="5 数据链路层" /><meta name="author" content="BeiyanLuansheng" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="5.1 数据链路层服务" /><meta property="og:description" content="5.1 数据链路层服务" /><link rel="canonical" href="https://beiyanluansheng.github.io//posts/5-DataLinkLayer/" /><meta property="og:url" content="https://beiyanluansheng.github.io//posts/5-DataLinkLayer/" /><meta property="og:site_name" content="XuJian" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-11T22:09:24+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="5 数据链路层" /><meta name="twitter:site" content="@BeiyanLuansheng" /><meta name="twitter:creator" content="@BeiyanLuansheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BeiyanLuansheng"},"dateModified":"2020-12-11T22:09:24+08:00","datePublished":"2020-12-11T22:09:24+08:00","description":"5.1 数据链路层服务","headline":"5 数据链路层","mainEntityOfPage":{"@type":"WebPage","@id":"https://beiyanluansheng.github.io//posts/5-DataLinkLayer/"},"url":"https://beiyanluansheng.github.io//posts/5-DataLinkLayer/"}</script><title>5 数据链路层 | XuJian</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XuJian"><meta name="application-name" content="XuJian"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XuJian</a></div><div class="site-subtitle font-italic">BeiyanLuansheng</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/BeiyanLuansheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/BeiyanLuansheng" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['beiyanluansheng','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>5 数据链路层</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>5 数据链路层</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BeiyanLuansheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2020-12-11, 22:09 +0800" >2020-12-11<i class="unloaded">2020-12-11T22:09:24+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5898 字">32 分钟 阅读</span></div></div><div class="post-content"><h2 id="51-数据链路层服务">5.1 数据链路层服务</h2><blockquote><p>主机和路由器：<strong>结点(nodes)</strong></p><p>连接相邻结点的通信信道：<strong>链路(links)</strong>，有线链路(wired links)、无线链路(wireless links)、局域网(LANs)</p><p>链路层(第2层)数据分组：<strong>帧(frame)</strong>，封装网络层数据报</p></blockquote><p>数据链路层负责通过一条链路从一个节点向另一个物理链路直接相连的相邻结点传送数据报。</p><p><strong>组帧(framing)</strong>：封装数据报构成数据帧，加首部和尾部。完成<strong>帧同步</strong>：通过在首部和尾部加入特定的比特串。</p><p><strong>链路接入(link access)</strong>：如果是共享介质，需要解决信道接入(channel access)。帧首部中的“MAC”地址，用于标识帧的源和目的，不同于IP地址！</p><p><strong>相邻结点间可靠交付</strong>：在低误码率的有线链路上很少采用 (如光纤，某些双绞线等)。无线链路：误码率高，需要可靠交付</p><p><strong>流量控制(flow control)</strong>：协调(pacing)相邻的发送结点和接收</p><p><strong>差错检测(error detection)</strong>：信号衰减和噪声会引起差错。接收端检测到差错：通知发送端重传或者直接丢弃帧</p><p><strong>差错纠正(error correction)</strong>：接收端直接纠正比特差错</p><p><strong>全双工和半双工通信控制</strong></p><ul><li><p>全双工：链路两端结点同时双向传输</p><li><p>半双工：链路两端结点交替双向传输</p></ul><h2 id="52-差错编码">5.2 差错编码</h2><p>差错编码基本原理：D→DR，其中R为差错检测与纠正比特（冗余比特）。即加入了冗余信息，使得原本不存在的比特位建立联系。</p><ul><li>分组码：多见于计算机网络<ul><li><strong>线性分组码</strong>：R建立起的D之间的关系是线性的。此类多见<li>非线性分组码：R建立起的D之间的关系是非线性的。</ul><li>卷积码：应用于通信领域</ul><blockquote><p>差错编码不能保证100%可靠</p></blockquote><h3 id="521-差错编码的检错能力">5.2.1 差错编码的检错能力</h3><p>差错编码可分为检错码与纠错码</p><ul><li><p>对于检错码，如果编码集的汉明距离d~s~=r+1，则该差错编码可以检测r位的差错</p><li><p>对于纠错码，如果编码集的汉明距离d~s~=2r+1，则该差错编码可以纠正r位的差错</p></ul><p>奇偶校验码</p><ul><li><p>1比特校验位：检测奇数位差错</p><li><p>二维奇偶校验：检测奇数位差错、部分偶数位差错；纠正同一行/列的奇数位错</p></ul><p>Internet校验和(Checksum)</p><ul><li><p>发送端：将“数据”(校验内容)划分为16位的二进制“整数”序列，求和(sum)：补码求和(最高位进位的“1”，返回最低位继续加）。校验和(Checksum)：sum的反码。放入分组(UDP、TCP、IP)的校验和字段。</p><li><p>接收端：与发送端相同算法计算。计算得到的”checksum”：为16位全0（或sum为16位全1）则无错，否则有错</p></ul><h3 id="522-循环冗余校验码crc">5.2.2 循环冗余校验码(CRC)</h3><p>检错能力更强大的差错编码</p><p>将数据比特，D，视为一个二进制数，选择一个r+1位的比特模式 (生成比特模式)，G。目标：选择r位的CRC比特，R，满足：</p><ul><li><p>&lt;D,R&gt;刚好可以被G整除(模2)</p><li><p>接收端检错：利用G除&lt;D,R&gt;，余式全0，无错；否则，有错！</p><li><p>可以检测所有突发长度小于r+1位差错。</p></ul><blockquote><p>广泛应用于实际网络 (以太网，802.11 WiFi，ATM)</p></blockquote><p>期望：D * 2^r^ XOR R = nG</p><p>相当于：D * 2^r^ = nG XOR R</p><p>相当于：如果利用G去除D*2r, 则余式即为R=余式[D * 2^r^ / G]</p><p><img data-proofer-ignore data-src="image-20201212124204283.png" alt="image-20201212124204283" /></p><h2 id="53-多路访问控制mac协议">5.3 多路访问控制(MAC)协议</h2><h3 id="531-mac协议">5.3.1 MAC协议</h3><p>两类“链路”：</p><ul><li><strong>点对点链路</strong><ul><li>拨号接入的PPP<li>以太网交换机与主机间的点对点链路</ul><li>**广播链路 **(共享介质)<ul><li>早期的总线以太网<li>HFC的上行链路<li>802.11无线局域网</ul></ul><p>单一共享广播信道，两个或者两个以上结点同时传输：干扰(interference)</p><p>冲突(collision)：结点同时接收到两个或者多个信号→接收失败！</p><p><strong>多路访问控制协议(multiple access control protocol)</strong>：采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据；必须基于信道本身，通信信道共享协调信息；无带外信道用于协调</p><h4 id="5311-理想mac协议">5.3.1.1 理想MAC协议</h4><p>给定：速率为R bps的广播信道，期望：</p><ol><li>当只有一个结点希望传输数据时，它可以以速率 R发送.<li>当有M个结点期望发送数据时，每个节点平均发送数据的平均速率是R/M<li>完全分散控制：无需特定结点协调；无需时钟、时隙同步<li>简单</ol><h4 id="5312-mac协议分类">5.3.1.2 MAC协议分类</h4><ul><li>信道划分(channel partitioning)MAC协议<ul><li>多路复用技术<li>TDMA、FDMA、CDMA、WDMA等</ul><li>随机访问(random access)MAC协议<ul><li>信道不划分，允许冲突<li>采用冲突“恢复”机制<li>ALOHA, S-ALOHA, CSMA, CSMA/CD<li>CSMA/CD应用于以太网；CSMA/CA应用802.11无线局域网</ul><li>轮转(“taking turns”)MAC协议<ul><li>结点轮流使用信道<li>主结点轮询；令牌传递<li>蓝牙、FDDI、令牌环网</ul></ul><h3 id="532-信道划分mac协议">5.3.2 信道划分MAC协议</h3><h4 id="5321-tdma">5.3.2.1 TDMA</h4><p>TDMA: time division multiple access</p><ul><li><p>“周期性”接入信道</p><li><p>每个站点在每个周期，占用固定长度的时隙(e.g.长度=分组传输时间)</p><li><p>未用时隙空闲(idle)</p></ul><p>例如：6-站点LAN，1,3,4传输分组，2,5,6空闲</p><h4 id="5322-fdma">5.3.2.2 FDMA</h4><p>FDMA: frequency division multiple access</p><ul><li>信道频谱划分为若干频带(frequency bands)<li>每个站点分配一个固定的频带<li>无传输频带空闲</ul><p>例如：6站点LAN, 1,3,4频带传输数据, 2,5,6频带空闲。</p><h3 id="533-随机访问mac协议">5.3.3 随机访问MAC协议</h3><p>当结点要发送分组时：利用信道全部数据速率R发送分组，由于没有事先的结点间协调，所以存在两个或多个结点同时传输导致冲突。</p><p>随机访问MAC协议需要定义：如何检测冲突；如何从冲突中恢复 (e.g., 通过延迟重传)</p><blockquote><p>典型的随机访问MAC协议：时隙(sloted)ALOHA、ALOHA、CSMA、CSMA/CD、CSMA/CA</p></blockquote><h4 id="5331-时隙aloha协议">5.3.3.1 时隙ALOHA协议</h4><p>假定：</p><ul><li>所有帧大小相同<li>时间被划分为等长的时隙（每个时隙可以传输1个帧）<li>结点只能在时隙开始时刻发送帧<li>结点间时钟同步<li>如果2个或2个以上结点在同一时隙发送帧，结点即检测到冲突</ul><p>运行：当结点有新的帧时，在下一个时隙(slot)发送</p><ul><li>如果无冲突：该结点可以在下一个时隙继续发送新的帧<li>如果冲突：该结点在下一个时隙<strong>以概率p重传</strong>该帧，直至成功</ul><p>优点:</p><ul><li>单个结点活动时，可以连续以信道全部速率传输数据<li>高度分散化：只需同步时隙<li>简单</ul><p>缺点:</p><ul><li>容易冲突，浪费时隙<li>空闲时隙<li>结点也许能以远小于分组传输时间检测到冲突<li>时钟同步</ul><blockquote><p><strong>效率(efficiency)：长期运行时，成功发送帧的时隙所占比例 (很多结点，有很多帧待发送)</strong></p></blockquote><p>假设N个结点有很多帧待传输，每个结点在每个时隙均以概率p发送数据</p><p>对于给定的一个结点，在一个时隙将帧发送成功的概率= p(1-p)^N-1^</p><p>对于任意结点成功发送帧的概率= Np(1-p)^N-1^</p><p>最大效率：求得使Np(1-p)^N-1^最大的p*</p><p>对于很多结点，求Np*(1-p*)^N-1^当N趋近无穷时的极限，可得：最大效率= 1/e = 0.37。即最好情况下信道被成功利用的时间仅占37%</p><h4 id="5332-aloha协议">5.3.3.2 ALOHA协议</h4><p>非时隙(纯)Aloha：更加简单，无需同步</p><p>当有新的帧生成时立即发送，这也导致冲突可能性增大：在t~0~时刻发送帧，会与在 (t~0~-1, t~0~+1) 期间其他结点发送的帧冲突。</p><p><strong>效率</strong>：P(给定结点成功发送帧) = P(该结点发送) * P(无其他结点在[t~0~-1, t~0~]期间发送帧) * P(无其他结点在[t~0~, t~0~+1]期间发送帧)</p><p>= p * (1-p)^N-1^ * (1-p)^N-1^ = p . (1-p)^2(N-1)^ 选取最优的p，并令n→∞</p><p>= 1/(2e) = 0.18</p><blockquote><p>比时隙ALOHA协议更差</p></blockquote><h4 id="5333-csma协议">5.3.3.3 CSMA协议</h4><p><strong>载波监听多路访问协议CSMA (carrier sense multiple access)</strong>：发送帧之前，监听信道(载波)：信道空闲时发送完整帧；信道忙时推迟发送：</p><ul><li><p>1-坚持CSMA：持续监听信道，一旦发现空闲即发送数据。</p><li><p>非坚持CSMA：随机等待一段时间后再监听信道</p><li><p>P-坚持CSMA：以概率P持续监听信道，以概率1-P随机等待一段时间后再监听信道</p></ul><p>但由于信号传播延迟，<strong>冲突可能仍然发生</strong>。如果两个结点同时监听到空闲然后同时发送数据，同样会发生冲突。</p><h4 id="5334-csmacd协议">5.3.3.4 CSMA/CD协议</h4><p><strong>CSMA/CD (CSMA with Collision Detection)</strong>：短时间内可以检测到冲突，冲突后传输中止，减少信道浪费。冲突检测:</p><ul><li><p>有线局域网易于实现：测量信号强度，比较发射信号与接收信号</p><li><p>无线局域网很难实现：接收信号强度淹没在本地发射信号强度下</p></ul><blockquote><p>“边发边听，不发不听”</p></blockquote><p><strong>条件</strong>：网络带宽：R bps，数据帧最小长度：Lmin (bits)，信号传播速度：V (m/s)下，需满足：L / R ≥ 2d~max~ / V</p><ul><li><p>L~min~ / R = 2d~max~ / V</p><li><p>由于实际存在中继，可能存在其他延迟：L~min~ / R = RTT~max~</p></ul><p><strong>效率</strong>：$\displaystyle\frac 1 {1+5t_{prop} / t_{trans}}$</p><p>t~prop~ = LAN中2个结点间的最大传播延迟</p><p>t~trans~ = 最长帧传输延迟</p><blockquote><p>t~prop~ 趋近于0或者t~trans~ 趋近于∞时，效率趋近于1，远优于ALOHA，并且简单、分散！</p></blockquote><h3 id="534-轮转访问mac协议">5.3.4 轮转访问MAC协议</h3><p>信道划分MAC协议：</p><ul><li><p>网络负载重时，共享信道效率高，且公平</p><li><p>网络负载轻时，共享信道效率低</p></ul><p>随机访问MAC协议：</p><ul><li><p>网络负载轻时，共享信道效率高，单个结点可以利用信道的全部带宽</p><li><p>网络负载重时，产生冲突开销</p></ul><p>轮转访问MAC协议： 综合两者的优点，两种举例：</p><ul><li><p><strong>轮询(polling)</strong>：主结点轮流“邀请”从属结点发送数据。典型应用：“哑(dumb)” 从属设备</p><p>问题：轮询开销；等待延迟；单点故障</p><li><p><strong>令牌传递(token passing)</strong>：控制令牌依次从一个结点传递到下一个结点.。令牌：特殊帧</p><p>问题：令牌开销；等待延迟；单点故障</p></ul><h2 id="54-arp协议">5.4 ARP协议</h2><ul><li><p>32位IP地址：接口的网络层地址，用于标识网络层(第3层)分组，支持分组转发。<strong>IP地址是层次地址：不可“携带”，IP地址依赖于结点连接到哪个子网</strong></p><li><p>MAC地址(或称LAN地址,物理地址,以太网地址)：用于局域网内标识一个帧从哪个接口发出，到达哪个物理相连的其他接口。48位MAC地址(用于大部分LANs)，固化在网卡的ROM中，有时也可以软件设置。e.g.：1A-2F-BB-76-09-AD。局域网中的每块网卡都有一个唯一的MAC地址。MAC地址由IEEE统一管理与分配，网卡生产商购买MAC地址空间(前24比特)。<strong>MAC地址是“平面”地址：可“携带”，可以从一个LAN移到另一个LAN</strong></p></ul><blockquote><p>类比：MAC地址：身份证号；IP地址：邮政地址</p></blockquote><p><strong>ARP</strong>：地址解析协议。解决在同一个LAN内<strong>已知目的接口的IP地址前提下确定其MAC地址</strong>问题。</p><p>ARP表：LAN中的<strong>每个IP结点</strong>(主机、路由器)维护一个表，存储某些LAN结点的IP/MAC地址映射关系：<strong>&lt; IP地址; MAC地址; TTL&gt;</strong>。经过TTL (Time To Live)时间以后该映射关系会被遗弃(典型值为20min)。</p><p><strong>A想要给同一局域网内的B发送数据报</strong>，但B的MAC地址不在A的ARP表中，所以：</p><ol><li>A广播ARP查询分组，其中包含B的IP地址，目的MAC地址 = FF-FF-FF-FF-FF-FF。<li>LAN中所有结点都会接收ARP查询，B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC 地址，利用单播帧向A发送应答。<li>A在其ARP表中，缓存B的IP-MAC地址对，直至超时。超时后，再次刷新。ARP是“即插即用”协议，结点自主创建ARP表，无需干预。</ol><p><strong>A通过路由器R向B发送数据报</strong>：假设A知道B的IP地址，A知道第一跳路由器R (左)接口IP地址 (默认网关)，A知道第一跳路由器R (左)接口MAC地址 (ARP协议)。</p><ol><li>A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址。<li><p>A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址是R(左)接口的MAC地址，封装A到B的IP数据报。</p><li><p>帧从A发送至R，R接收帧，提取IP数据报，传递给上层IP协议。</p><li>R转发IP数据报（<strong>源和目的IP地址不变</strong>）R创建链路层帧，其中源MAC地址是R(右)接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报。</ol><h2 id="55-以太网">5.5 以太网</h2><h3 id="551-以太网ethernet">5.5.1 以太网(ETHERNET)</h3><p><strong>物理拓扑</strong></p><ul><li><p><strong>总线(bus)</strong>：所有结点在同一冲突域(collision domain) (可能彼此冲突)</p><li><p><strong>星型(star)</strong>：中心交换机(switch)，每个结点一个单独冲突域(结点间彼此不冲突)</p></ul><p><strong>以太网：不可靠、无连接服务</strong></p><p>无连接(connectionless)：发送帧的网卡与接收帧的网卡间没有“握手”过程。</p><p>不可靠(unreliable)：接收网卡不向发送网卡进行确认。差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议 (e.g., TCP)，否则，发生数据丢失。</p><p>以太网的MAC协议：<strong>采用二进制指数退避算法的CSMA/CD</strong></p><blockquote><p><strong>二进制指数退避算法</strong>用于计算随机等待的时间</p></blockquote><h4 id="5511-以太网csmacd算法">5.5.1.1 以太网CSMA/CD算法</h4><ol><li>NIC从网络层接收数据报，创建数据帧。<li>监听信道：如果NIC监听到信道空闲，则开始发送帧；如果NIC监听到信道忙，则一直等待到信道空闲，然后发送帧。<li>NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功！<li>如果NIC检测到其他结点传输数据，则中止发送，并发送堵塞信号 (jam signal)<li>中止发送后，NIC进入二进制指数退避：第m次连续冲突后：取n = Min(m, 10)，NIC 从{0,1,2, …, 2^n^-1}中随机选择一个数K，NIC等待K·512比特的传输延迟时间，再返回第2步。<ul><li>连续冲突次数越多，平均等待时间越长。<li>一般情况下，连续16次冲突后就不在发送，向上层报告错误。</ul></ol><h4 id="5512-以太网帧结构">5.5.1.2 以太网帧结构</h4><p>发送端网卡将IP数据报(或其他网络层协议分组)封装到以太网帧中：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201030132123536.png" alt="image-20201030132123536" /></p><ul><li><p><strong>前导码(Preamble)(8B)</strong>：用于发送端与接收端的时钟同步。7个字节的10101010，第8字节为10101011。一般情况下，我们所说的<strong>以太网帧长度不包含前导码的长度</strong>。</p><li><p><strong>目的MAC地址、源MAC地址(各6B)</strong>： 如果网卡的MAC地址与收到的帧的目的MAC地址匹配，或者帧的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。否则，网卡丢弃(不接收)该帧。</p><li><p><strong>类型(Type)(2B)</strong>：指示帧中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等)</p><li><strong>数据(Data)(46-1500B)</strong>：指上层协议载荷。<ul><li>R=10Mbps，RTT~max~=512μs，L~min~ / R = RTT~max~<li>L~min~=512bits=64B，Data~min~=L~min~-18=46B</ul><li><strong>CRC(4B)</strong>：循环冗余校验码，丢弃差错帧</ul><h3 id="552-交换机">5.5.2 交换机</h3><p>链路层设备</p><ul><li><p>主机利用独享(dedicated)链路直接连接交换机</p><li>存储-转发以太网帧，交换机缓存帧<li>检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧<li>交换机在每段链路上利用CSMA/CD收发帧，但无冲突，且可以全双工。每段链路一个独立的冲突域。</ul><p>透明(transparent)：主机感知不到交换机的存在</p><p>即插即用(plug-and-play)</p><p>交换(switching)：A-A’与B-B’的传输可以同时进行，没有冲突</p><p>每个交换机有一个<strong>交换表(switch table)</strong>，每个入口(entry)：(主机的MAC地址，到达主机的接口，时间戳)</p><p>交换机通过<strong>自学习(self-learning)</strong>，获知到达主机的接口信息，无需配置。当收到帧时，交换机“学习”到发送帧的主机（通过帧的源MAC地址），位于收到该帧的接口所连接的LAN网段，将发送主机MAC地址/接口信息记录到交换表中。</p><h4 id="5521-帧过滤转发">5.5.2.1 帧过滤/转发</h4><p>当交换机收到帧:</p><ol><li>记录帧的源MAC地址与输入链路接口（自学习）<li>利用目的MAC地址检索交换表<li>if 在交换表中检索到与目的MAC地址匹配的入口(entry) then { if 目的主机位于收到帧的网段（源和目的主机连在交换机的同一个接口上） then 丢弃帧 else 将帧转发到该入口指向的接口 } else 泛洪(flood) /* 向除收到该帧的接口之外的所有接口转发 */</ol><h4 id="5522-交换机-vs-路由器">5.5.2.2 交换机 vs. 路由器</h4><p><strong>均为存储-转发设备</strong>：</p><ul><li><p>路由器：网络层设备 (检测网络层分组首部)</p><li><p>交换机：链路层设备 (检测链路层帧的首部)</p></ul><p><strong>均使用转发表</strong>：</p><ul><li><p>路由器：利用路由算法(路由协议)计算(设置)，依据IP地址</p><li><p>交换机：利用自学习、泛洪构建转发表，依据MAC地址</p></ul><h3 id="553-虚拟局域网vlan">5.5.3 虚拟局域网(VLAN)</h3><p>虚拟局域网(Virtual Local Area Network)：支持VLAN划分的交换机，可以在一个物理LAN架构上配置、定义多个VLAN</p><p><strong>基于端口的VLAN</strong>：分组交换机端口 (通过交换机管理软件)，于是，单一的物理交换机就像多个虚拟交换机一样运行。</p><ul><li><p><strong>流量隔离(traffic isolation)</strong>：去往/来自端口1-8的帧只到达端口1-8，同理，也可以基于MAC地址定义VLAN，而不是交换端口</p><li><p><strong>动态成员</strong>：端口可以动态分配给不同VLAN</p><li><p><strong>在VLAN间转发</strong>：通过路由(就像在独立的交换机之间)。而实践中，厂家会将交换机与路由器集成在一起</p></ul><p>跨越多交换机的VLAN，可以使用多线缆连接，每个线缆连接一个VLAN，但显然每个交换机都会浪费一个端口。</p><p><strong>中继端口(trunk port)</strong>：在跨越多个物理交换机定义的VLAN承载帧。为多VLAN转发802.1帧容易产生歧义，所以必须携带VLAN ID信息，802.1q协议为经过中继端口转发的帧增加/去除额外的首部域</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201030140800909.png" alt="image-20201030140800909" /></p><h2 id="55-ppp协议">5.5 PPP协议</h2><p>点对点数据链路控制：一个发送端，一个接收端，一条链路。比广播链路容易：无需介质访问控制(Media Access Control)；无需明确的MAC寻址。e.g., 拨号链路，ISDN链路</p><p>常见的点对点数据链路控制协议：</p><ul><li>HDLC (High Level Data Link Control)<li>PPP (Point-to-Point Protocol)</ul><h3 id="551-ppp设计需求">5.5.1 PPP设计需求</h3><ul><li><strong>组帧</strong>：将网络层数据报封装到数据链路层帧中。可以同时承载<strong>任何网络层协议</strong>分组(不仅IP数据报)；可以向上层实现分用（多路分解）。<li><strong>比特透明传输</strong>：数据域必须支持承载<strong>任何比特模式</strong><li><strong>差错检测</strong>：(无纠正)<li><strong>连接活性(connection liveness)检测</strong>：检测、并向网络层通知链路失效<li><strong>网络层地址协商</strong>：端结点可以学习/配置彼此网络地址<li><strong>无需支持</strong>的功能：无需差错纠正/恢复；无需流量控制；不存在乱序交付；无需支持多点链路。差错恢复、流量控制等由高层协议处理。</ul><h3 id="552-ppp数据帧">5.5.2 PPP数据帧</h3><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201030185824316.png" alt="image-20201030185824316" /></p><ul><li><p><strong>标志(Flag)</strong>：定界符(delimiter)</p><li><strong>地址(Address)</strong>：无效(仅仅是一个选项)，目前全部取1<li><strong>控制(Control)</strong>：无效；未来可能的多种控制域<li><strong>协议(Protocol)</strong>：上层协议 (eg, PPP-LCP, IP, IPCP, etc)<li><strong>信息(info)</strong>：上层协议分组数据<li><strong>校验(check)</strong>：CRC校验，用于差错检测</ul><blockquote><p>通过协商，可以省略地址字段和控制字段等字节，一个PPP数据帧最多可以<strong>节省5个字节</strong>的长度：地址字段1字节、控制字段1字节、协议字段1字节、校验字段2个字节。</p></blockquote><h3 id="553-字节填充">5.5.3 字节填充</h3><p>数据透明传输要求数据域必须允许包含标志模式&lt;01111110&gt;</p><p>发送端：在数据中的&lt;01111110&gt;和&lt;01111101&gt;字节前添加额外的字节&lt;01111101&gt; (“填充(stuffs)”)</p><p>接收端：</p><ul><li><p>单个字节&lt;01111101&gt;表示一个填充字节；</p><li><p>连续两个字节&lt;01111101&gt;：丢弃第1个，第2个作为数据接收；</p><li><p>单个字节&lt;01111110&gt;：标志字节</p></ul><blockquote><p>综上，字节&lt;01111101&gt;相当于转义符，如果在数据域中出现了标志字节&lt;01111110&gt;或者转义符自身，就需要在原字节之前加一个转义符，将它转成原本的含义，而非特殊含义“标志”或“转义”。</p></blockquote><p>在交换网络层数据之前，PPP数据链路两端必须：</p><ul><li><p>配置PPP链路：最大帧长；身份认证(authentication)；协商配置各个可变字段的长度；etc.</p><li><p>学习/配置网络层信息：对于IP协议，通过交换IPCP协议 (IP Control Protocol )报文 (IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a> <a href="/tags/hitcn/" class="post-tag no-text-decoration" >HITCN</a> <a href="/tags/2020%E7%A7%8B/" class="post-tag no-text-decoration" >2020秋</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=5 数据链路层 - XuJian&url=https://beiyanluansheng.github.io//posts/5-DataLinkLayer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=5 数据链路层 - XuJian&u=https://beiyanluansheng.github.io//posts/5-DataLinkLayer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=5 数据链路层 - XuJian&url=https://beiyanluansheng.github.io//posts/5-DataLinkLayer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nas/">使用Docker部署NAS</a><li><a href="/posts/route/">使用Docker部署OpenWRT旁路由</a><li><a href="/posts/10-dockerDeploy/">OES之十：Dcoker部署</a><li><a href="/posts/9-file/">OES之九：文件上传下载</a><li><a href="/posts/5-passValue/">OES之五：请求接口</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT-FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-Introdution/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T10:56:33+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1 概述</h3><div class="text-muted small"><p> 1.1 计算机网络 1.1.1 计算机网络与Internet 计算机网络：计算机网络就是互连的、自治的计算机集合。 自治：无主从关系 互连：互联互通——通信链路。通过交换网络互连主机，在距离远、数量大时保证互连。 Internet：全球最大的互联网络。ISP(Internet Service Provider) 网络互连的“网络之网络” 数以百万计的互连的计算设备...</p></div></div></a></div><div class="card"> <a href="/posts/2-ApplicationLayer/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T21:41:25+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2 应用层</h3><div class="text-muted small"><p> 2.1 基本原理 2.1.1 网络应用的体系结构 客户机/服务器结构(Client-Server, C/S) 服务器：7*24小时提供服务；永久性访问地址/域名；利用大量服务器实现可扩展性 客户机：与服务器通信，使用服务器提供的服务；间歇性接入网络；可能使用动态IP地址；不会与其他客户机直接通信 Web应用 ...</p></div></div></a></div><div class="card"> <a href="/posts/3-TransportLayer/"><div class="card-body"> <span class="timeago small" >2020-12-09<i class="unloaded">2020-12-09T14:22:08+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>3 传输层</h3><div class="text-muted small"><p> 网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制 3.1 多路复用和多路分用 多路复用（发送端）：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络层 多路分用（接收端）：传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程工作方式： 主机接收IP数据报：每个数据报携带源IP地...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/4-NetworkLayer/" class="btn btn-outline-primary" prompt="上一篇"><p>4 网络层</p></a> <a href="/posts/6-PhysicalLayer/" class="btn btn-outline-primary" prompt="下一篇"><p>6 物理层</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.facebook.com/BeiyanLuansheng">XuJian</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
