<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="3 传输层" /><meta name="author" content="BeiyanLuansheng" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制" /><meta property="og:description" content="网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制" /><link rel="canonical" href="https://beiyanluansheng.github.io//posts/3-TransportLayer/" /><meta property="og:url" content="https://beiyanluansheng.github.io//posts/3-TransportLayer/" /><meta property="og:site_name" content="XuJian" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-09T14:22:08+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="3 传输层" /><meta name="twitter:site" content="@BeiyanLuansheng" /><meta name="twitter:creator" content="@BeiyanLuansheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BeiyanLuansheng"},"dateModified":"2020-12-09T14:22:08+08:00","datePublished":"2020-12-09T14:22:08+08:00","description":"网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制","headline":"3 传输层","mainEntityOfPage":{"@type":"WebPage","@id":"https://beiyanluansheng.github.io//posts/3-TransportLayer/"},"url":"https://beiyanluansheng.github.io//posts/3-TransportLayer/"}</script><title>3 传输层 | XuJian</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XuJian"><meta name="application-name" content="XuJian"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XuJian</a></div><div class="site-subtitle font-italic">BeiyanLuansheng</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/BeiyanLuansheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/BeiyanLuansheng" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['beiyanluansheng','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>3 传输层</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>3 传输层</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BeiyanLuansheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2020-12-09, 14:22 +0800" >2020-12-09<i class="unloaded">2020-12-09T14:22:08+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4921 字">27 分钟 阅读</span></div></div><div class="post-content"><p>网络层提供<strong>主机之间</strong>的逻辑通信机制，而传输层提供<strong>应用进程之间</strong>的逻辑通信机制</p><h2 id="31-多路复用和多路分用">3.1 多路复用和多路分用</h2><ul><li><strong>多路复用</strong>（发送端）：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络层<li><strong>多路分用</strong>（接收端）：传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程<strong>工作方式</strong>：<ol><li><strong>主机接收IP数据报</strong>：每个<strong>数据报</strong>携带<strong>源IP地址</strong>和<strong>目的IP地址</strong>，还携带一个<strong>传输层的段</strong>(Segment)，每个段携带<strong>源端口号</strong>和<strong>目的端口号</strong><li>收到Segment之后，传输层协议<strong>提取IP地址和端口号</strong>信息，将Segment<strong>导向相应的Socket</strong>：网络层不关心端口号信息</ol></ul><h3 id="311-无连接的多路分用">3.1.1 无连接的多路分用</h3><ul><li>利用端口号创建Socket<li><strong>UDP的Socket用二元组</strong>标识：(<strong>目的IP地址，目的端口号</strong>)<li>主机收到UDP段后检查段中的目的端口号，将UDP段导向绑定在该端口号的Socket，所以只要目的IP和目的端口号相同，来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket</ul><h3 id="312-面向连接的多路分用">3.1.2 面向连接的多路分用</h3><ul><li><p><strong>TCP的Socket用四元组</strong>标识：(<strong>源IP地址，源端口号，目的IP地址，目的端口号</strong>)</p><li><p>接收端利用所有的四个值将Segment导向合适的Socket</p><li><p>服务器可能同时支持<strong>多个TCP Socket</strong>，每个Socket用自己的四元组标识：Web服务器为每个客户端开不同的Socket，可能创建<strong>多个进程</strong>，每个进程一个Socket；也可能创建<strong>多个线程</strong>，每个线程一个Socket</p></ul><h2 id="32-无连接传输协议udp">3.2 无连接传输协议UDP</h2><p>UDP基于IP协议,解决了<strong>复用/分用</strong>、<strong>简单的错误校验</strong>两个问题，UDP协议不可靠，数据可能丢失，可能非按序到达</p><blockquote><p>在应用层增加可靠性机制以实现可靠的数据传输（增加了实现难度）</p></blockquote><p>无连接：UDP发送方和接收方之间不需要握手；每个UDP段的处理独立于其他段</p><ul><li><p><strong>优点</strong>：无连接<strong>减少了延迟</strong>（DNS使用UDP的原因），并且无需维护连接状态因此<strong>实现起来也简单</strong>；头部<strong>开销少</strong>；没有拥塞控制，<strong>应用可更好地控制</strong>发送时间和速率</p><li><p><strong>用途</strong>：流媒体应用、DNS、SNMP</p><li><p><strong>UDP报文段格式</strong>：</p><div class="table-wrapper"><table><tbody><tr><td>源端口号<td>目的端口号</table></div><div class="table-wrapper"><table><tbody><tr><td>UDP段(包含头部)的长度<td>校验和</table></div><div class="table-wrapper"><table><tbody><tr><td>应用数据（消息）</table></div><li><p><strong>校验和checksum</strong></p><blockquote><p>目的：检测UDP段在传输中是否发生错误（如位翻转）</p></blockquote><p>发送方：计算前将校验和字段设为全0，然后将段的内容视为16-bit整数，(<strong>校验和计算</strong>)计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和；将校验和放入校验和字段</p><p>接收方：计算所收到段的校验和，将其与校验和字段进行对比：不相等——检测出错误；相等——没有检测出错误（但可能有错误）</p></ul><h2 id="33-可靠数据传输">3.3 可靠数据传输</h2><p>信道的不可靠特性决定了可靠数据传输协议(RDT)的复杂性</p><h3 id="331-可靠数据传输原理">3.3.1 可靠数据传输原理</h3><ol><li><p>发送方调用<code class="language-plaintext highlighter-rouge">rdt_send()</code> 将待发送数据交给可靠数据传输协议</p><li><p>可靠数据传输协议调用 <code class="language-plaintext highlighter-rouge">udt_send()</code> 将数据发送给传输层</p><li><p>数据发送到接收方的传输层，调用<code class="language-plaintext highlighter-rouge">rdt_rcv()</code> 将数据传给可靠数据传输协议</p><li><p>RDT整理后调用<code class="language-plaintext highlighter-rouge">deliver_data</code>将完整的数据发给接收方上层应用</p></ol><p>第2、3步的通信都是双向的，以保证传输数据的完整性（可靠性）</p><h3 id="332-rdt">3.3.2 RDT</h3><h4 id="3321-rdt10">3.3.2.1 RDT1.0</h4><p><strong><em>可靠信道上的可靠数据传输协议</em></strong></p><p>假设底层信道完全可靠，无丢失无错误，因此双方无需进行控制信息的传递，发送方只需把消息发送一次即可，接收方收到的消息即是完整的消息。</p><h4 id="3322-rdt20">3.3.2.2 RDT2.0</h4><p><strong><em>可能产生位错误的信道上的可靠数据传输协议</em></strong></p><p>利用<strong>校验和</strong>检测底层信道可能翻转分组中的<strong>位错误</strong>，双方要进行控制信息的传递以<strong>纠正错误</strong>：</p><ul><li><strong>ACK</strong> (确认机制)——接收方显式地告知发送方分组已正确接收；<li><strong>NAK</strong>——接收方显式地告知发送方分组有错误，发送方收到NAK后，重传分组</ul><p>基于这种重传机制的rdt协议称为<strong>ARQ(Automatic Repeat reQuest)协议</strong></p><blockquote><p><strong>Rdt 2.0中引入的新机制：差错检测；接收方反馈控制消息: ACK/NAK；重传</strong></p><p>在实现的过程中，利用了<strong>停-等协议</strong>，即发送方发送了一个packet后，只有在收到来自接收方的确认消息后才能继续下一步操作。</p></blockquote><h4 id="3323-rdt2122">3.3.2.3 RDT2.1、2.2</h4><p>在RDT2.0中没有<strong>ACK/NAK消息发生错误/被破坏</strong>的处理方案，于是提出了新的解决方案</p><ul><li><p>RDT2.1</p><p>如果ACK/NAK坏掉发送方就重传，但这有可能会产生重复分组，所以RDT2.1为每个分组增加了序列号（使用0，1标识——基于停-等协议），所以接收方可以根据序列号丢弃重复分组</p><p>相比与2.0，发送方为每个分组增加了序列号，并且需要检验ACK/NAK消息是否发生错误，而且由于状态必须“记住”“当前”的分组，所以序列号FSM的状态数量翻倍；接收方需要判断分组是否重复即是否收到了期望的序列号</p><li><p>RDT2.2：无NAK消息协议</p><p>在RDT2.1的基础上删除NAK，接收方通过ACK告知最后一个被正确接收的分组，在ACK消息中显式地加入被确认分组的序列号，发送方收到重复ACK之后，处理方式与收到NAK相同，重传当前分组</p></ul><h4 id="3324-rdt30">3.3.2.4 RDT3.0</h4><p><strong><em>如果信道既可能发生错误，也可能丢失分组</em></strong></p><p>在这个协议中，引入了<strong>定时器</strong>，发送方会等待合理的时间，如果时间内未收到ACK，则重传，而如果分组只是延迟而不是丢了也同样会引发重传，但序列号机制能够处理这种问题</p><blockquote><p>Rdt 3.0能够正确工作，但由于停-等操作规定了需要等待接收方响应之后才进行下一步操作，所以性能很差</p></blockquote><h3 id="333-滑动窗口协议">3.3.3 滑动窗口协议</h3><h4 id="3331-流水线机制与滑动窗口协议">3.3.3.1 流水线机制与滑动窗口协议</h4><p>由于RDT3.0的性能限制在于等待ACK消息的过程中带宽资源闲置，所以在流水线机制下，允许发送方在收到ACK之前连续发送多个分组，因而也需要更大的序列号范围，发送方/接收方需要更大的存储空间以缓存分组</p><p><strong>滑动窗口协议 (Sliding-window protocol)</strong>：窗口是允许的序列号的范围，窗口尺寸为N表示最多有N个等待确认的消息。随着协议的运行，窗口在序列号空间内向前滑动（序列号会越来越大）。</p><blockquote><p>主要的滑动窗口协议：GBN、SR</p></blockquote><h4 id="3332-gbngo-back-n">3.3.3.2 GBN（Go-Back-N）</h4><p><strong>发送方</strong>：分组头部包含k-bit的序列号，窗口尺寸为N，即最多允许N个分组未确认，如果上层应用发来的数据没有可用的序列号时调用<code class="language-plaintext highlighter-rouge">refuse_data(data)</code> 拒绝。</p><p><strong>ACK(n)</strong>：确认到序列号n(包含n)的分组均已被正确接收——<strong>累积确认</strong></p><p>为空中的分组设置计时器(timer)，超时Timeout(n)事件：<strong>重传序列号大于等于n</strong>，还未收到ACK的所有分组</p><p><strong>接收方</strong>：无缓存，只需要记住唯一的expectedseqnum (期望序列号)，对于乱序到达的分组直接丢弃，重新确认序列号最大的、按序到达的分组</p><p>ACK机制: 发送拥有最高序列号的、已被正确接收的分组的ACK</p><h4 id="3333-sr-selective-repeat">3.3.3.3 SR (Selective Repeat)</h4><p>GBN的丢失信息会导致所有序列号高于已经确认的序列号的包全部重发，因而造成资源浪费。在GBN的基础上改进得SR协议：</p><ul><li><p>发送方只重传那些没收到ACK的分组，为每个分组设置定时器</p><li><p>接收方对每个分组<strong>单独进行确认</strong>，设置缓存机制，<strong>缓存乱序到达的分组</strong>，设置一个接收方窗口，将乱序到达的分组缓存，等待前面的分组到达后与前面的分组一起合并和交给上层</p><ul><li>收到在窗口内的分组时先发送ACK(n)，再判断是不是乱序到达的分组，是就缓存，不是就合并交付移动窗口<li>收到窗口左侧的分组发送ACK(n)<li>收到窗口右侧的分组忽略</ul></ul><p>序列号空间大小与窗口尺寸需满足：<strong>N~S~+N~R~&lt;=2^k^</strong></p><h2 id="34-tcp">3.4 TCP</h2><h3 id="341-tcp段结构">3.4.1 TCP段结构</h3><h3 id="3411-tcp段结构">3.4.1.1 TCP段结构</h3><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201011212239482.png" alt="image-20201011212239482" /></p><h4 id="3412-序列号">3.4.1.2 序列号</h4><p>序列号是segment中第一个字节的编号，而不是segment的编号（$NextSeqNum = SeqNum + length(data)$）</p><p>建立TCP时，双方随机选择序列号</p><h4 id="3413-ack">3.4.1.3 ACK</h4><p>指的是希望接收到的下一个字节的序列号</p><p>使用的是累计确认机制（该序列号之前的所有字节均已被正确接收到）</p><blockquote><p>关于乱序到达的Segment，TCP规范中没有规定，由TCP的实现者做出决策</p></blockquote><h3 id="342-tcp可靠数据传输">3.4.2 TCP可靠数据传输</h3><p>TCP在<strong>IP层提供的不可靠服务基础上</strong>实现<strong>可靠数据传输</strong>服务，使用了以下机制</p><ul><li><p>流水线机制</p><li><p>累积确认</p><li><p>TCP使用单一重传定时器。触发重传的事件：超时；收到重复ACK</p></ul><h4 id="3421-rtt和超时">3.4.2.1 RTT和超时</h4><p>为了设置定时器的超时时间，必须参考网络的RTT时间，而RTT是变化的，所以必须测量RTT</p><p>SampleRTT：测量从段发出去到收到ACK的时间。多次测量取平均值得到估计值EstimatedRTT（指数加权移动平均）：</p><p>$EstimatedRTT = (1- \alpha)<em>EstimatedRTT + \alpha</em>SampleRTT$ （$\alpha$一般取0.125）</p><p><strong>超时时间设置为：EstimatedRTT+ 安全边界</strong>。所以如果EstimatedRTT变化大就意味着需要设置较大的边界，所以就需要测量RTT的变化值：SampleRTT与EstimatedRTT的差值：</p><div class="table-wrapper"><table><tbody><tr><td>$DevRTT = (1- \beta)*DevRTT +\beta *<td>SampleRTT-EstimatedRTT<td>$</table></div><p>所以超时时间的设置：$TimeoutInterval = EstimatedRTT + 4*DevRTT$</p><h4 id="3422-发送方">3.4.2.2 发送方</h4><p>从应用层收到数据：创建Segment（设置序列号）–&gt;开启计时器–&gt;设置超时时间：</p><p>超时事件：重传<strong>引起超时的Segment</strong>，重启定时器</p><p>收到ACK：如果确认此前未确认的Segment，更新滑动窗口（SendBase），如果窗口中还有未被确认的分组，重新启动定时器。</p><h4 id="3423-接收方ack生成">3.4.2.3 接收方ACK生成</h4><div class="table-wrapper"><table><thead><tr><th>接收方事件<th>接收方TCP动作<tbody><tr><td>收到按序到达的段（之前无等待发ACK的段）<td>等待500ms，看是否有下一个段到达，如果没有就直接发送ACK<tr><td>收到按序到达的段（之前有等待发ACK的段）<td>立即发送它的确认消息<tr><td>收到乱序到达的段<td>立即发送重复的ACK消息，声明期望的段</table></div><h4 id="3424-快速重传机制">3.4.2.4 快速重传机制</h4><p>TCP的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大，所以重发丢失的分组之前要等待很长时间使之超时。</p><p>Sender会连续地发送多个分组，如果某个分组丢失，可能会引发多个重复的ACK，所以可以<strong>通过重复ACK检测分组丢失</strong>。如果sender收到对同一数据的<strong>3个ACK</strong>，则假定该数据之后的段已经丢失。</p><p><strong>快速重传</strong>：在定时器超时之前即进行重传。</p><blockquote><p>问题：为什么是收到<strong>3</strong>次相同的ACK？</p></blockquote><h3 id="343-tcp流量控制">3.4.3 TCP流量控制</h3><p>接收方为TCP连接分配缓冲区(buffer)，而上层应用可能处理buffer中数据的速度较慢，所以就需要<strong>流量控制</strong>以保证发送方不会传输的太多、太快以至于淹没接收方（buffer溢出）。</p><p>流量控制实际上是<strong>速度匹配</strong>机制。</p><p>假定TCP receiver丢弃乱序的段，则Buffer中的可用空间(spare room)= RcvWindow= RcvBuffer-[LastByteRcvd -LastByteRead]</p><p>Receiver通过在段的头部字段将RcvWindow 告诉Sender</p><p>Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的RcvWindow尺寸</p><p>Receiver告知Sender RcvWindow=0，这会导致即使Reciver空闲了也无法通知Sender，所以需要一个机制来使Sender可以发送一个小的段从而可以带回Reciver的信息，避免了上面的死锁。</p><h3 id="344-tcp连接管理">3.4.4 TCP连接管理</h3><p>TCP sender和receiver在传输数据前需要建立连接</p><p>初始化TCP变量：如分配序列号、分配缓存区、交换流量控制信息。</p><h4 id="3441-tcp建立三次握手">3.4.4.1 TCP建立：三次握手</h4><p>Client：连接发起者</p><p>Server: 等待客户连接请求</p><ol><li><p>Client主机向Server发送一个TCP <strong>SYN</strong> segment：</p><blockquote><p>SYN=1, seq=client_isn</p></blockquote><ul><li>不携带数据<li>SYN标志位置1<li>传递选择的初始序列号</ul><li><p>Server主机收到SYN，同意建立连接，回复SYNACK段</p><blockquote><p>SYN=1, seq=serever_isn, ack=client_isn+1</p></blockquote><ul><li>Server分配buffer<li>选择Server端的初始序列号，并告知Client</ul><li><p>Client收到SYNACK，答复ACK段，SYN标志不再位置1，也可包含数据。</p><blockquote><p>SYN=0, seq=client_isn+1, ack=server_isn+1</p></blockquote></ol><h4 id="3442-tcp关闭">3.4.4.2 TCP关闭</h4><p>Client和Server都可发起关闭请求，多数是客户机发起。</p><ol><li>Client向server发送TCP FIN 控制segment<li>Server收到FIN, 回复ACK. 关闭连接, 发送FIN.<li>Client收到FIN, 回复ACK。进入“等待” ——如果收到FIN，会重新发送ACK<li>Server收到ACK. 连接关闭.</ol><h4 id="3443-tcp生命周期">3.4.4.3 TCP生命周期</h4><p>TCP客户端：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201011212346294.png" alt="image-20201011212346294" /></p><p>TCP服务端：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/cn/image-20201011212451729.png" alt="image-20201011212451729" /></p><h2 id="35-拥塞控制">3.5 拥塞控制</h2><p>拥塞的表现：</p><ul><li>分组丢失（路由器缓存溢出）<li>分组延迟过大（在路由器缓存中排队）</ul><h3 id="351-拥塞的成因和代价">3.5.1 拥塞的成因和代价</h3><p>$\lambda_{in}$：实际需要发送的数据</p><p>$\lambda’_{in}$：实际需要发送的数据+需要重传的数据</p><p>$\lambda_{out}$：实际接收的数据</p><ul><li><p>两个senders，两个receivers，一个路由器且无限缓存：这种条件下不需要重传，但拥塞时<strong>分组延迟太大</strong>。对于路由器：$\lambda_{in} = \lambda_{out}$</p><li><p>两个senders，两个receivers，一个路由器且有限缓存：可能丢包，所以Sender需要重传分组。对于路由器：</p><ul><li>情况a：Sender能够通过某种机制获知路由器buffer信息，有空闲才发。$\lambda_{in}=\lambda’<em>{in}=\lambda</em>{out}$</ul><li>情况b：丢失后才重发。$\lambda’<em>{in}&gt;\lambda</em>{out}$<ul><li>情况c：分组丢失和定时器超时后都重发，$\lambda’_{in}$变得更大</ul><p>由于<strong>重传</strong>，网络要做更多的工作，<strong>造成了资源的浪费</strong>。</p><li>四个发送方，多跳：可能丢包或超时都会引起重传。当拥塞时，一个分组被drop，任何用于该分组的<strong>“上游”传输能力全都被浪费</strong>掉</ul><h3 id="352-拥塞控制的方法">3.5.2 拥塞控制的方法</h3><h4 id="3521-端到端拥塞控制">3.5.2.1 端到端拥塞控制</h4><p>网络层<strong>不需要显式的提供支持</strong>，端系统通过观察loss，delay等网络行为判断是否发生拥塞。TCP采取这种方法。</p><h4 id="3522-网络辅助的拥塞控制">3.5.2.2 网络辅助的拥塞控制</h4><p>路由器向发送方<strong>显式地反馈网络拥塞信息</strong>，通过简单的拥塞指示（1bit：SNA, DECbit, TCP/IP ECN, ATM）指示发送方应该采取何种速率</p><h4 id="3523-atm-abr拥塞控制">3.5.2.3 ATM ABR拥塞控制</h4><p>**ABR **(available bit rate)：</p><ul><li><p>如果发送方路径“underloaded”，使用可用带宽</p><li><p>如果发送方路径拥塞，将发送速率降到最低保障速率</p></ul><p>**RM **(resource management) cells：</p><ul><li><p>发送方发送</p><li>交换机设置RM cell位(网络辅助)<ul><li>NI bit: rate不许增长<li>CI bit: 拥塞指示</ul><li>RM cell由接收方返回给发送方</ul><p><strong>RM cell中显式的速率(ER)字段</strong>：两个字节。拥塞的交换机可以将ER置为更低的值，发送方获知路径所能支持的最小速率</p><p><strong>数据cell中的EFCI位</strong>：拥塞的交换机将其设为1，如果RM cell前面的data cell的EFCI位被设为1，那么发送方在返回的RM cell中置CI位</p><h3 id="353-tcp拥塞控制">3.5.3 TCP拥塞控制</h3><p>Sender限制发送速率：$LastByteSent-LastByteAcked&lt;= CongWin$，则速率 $rate ≈\frac{CongWin}{RTT}\ Bytes/sec$</p><p>CongWin（发送窗口）保证了动态调整以改变发送速率，它反映所感知到的网络拥塞。</p><p><strong>感知网络拥塞</strong>：Loss事件=timeout或3个重复ACK。发生loss事件后，发送方降低速率。</p><p><strong>调整发送速率</strong>：加性增—乘性减；慢启动</p><h4 id="3531-加性增乘性减-aimd">3.5.3.1 加性增—乘性减: AIMD</h4><p><strong>原理</strong>：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss，一旦发生loss，速率直接减半。</p><p><strong>方法</strong>: AIMD</p><ul><li><p><strong>Additive Increase</strong>：每个RTT将CongWin增大一个MSS——拥塞避免</p><li><p><strong>Multiplicative Decrease</strong>：发生loss后将CongWin减半</p></ul><h4 id="3532-tcp慢启动-ss">3.5.3.2 TCP慢启动: SS</h4><p><strong>原理</strong>：当连接开始时，指数性增长——收到每个ACK将CongWin加1 (即每个RTT将CongWin翻倍)。初始速率很慢，但是快速攀升。当CongWin达到Loss事件前值的1/2时，触发<strong>拥塞避免</strong>机制，<strong>指数性增长切换为线性增长</strong>。</p><p><strong>实现方法</strong>：<strong>Threshold</strong>变量。Loss事件发生时，Threshold被设为Loss事件前CongWin值的1/2，然后开始线性增长。</p><p><strong>Loss事件处理</strong></p><ul><li><p>3个重复ACKs：<strong>CongWin切到一半</strong>然后线性增长</p><li><p>Timeout事件：<strong>CongWin直接设为1个MSS</strong>，然后指数增长，达到threshold后, 再线性增长。</p><li><blockquote><p>3个重复ACKs表示网络还能够传输一些 segments，而timeout事件表明拥塞更为严重。</p></blockquote></ul><h3 id="354-tcp性能分析">3.5.4 TCP性能分析</h3><p><strong>TCP吞吐率</strong></p><ul><li><p>忽略掉Slow start，假定发生超时时CongWin的大小为W，吞吐率是W/RTT</p><li><p>超时后，CongWin=W/2，吞吐率是W/2RTT</p><li><p>平均吞吐率为：0.75W/RTT</p></ul><p><strong>TCP的公平性</strong></p><ul><li><p><strong>公平</strong>：如果K个TCP Session共享相同的瓶颈带宽R，那么每个Session的平均速率为R/K。TCP是公平的。</p><li><p><strong>公平性与UDP</strong>：多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率。使用UDP的话可以以恒定速率发送，能够容忍丢失，于是产生了不公平。</p><li><p><strong>公平性与并发TCP连接</strong>：某些应用会打开多个并发连接，如Web浏览器，于是产生公平性问题。</p><blockquote><p>例子：链路速率为R，已有9个连接，新来的应用请求1个TCP，获得R/10的速率，新来的应用请求11个TCP，获得R/2的速率</p></blockquote></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a> <a href="/tags/hitcn/" class="post-tag no-text-decoration" >HITCN</a> <a href="/tags/2020%E7%A7%8B/" class="post-tag no-text-decoration" >2020秋</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=3 传输层 - XuJian&url=https://beiyanluansheng.github.io//posts/3-TransportLayer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=3 传输层 - XuJian&u=https://beiyanluansheng.github.io//posts/3-TransportLayer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=3 传输层 - XuJian&url=https://beiyanluansheng.github.io//posts/3-TransportLayer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nas/">使用Docker部署NAS</a><li><a href="/posts/route/">使用Docker部署OpenWRT旁路由</a><li><a href="/posts/10-dockerDeploy/">OES之十：Dcoker部署</a><li><a href="/posts/9-file/">OES之九：文件上传下载</a><li><a href="/posts/5-passValue/">OES之五：请求接口</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT-FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-Introdution/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T10:56:33+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1 概述</h3><div class="text-muted small"><p> 1.1 计算机网络 1.1.1 计算机网络与Internet 计算机网络：计算机网络就是互连的、自治的计算机集合。 自治：无主从关系 互连：互联互通——通信链路。通过交换网络互连主机，在距离远、数量大时保证互连。 Internet：全球最大的互联网络。ISP(Internet Service Provider) 网络互连的“网络之网络” 数以百万计的互连的计算设备...</p></div></div></a></div><div class="card"> <a href="/posts/2-ApplicationLayer/"><div class="card-body"> <span class="timeago small" >2020-12-08<i class="unloaded">2020-12-08T21:41:25+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2 应用层</h3><div class="text-muted small"><p> 2.1 基本原理 2.1.1 网络应用的体系结构 客户机/服务器结构(Client-Server, C/S) 服务器：7*24小时提供服务；永久性访问地址/域名；利用大量服务器实现可扩展性 客户机：与服务器通信，使用服务器提供的服务；间歇性接入网络；可能使用动态IP地址；不会与其他客户机直接通信 Web应用 ...</p></div></div></a></div><div class="card"> <a href="/posts/4-NetworkLayer/"><div class="card-body"> <span class="timeago small" >2020-12-10<i class="unloaded">2020-12-10T22:55:52+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>4 网络层</h3><div class="text-muted small"><p> 4.1 网络层服务 网络层：从发送主机向接收主机传送数据段（segment），发送主机将数据段封装到数据报（datagram）中；接收主机向传输层交付数据段（segment）。每个主机和路由器都运行网络层协议（非端到端的），路由器检验所有穿越它的IP数据报的头部域，以决策如何处理IP数据报。 网络层核心功能：转发与路由 转发(forwarding)：将分组从路由器的输入端口转移到...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2-ApplicationLayer/" class="btn btn-outline-primary" prompt="上一篇"><p>2 应用层</p></a> <a href="/posts/4-NetworkLayer/" class="btn btn-outline-primary" prompt="下一篇"><p>4 网络层</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.facebook.com/BeiyanLuansheng">XuJian</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
