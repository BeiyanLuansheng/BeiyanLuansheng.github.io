<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="上下文无关文法和下推自动机" /><meta name="author" content="BeiyanLuansheng" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1 上下文无关文法 (CFG)" /><meta property="og:description" content="1 上下文无关文法 (CFG)" /><link rel="canonical" href="https://beiyanluansheng.github.io//posts/3-CFGandPDA/" /><meta property="og:url" content="https://beiyanluansheng.github.io//posts/3-CFGandPDA/" /><meta property="og:site_name" content="XuJian" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-13T22:50:28+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="上下文无关文法和下推自动机" /><meta name="twitter:site" content="@BeiyanLuansheng" /><meta name="twitter:creator" content="@BeiyanLuansheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BeiyanLuansheng"},"dateModified":"2021-12-22T00:54:59+08:00","datePublished":"2020-07-13T22:50:28+08:00","description":"1 上下文无关文法 (CFG)","headline":"上下文无关文法和下推自动机","mainEntityOfPage":{"@type":"WebPage","@id":"https://beiyanluansheng.github.io//posts/3-CFGandPDA/"},"url":"https://beiyanluansheng.github.io//posts/3-CFGandPDA/"}</script><title>上下文无关文法和下推自动机 | XuJian</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XuJian"><meta name="application-name" content="XuJian"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XuJian</a></div><div class="site-subtitle font-italic">BeiyanLuansheng</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/BeiyanLuansheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/BeiyanLuansheng" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['beiyanluansheng','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>上下文无关文法和下推自动机</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>上下文无关文法和下推自动机</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BeiyanLuansheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2020-07-13, 22:50 +0800" >2020-07-13<i class="unloaded">2020-07-13T22:50:28+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021-12-22, 00:54 +0800" >2021-12-22<i class="unloaded">2021-12-22T00:54:59+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3017 字">16 分钟 阅读</span></div></div><div class="post-content"><h2 id="1-上下文无关文法-cfg">1 上下文无关文法 (CFG)</h2><h3 id="1-形式化定义">1 形式化定义</h3><p><strong>上下文无关文法 (Context-Free Grammars)</strong>：CFG是一个四元组，如：$G=(V,T,S,P)$，其中</p><ul><li>$V$：变元的集合，是一个有限集；（变量）<li>$T$：终结符的集合，是一个有限集，且 $V \cap T = \phi$；（值）<li>$S$：开始变元，$S \in V$；<li>$P$：产生式的集合，是一个有穷集，其中的每个元素都有形式：$A \rightarrow \alpha$，其中 $A \in V, \alpha \in (V \cup T)^*$</ul><p><strong>派生</strong>：由产生式生成字符串的过程。</p><ul><li><p><strong>最左派生</strong>：每次选取派生式的最左的变元派生替换。</p><li><p><strong>最右派生</strong>：每次选取派生式的最右变元派生替换。</p></ul><blockquote><p>例如：$L=\{a^{2n}b^m | n \ge 0, m \ge 0 \}$ 的产生式为：$S\rightarrow AB,\, A\rightarrow \varepsilon | aaA,\, B\rightarrow \varepsilon | Bb$</p><p>对于字符串 $w=aabb$ 来说，派生式如下：</p><p>$S\Rightarrow AB \Rightarrow aaAB \Rightarrow aaABb \Rightarrow aaBb \Rightarrow aaBbb \Rightarrow aabb$</p><ul><li><p>最左派生：$S\Rightarrow AB\Rightarrow aaAB\Rightarrow aaB\Rightarrow aaBb\Rightarrow aaBbb \Rightarrow aabb$</p><li><p>最右派生：$S\Rightarrow AB\Rightarrow ABb\Rightarrow ABbb\Rightarrow Abb\Rightarrow aaAbb\Rightarrow aabb$</p></ul></blockquote><p><strong>上下文无关语言 (CFL)</strong>：$G=(V,T,S,P)$ 是一个CFG，则 $L(G)=\{w\;|\;w\in T^* \; and\; S \stackrel{*} {\Longrightarrow} w\}$</p><h3 id="2-语法分析树">2 语法分析树</h3><p><strong>语法分析树</strong>：$G=(V,T,S,P)$ 是一个CFG，一个G的语法分析树如下：</p><ul><li>每个内节点都标了一个 $V$ 中的变元；<li>每个叶节点都标了一个 $T\cup \{\varepsilon\}$ 中的符号，所有被 ε 标记的叶节点都是其父节点的唯一子节点；<li>如果一个内节点标记为A，它的子节点(从左到右)标记为 $x_1,x_2, …, x_k$，则 $A\rightarrow x_1,x_2, …, x_k \in P$</ul><p>例：$L=\{ w\; |\; w\in \{0,1\}^*\; and\; w = w^R \}$ 产生式为 $S \rightarrow \varepsilon\, |\, 0\, |\, 1\, |\, 0S0\, |\, 1S1$ 两个语法分析树如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200703222213618.png" alt="image-20200703222213618" /></p><h3 id="3-二义性">3 二义性</h3><p>对于一个CFG：$G=(\{E,I\}, \{a, b, (, ), +, <em>\}, E, P)$，产生式为 $E\rightarrow I\; |\; E+E |\;E</em>E\;|\;(E)$，$ I\rightarrow a\;|\;b$</p><p>对于字符串 $w=a+a*a$ 的两种最左派生如下：</p><p>$E\Rightarrow E<em>E\Rightarrow E+E</em>E\Rightarrow I+E<em>E\Rightarrow a+E</em>E\Rightarrow a+a<em>a<br /> E\Rightarrow E+E\Rightarrow I+E\Rightarrow a+E\Rightarrow a+E</em>E\Rightarrow a+a*a$</p><p>对应的语法分析树如下，发现一个先算的是加法，一个先算的是乘法，出现了歧义。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200703230824010.png" alt="image-20200703230824010" /></p><p>重新构造产生式以消除歧义：</p><p>先算乘法的：$E\rightarrow I\; |\; E+E\; |\; E*E\; |\; (E),\; I\rightarrow a\; |\; b$</p><p>先算加法的：$E\rightarrow T\; |\; E+T,\; T\rightarrow F\; |\; T*F,\; F\rightarrow I\; |\;(E),\; I\rightarrow a\;|\;b\;|\;Ia\;|\;Ib$</p><blockquote><p>定义同样的语言可以有多个文法，如果一个CFL的所有文法都是歧义的，那么它是固有二义性的</p></blockquote><h3 id="4-cfg的化简">4 CFG的化简</h3><ul><li>去掉 ε 产生式；<li>去掉单元产生式；<li>去掉无用的产生式；</ul><h3 id="5-乔姆斯基范式cnf">5 乔姆斯基范式(CNF)</h3><p><strong>乔姆斯基范式(Chomsky Normal Form)</strong>：一个CFG的所有的产生式都有如下两种形式之一：</p><ul><li>$A\rightarrow BC$，$A,B,C\in V$<li>$A\rightarrow a$，$a\in T$</ul><p>CFG可以转换为CNF的形式，如下例子。</p><p><strong>例</strong>：将 $S\rightarrow ABa , A\rightarrow aab , B \rightarrow Ac$ 转化为CNF的形式</p><p><strong>解</strong>：$S\rightarrow AC,A\rightarrow DE,B\rightarrow AF,C\rightarrow BD,D\rightarrow a,F\rightarrow c,E\rightarrow DG,G\rightarrow b$</p><h2 id="2-下推自动机pda">2 下推自动机(PDA)</h2><blockquote><p>由于FA有局限性，可以识别$M=\{0^n1^m | n \ge 0, m \ge 0 \}$，但不能识别$L=\{ 0^n1^n | n \ge 0 \}$，所以有了PDA</p></blockquote><h3 id="1-形式化定义-1">1 形式化定义</h3><p><strong>下推自动机(Pushdown Automata)</strong>：PDA是一个七元组$P=(Q,\,\Sigma,\,\Gamma,\,\delta,\,q_0,\,z_0,\,F)$，其中，</p><ul><li>$Q$ 是有限的状态集；<li>$\Sigma$ 是有限的输入字符集；<li>$\Gamma$ 是有限的栈字符集；<li>$\delta$ 是状态转移函数，是一个映射 $Q\times (\Sigma\cup\{\varepsilon\})\times \Gamma \Rightarrow 2^Q\times \Gamma^*$；<li>$q_0$ 是初始状态；<li>$z_0$ 是初始栈符，表示栈是空的；<li>$F$ 是终结状态集；</ul><p><strong>例</strong>：构造PDA识别 $L=\{ww^R|w\in\{0,1\}^*\}$</p><p><strong>解</strong>：第一步，把 $w$ 入栈 \(\delta(q,0,z_0)=(q,0z_0),\quad \delta(q,1,z_0)=(q,1z_0)\\ \delta(q,0,0)=(q,00),\quad \delta(q,1,0)=(q,10)\\ \delta(q,0,1)=(q,01),\quad \delta(q,1,1)=(q,11)\) 第二步，从栈中弹出 $w^R$ \(\delta(q,1,1)=(p,\varepsilon),\quad \delta(q,0,0)=(q,\varepsilon)\\ \delta(p,1,1)=(p,\varepsilon),\quad \delta(p,0,0)=(q,\varepsilon)\) 第三步，转移到终结状态 $\delta(p,\varepsilon, z_0)=(r,z_0)$</p><p>图示如下，<em>这是一个不确定的PDA</em></p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713110900033.png" alt="image-20200713110900033" /></p><h3 id="2-确定的pda">2 确定的PDA</h3><p>如果一个PDA $P=(Q,\,\Sigma,\,\Gamma,\,\delta,\,q_0,\,z_0,\,F)$ 是确定的，那么它满足下面的条件：</p><ul><li>$\forall q\in Q,\forall a\in \Sigma \cup \{\varepsilon\},\forall X\in \Gamma$，$\delta(q,a,X)$ 的结果是唯一的；<li>$\delta(q,a,X)$ 和 $\delta(q,\varepsilon ,X)$ 只能有一个有定义，因为对于状态$q$来说，读 $\varepsilon$ 意味着不读 $a$，而另一个意味着读 $a$，所以读与不读就产生了不确定性。</ul><p><strong>例</strong>：构造确定的PDA识别 $L = \{ 0^n1^n | n &gt; 0 \}$</p><p><strong>解</strong>：这就是一个DPDA</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713113222517.png" alt="image-20200713113222517" /></p><h3 id="3-pda的瞬时描述">3 PDA的瞬时描述</h3><p>用一个三元组 $(q,w,\alpha)$ 来描述一个PDA在某一时刻的格局，其中，</p><ul><li>$q$ 是PDA此时的状态；<li>$w$ 是剩余的待读入字符串；<li>$\alpha$ 是栈中的字符串。</ul><p><strong>例</strong>：用格局序列描述2中构造的 $L = \{ 0^n1^n | n &gt; 0 \}$ 的PDA接受 $w=0011$ 的过程。</p><p><strong>解</strong>：$(q,0011,z_0)┝(q,011,0z_0)┝(q,11,00z_0)┝(p,1,0z_0)┝(p,\varepsilon,z_0)┝(r,\varepsilon,z_0)$</p><p>简记为 $(q,0011,z_0)┝^* (r,\varepsilon,z_0)$</p><h3 id="4-pda接受的语言">4 PDA接受的语言</h3><p>能够由PDA接受(CFG构造)的语言称为<strong>上下文无关语言(CFL)</strong>，PDA可以用两种方式描述接受语言：</p><ul><li>用<strong>终结状态</strong>来描述：$L(P) = \{w\,|\, (q_0, w, z_0)┝^* (q, \varepsilon, \alpha), q\in F\}$<li>用<strong>空栈状态</strong>来描述：$N(P) = \{w\,|\, (q_0, w, z_0)┝^* (q, \varepsilon, \alpha)\}$<li>这两种描述方式是<strong>等价</strong>的，即 $L(P) \Leftrightarrow N(p)$</ul><p>例如2中构造的 $L = \{ 0^n1^n | n &gt; 0 \}$ 的PDA就是用终结状态接受的，也可用空栈状态来描述，如下</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713115835687.png" alt="image-20200713115835687" /></p><p>但是并不是所有的PDA都可以用两种方式构造 (针对DPDA)，当 $L$ 可以<strong>被终结状态的DPDA接受</strong>并且 $L$ <strong>有前缀性</strong>的时候，$L$ 才能被空栈状态的DPDA接受。</p><blockquote><p>语言的<strong>前缀性</strong>：该语言中没有两个不同的字符串x和y，使得x是y的前缀。</p><p>如：语言 0* 就没有前缀性，因为0是00的前缀。</p></blockquote><h2 id="3-cfg和pda的等价性">3 CFG和PDA的等价性</h2><p>对于一个给定的上下文无关语言 $L$，存在一个CFG生成 $L$，且存在一个PDA识别 $L$。</p><h3 id="1-cfg-rightarrow-pda">1 CFG $\Rightarrow$ PDA</h3><p>把CFG $G=(V,T,S,P)$ 转化为PDA，则对应的PDA为 $B=(\{q\},T,V\cup T,\delta,q,S,\{\,\})$，其中，</p><ul><li>$\delta(q, \varepsilon, A) =\{(q, \alpha ) | A\rightarrow \alpha \in P \}$<li>$\delta(q, a, a) =(q, \varepsilon)$</ul><p><strong>例</strong>：将CFG $G=(\{S\},\{0,1\}, \{S\rightarrow 0S1, S\rightarrow SS, S\rightarrow \varepsilon \}, S)$ 转化为PDA。</p><p><strong>解</strong>：PDA为 $P=(\{q\}, \{0,1\}, \{0,1,S\}, \delta, q, S, \{\,\})$，其中 $\delta$ 定义如下：</p><ul><li>$\delta(q,\varepsilon, S)=\{(q,0S1), (q,SS), (q,\varepsilon)\}$<li>$\delta (q,0,0)=\{(q,\varepsilon )\}$<li>$\delta (q,1,1)=\{(q,\varepsilon )\}$</ul><p>用图表示</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713143306774.png" alt="image-20200713143306774" /></p><p>该PDA识别字符串 $w=0011$ 的过程：</p><p>$(q,0011,S)┝(q,0011,0S1)┝(q,011,S1)┝(q,011,0S11) ┝(q,11,S11)┝(q,11,11)┝(q,1,1)┝(q,\varepsilon,\varepsilon)$</p><p>对应的CFG派生序列：$S \Rightarrow 0S1 \Rightarrow 00S11 \Rightarrow 0011$</p><blockquote><p>转化出的PDA实际上是在模拟CFG的派生过程，所以PDA一定能就识别CFG生成的字符串</p></blockquote><h3 id="2-pda-rightarrow-cfg">2 PDA $\Rightarrow$ CFG</h3><p>把PDA $P=(Q,\,\Sigma,\,\Gamma,\,\delta,\,q_0,\,z_0,\,F)$ 转化为CFG，则对应的CFG为 $G=(V,\Sigma,S,R)$，其中，</p><ul><li>$V$ ：包括开始变元 $S$，这个变元和PDA没有关系，就是强行规定的；还有其他形如 $[qXp]$ 的符号，其中$\forall q,p \in Q, X\in \Gamma$<ul><li>符号 $[qXp]$ 的意义是在 $q$ 状态下，可以<strong>使栈中的 $X$ 弹出并转移到 $p$ 状态</strong>的字符串，例如有状态转移函数 $\delta(q_0, \varepsilon, z_0) = (p, \varepsilon)$，则 $[q_0z_0p]\rightarrow \varepsilon$，于是对于下面 $R$ 的第一条产生式规则，就有$S\rightarrow [q_0z_0p]$</ul><li>$R$ ：包括 $\forall p\in Q$，$S\rightarrow [q_0z_0p]$；还有 $[q X r_k]\rightarrow a[rY_1r_1][r_1Y_2r_2]… [r_{k-1}Y_kr_k]$，对于 $(r, Y_1Y_2…Y_k)\in \delta (q,a,X)$<ul><li>第一条产生式规则已经在上一条中描述了，下面是关于第二条产生式规则。对于状态转移函数 $\delta(q, a, X) = (r,Y_1Y_2…Y_k)$，因为 $[qXr_k]$ 表示的是把 $X$ <strong>全pop掉</strong>所需要的字符串，而状态转移函数读入字符串 $a$ 之后栈中的元素是 $Y_1Y_2…Y_k$，所以需要把这些元素也pop掉，因此最后的状态就不是 $r$ 而是 $r_k$，而第二条产生式规则的body部分 $a$ 之后的部分就是做这个的。</ul></ul><p><strong>例</strong>：还是用 <em>2.2确定的PDA</em> 中的例子，将其转化成CFG</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713113222517.png" alt="image-20200713113222517" /></p><p><strong>解</strong>：$P=(Q,\,\Sigma,\,\Gamma,\,\delta,\,q_0,\,z_0,\,F)\Rightarrow G=(V,\Sigma,S,R)$，其中 $V=\{S,[qz_0q], [qz_0p], [q0q], [q0p], [q1q], [q1p],[pz_0q], [pz_0p], [p0q], [p0p], [p1q], [p1p] \}$</p><p>然后根据转移函数导出产生式 $R$</p><ul><li>$\delta (q, 0, z_0) = (q, 0z_0)\Rightarrow [qz_0r_2]\rightarrow 0[q0r_1][r_1z_0r_2], \forall r_1,r_2\in Q \Rightarrow<br /> [qz_0q] \rightarrow 0[q0q][qz_0q]\; |\; 0[q0p][pz_0q]<br /> [qz_0p] \rightarrow 0[q0q][qz_0p]\; |\; 0[q0p][pz_0p]$<li>$\delta (q, 0, 0) = (q, 00)\Rightarrow [q0r_2] \rightarrow 0[q0r_1][r_10r_2], \forall r_1,r_2\in Q \Rightarrow <br /> [q0q] \rightarrow 0[q0q][q0q]\; |\; 0[q0p][p0q] <br /> [q0p] \rightarrow 0[q0q][q0p]\; |\; 0[q0p][p0p]$<li>$\delta(q, \varepsilon, z_0)=(p,z_0) \Rightarrow [qz_0r_1] \rightarrow [pz_0r_1], \forall r_1\in Q \Rightarrow <br /> [qz_0q] \rightarrow [pz_0q]<br /> [qz_0p] \rightarrow [pz_0p]$<li>$\delta(q, 1, 0) = (p,\varepsilon) \Rightarrow [q0p] \rightarrow 1$<li>$\delta(p, 1, 0) = (p,\varepsilon) \Rightarrow [p0p] \rightarrow 1$<li>$\delta(p, \varepsilon, z_0) = (p,\varepsilon) \Rightarrow [pz_0p] \rightarrow \varepsilon$</ul><p>把得到的产生式整合在一起得到 $R$ \(R = \\{\quad S \rightarrow [qz_0q]\,\, \|\,\, [qz_0p],\\ [qz_0q] \rightarrow 0[q0q][qz_0q] \,\,\|\,\, 0[q0p][pz_0q],\\ [qz_0p] \rightarrow 0[q0q][qz_0p] \,\,\|\,\, 0[q0p][pz_0p],\\ [q0q] \rightarrow 0[q0q][q0q] \,\,\|\,\, 0[q0p][p0q],\\ [q0p] \rightarrow 0[q0q][q0p] \,\,\|\,\, 0[q0p][p0p],\\ [qz_0q] \rightarrow [pz_0q]，\;[qz_0p] \rightarrow[pz_0p],\\ [q0p] \rightarrow 1,\; [p0p] \rightarrow 1,\; [pz_0p] \rightarrow \varepsilon \quad\\}\) 最后<strong>把 $R$ 按如下规则化简</strong>一下：</p><ul><li>消除含有没有终结符的变元的产生式，如：含有 $[pz_0q]$ 的产生式；<li>消除死循环的产生式，如：$[q0q]$ 的第一个产生式，因为它的第二个产生式由于 $[p0q]$ 满足第一条化简规则，所以它只剩下第一个产生式，所以它死循环了；<li>消除含有由于前两条规则导致的无用变元的产生式，如：因为 $[q0q]$ 无用，所以含有它的产生式也无用。</ul><p>最终得到 \(R = \\{\quad S \rightarrow [qz_0p],\;[qz_0p] \rightarrow 0[q0p][pz_0p],\\ [q0p] \rightarrow 0[q0p][p0p],\; [qz_0p] \rightarrow[pz_0p],\\ [q0p] \rightarrow 1,\; [p0p] \rightarrow 1,\; [pz_0p] \rightarrow \varepsilon \quad\\}\) 看起来不太方便，于是令$A=[qz_0p], B=[q0p], C=[p0p], D=[pz_0p]$，得到</p><p>$R = \{ S \rightarrow A,\; A\rightarrow 0BD|D,\; B\rightarrow1|0BC,\; C\rightarrow1,\; D\rightarrow \varepsilon \}$</p><p>再次化简得到：$R = \{ S\rightarrow 0B|\varepsilon,\; B\rightarrow 1| 0BC,\; C\rightarrow1 \}$</p><h2 id="4-上下文无关语言的性质">4 上下文无关语言的性质</h2><h3 id="1-泵引理">1 泵引理</h3><p><strong>上下文无关语言的泵引理</strong>：$L$ 是一个CFL，则 $\exist n$，对 $\forall w\in L$，若 $|w|\ge n$，则 $w$ 可以划分为 $w=uvxyz$，其中</p><ul><li>$|vxy| \le n$<li><p>$|vy| \ge 1$，(要是vy同时为空就出现 $A\rightarrow A$ 这种没有意义的产生式了)</p><li>$uv^ixy^iz\in L,\;\,\forall i=0,1,2,…$</ul><blockquote><p>n的取法：令 $m=|V|$，$k=max\{ |\alpha| \forall A\rightarrow \alpha \}$，则 $n=k^m$</p></blockquote><p>派生过程：$S\stackrel<em>\Rightarrow uAz \stackrel</em>\Rightarrow uvAyz\stackrel*\Rightarrow w$，语法解析树如下，对于重复出现的 A 来说，则可用子树的A代替父节点，此时失去的就是一对vy节点。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/BeiyanLuansheng/BeiyanLuansheng.github.io/main/pics/flaa/image-20200713201355413.png" alt="image-20200713201355413" /></p><p><strong>例</strong>：证明 $L=\{ww|w\in \{0,1\}^*\}$ 不是CFL。</p><p><strong>解</strong>：假设L是CFL。则由泵引理可知，存在一个常数n，对于L中长度不小于n的字符串w就可以划分为五个部分，$w=uvxyz$，其中 $|vxy| \le n$，$vy \ne \varepsilon$，$uv^kxy^kz\in L$。</p><p>取 $w=0^n1^n0^n1^n\in L$，则 $uvxyz=0^n1^n0^n1^n$(如果要推出矛盾，就需要推出 $uxz\notin L$)。v和y不能同时为空串且 $|vxy| \le n$，所以它们的取值情况可以分为7种情况，这七种情况又可以分为两类：</p><ul><li>第一类：vxy在同一类字符里，即同在开始的n个0、同时在开始的n个1里、同时在结束的n个0里，同时在结束的n个1里。这四种情况是等价的，而显然在第一种情况下有 $uxz\notin L$，因为开始的0的个数不足n了。<li>第二类：vxy在连续的两类字符里，即在前半部分的 $0^n1^n$ 中、在中间的 $1^n0^n$ 中、在后半部分的 $0^n1^n$中。这三种情况是等价的，而显然在第一种情况下有 $uxz\notin L$，因为开始的0和1的个数都不足n了。</ul><p>所有的情况都推出了矛盾，所以假设错误，即 L 不是CFL。</p><h3 id="2-封闭性">2 封闭性</h3><p>CFL在<strong>并、连接、星、反转、交、同态、逆同态</strong>运算下是封闭的，而在<strong>交、补</strong>运算下不是封闭的。</p><blockquote><p>对于两个CFL $L_1$ 和 $L_2$，令 $G(L_1)=(V_1,T_1,R_1,S_1), G(L_2)=(V_2,T_2,R_2,S_2)$</p><ul><li>并：$G(L_1 \cup L_2 ) = (V_1\cup V_2\cup \{S\},T_1\cup T_2, R,S)$，$R= \{S\rightarrow S_1 | S_2\} \cup R_1\cup R_2$<li>连接：$G(L_1 \cup L_2 ) = (V_1\cup V_2\cup \{S\},T_1\cup T_2, R,S)$，$R= \{S\rightarrow S_1 S_2\} \cup R_1\cup R_2$<li>星：$G(L_1^*) = (V_1,T_1, \{S_1\rightarrow S_1S_1|\varepsilon\}\cup R_1,S_1)$<li>反转：$G(L_1^R)=(V_1,T_1, \{A\rightarrow \alpha^R|A\rightarrow \alpha R_1\},S_1)$</ul></blockquote><p>交运算不封闭，例如：$L_1 =\{a^nb^nc^m | n\ge 0, m\ge 0\},\;L_2 =\{a^nb^mc^m | n\ge 0, m\ge 0\}$ 是两个CFL，它们的交就是 $L_1 \cup L_2 =\{ a^nb^nc^n | n\ge 0\}$，这不是CFL，可以按照上面的方式用泵引理证明。</p><blockquote><p>但是一个CFL和一个RL做交运算之后得到的还是CFL，这个条件下它是封闭的。</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/'>形式语言与自动机</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-tag no-text-decoration" >形式语言与自动机</a> <a href="/tags/hit-flaa/" class="post-tag no-text-decoration" >HIT-FLAA</a> <a href="/tags/2020%E6%98%A5/" class="post-tag no-text-decoration" >2020春</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=上下文无关文法和下推自动机 - XuJian&url=https://beiyanluansheng.github.io//posts/3-CFGandPDA/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=上下文无关文法和下推自动机 - XuJian&u=https://beiyanluansheng.github.io//posts/3-CFGandPDA/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=上下文无关文法和下推自动机 - XuJian&url=https://beiyanluansheng.github.io//posts/3-CFGandPDA/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nas/">使用Docker部署NAS</a><li><a href="/posts/route/">使用Docker部署OpenWRT旁路由</a><li><a href="/posts/10-dockerDeploy/">OES之十：Dcoker部署</a><li><a href="/posts/9-file/">OES之九：文件上传下载</a><li><a href="/posts/5-passValue/">OES之五：请求接口</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT-FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1-FiniteAutomata/"><div class="card-body"> <span class="timeago small" >2020-07-13<i class="unloaded">2020-07-13T22:48:55+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>有穷自动机 (Finite Automata)</h3><div class="text-muted small"><p> 1 确定的有穷自动机 (DFA) 1 形式化定义 确定的有穷自动机 (Deterministic Finite Automata)：DFA是一个五元组，如：$M=(Q,\; \Sigma,\; \delta,\;q_0,\; F)$ ，其中， $Q$ 是有限的状态集，包含DFA中所有的状态； $\Sigma$ 是有限的输入字符集，也就是DFA的字母表； $q_0$ 是初始...</p></div></div></a></div><div class="card"> <a href="/posts/2-RegularExpression/"><div class="card-body"> <span class="timeago small" >2020-07-13<i class="unloaded">2020-07-13T22:49:56+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>正则表达式 (Regular Expression)</h3><div class="text-muted small"><p> 1 正则表达式 正则表达式的递归定义： $\varepsilon$ 是一个正则表达式，表示语言 ${\varepsilon}$ ; $\phi$ 是一个正则表达式，表示空语言 $\phi$ ; $\forall a \in \Sigma$，$a$ 是一个正则表达式, 表示语言 ${a}$ ; 如果 $E$ 和 $F$ 是正则表达式，表示的语言分别是 $L(E)$ 和 $...</p></div></div></a></div><div class="card"> <a href="/posts/4-TuringMachine/"><div class="card-body"> <span class="timeago small" >2020-07-15<i class="unloaded">2020-07-15T12:33:48+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>图灵机 (Turing Machine)</h3><div class="text-muted small"><p> 1 形式化定义 图灵机(Turing Machine)：TM是一个七元组$P=(Q,\,\Sigma,\,\Gamma,\,\delta,\,q_0,B,\,F)$，其中， $Q$ 是有限的状态集； $\Sigma$ 是有限的输入字符集； $\Gamma$ 是有限的纸带字符集； $\delta$ 是状态转移函数，是一个映射 $Q\times \Gamma \Righta...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2-RegularExpression/" class="btn btn-outline-primary" prompt="上一篇"><p>正则表达式 (Regular Expression)</p></a> <a href="/posts/4-TuringMachine/" class="btn btn-outline-primary" prompt="下一篇"><p>图灵机 (Turing Machine)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.facebook.com/BeiyanLuansheng">XuJian</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/2020%E7%A7%8B/">2020秋</a> <a class="post-tag" href="/tags/hitcn/">HITCN</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/dokcer/">Dokcer</a> <a class="post-tag" href="/tags/2020%E6%98%A5/">2020春</a> <a class="post-tag" href="/tags/hit-flaa/">HIT FLAA</a> <a class="post-tag" href="/tags/system/">system</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
