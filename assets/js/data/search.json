[ { "title": "PVE部署AIO", "url": "/posts/pve/", "categories": "技术积累, AIO", "tags": "PVE", "date": "2025-07-28 20:21:34 +0800", "snippet": "debain虚拟机安装输入法删除所有包：apt purge fcitx*apt pure ibus*apt autoremove安装ibus-rimeapt install ibus-rime在 系统设置-&amp;gt;keyboard-&amp;gt;Input Sources 添加 Chinese -&amp;gt; Chinese(Prime) 重启ibus，已经可以输入中文了ibus restart安装双拼方案apt install librime-data-double-pinyin配置cd cd .config/ibus/rimetouch default.custom.yaml编辑文件 default.custom.yamlpatch: schema_list: - schema: double_pinyin_flypy # 小鹤 - schema: luna_pinyin_simp # 简体 - schema: luna_pinyin # 繁体 menu: page_size: 6 # 候选词数编辑文件 ~/.config/ibus/rime/build/ibus_rime.yamlstyle: horizontal: true # 水平展示再重启ibus，快捷键 Ctrl+` 可以切换输入法设置LXC容器 (可选)创建容器 从 数据中心 -&amp;gt; pve -&amp;gt; local -&amp;gt; CT模板 -&amp;gt; 模板 下载模板 创建CT，取消勾选无特权容器，开启嵌套，其余信息可以直接拉满直通核显 进入pve宿主机，查询硬件参数 ls -l /dev/dri# 输出total 0drwxr-xr-x 2 root root 80 Jul 27 02:02 by-pathcrw-rw---- 1 root video 226, 1 Jul 27 02:02 card1crw-rw---- 1 root render 226, 128 Jul 27 02:02 renderD128 - video 226, 1 是核显 - render 226, 128 是渲染器 - 下方会配置这两个信息 编辑容器配置文件```shnano /etc/pve/lxc/容器ID.conf添加lxc.cgroup2.devices.allow: c 226:1 rwmlxc.cgroup2.devices.allow: c 226:128 rwmlxc.cgroup2.devices.allow: c 29:0 rwmlxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dirlxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=filelxc.apparmor.profile: unconfinedlxc.cgroup.devices.allow: alxc.cap.drop:4. 进入lxc，登录用户root，密码为创建容器填的cd /dev/dri &amp;amp;&amp;amp; ls看到设备信息即可### lxc容器配置1. 换源，使用中科大镜像```shsed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list# 更新apt updateapt upgrade 设置语言和时区 # echo &#39;LANG=&quot;zh_CN.UTF-8&quot;&#39; &amp;gt;&amp;gt; /etc/default/localedgkg-reconfigure localestimedatectl set-timezone Asia/Shanghai 开启root ssh```shnano /etc/ssh/sshd_config编辑添加PermitRootLogin yes保存，重启sshservice ssh restart## 安装docker官方安装教程```shapt-get install ca-certificates curlinstall -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.ascchmod a+r /etc/apt/keyrings/docker.ascecho \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release &amp;amp;&amp;amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \\ tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/nullapt-get updateapt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin查看服务# 版本docker --versionDocker version 28.3.2, build 578ccf6# 服务状态systemctl status docker * docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; preset: enabled) Active: active (running) since Sun 2025-07-27 11:38:50 CST; 2min 12s agoTriggeredBy: * docker.socket Docs: https://docs.docker.com Main PID: 11259 (dockerd) Tasks: 14 Memory: 22.2M CPU: 237ms CGroup: /system.slice/docker.service `-11259 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockJul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.696927872+08:00&quot; level=info msg=&quot;CDI directory does not exist, skipping: failed to monitor for changes: no such file or directory&quot; dir=/var/run/cdiJul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.704224993+08:00&quot; level=info msg=&quot;Creating a containerd client&quot; address=/run/containerd/containerd.sock timeout=1m0sJul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.765915506+08:00&quot; level=info msg=&quot;Loading containers: start.&quot;Jul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.978540419+08:00&quot; level=info msg=&quot;Loading containers: done.&quot;Jul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.999836821+08:00&quot; level=info msg=&quot;Docker daemon&quot; commit=e77ff99 containerd-snapshotter=false storage-driver=overlay2 version=28.3.2Jul 27 11:38:49 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:49.999944188+08:00&quot; level=info msg=&quot;Initializing buildkit&quot;Jul 27 11:38:50 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:50.039825898+08:00&quot; level=info msg=&quot;Completed buildkit initialization&quot;Jul 27 11:38:50 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:50.045475250+08:00&quot; level=info msg=&quot;Daemon has completed initialization&quot;Jul 27 11:38:50 lxc-debian dockerd[11259]: time=&quot;2025-07-27T11:38:50.045530834+08:00&quot; level=info msg=&quot;API listen on /run/docker.sock&quot;Jul 27 11:38:50 lxc-debian systemd[1]: Started docker.service - Docker Application Container Engine.# 自启动systemctl is-enabled docker enabled安装 portainer# 创建卷docker volume create portainer_data# 启动服务docker run -d -p 9000:9000 --name byls-portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /opt/docker/portainer:/data portainer/portainer-ce:latest" }, { "title": "使用Docker部署ASF", "url": "/posts/asf/", "categories": "技术积累, AIO", "tags": "Dokcer, ASF", "date": "2023-06-22 20:21:34 +0800", "snippet": "部署archisteamfarmsudo docker pull justarchi/archisteamfarmsudo docker run -p 1242:1242 \\--name byls-asf \\--restart=always \\-v /home/byls/exos/dockers/asf/config:/app/config \\-d justarchi/archisteamfarm" }, { "title": "使用Docker部署jellyfin", "url": "/posts/jellyfin/", "categories": "技术积累, AIO", "tags": "Dokcer, jellyfin", "date": "2023-03-14 20:21:34 +0800", "snippet": "部署jellyfinsudo docker pull jellyfin/jellyfinsudo docker run -p 8096:8096 \\--name byls-jellyfin \\--restart=always \\-v /home/byls/exos/dockers/jellyfin/config:/config \\-v /home/byls/exos:/media jellyfin/jellyfin-d jellyfin/jellyfin 启动容器名为 byls-jellyfin 的 jellyfin 镜像 挂载数据文件到 /home/byls/dockers/mysql/data 目录下 服务端口为 8096，映射到 8096 " }, { "title": "Ubuntu创建RAID1", "url": "/posts/raid/", "categories": "技术积累, Linux", "tags": "linux, raid", "date": "2022-11-01 20:34:24 +0800", "snippet": "格式化硬盘准备两块相同大小的硬盘，用 parted 创建分区表# 查看所有硬盘sudo fdisk -l# 用 parted 打开sudo parted /dev/sda# 进入后 用 help 命令查看使用方法# 使用 GPT 分区表mklabel gpt# 使用TB为操作单位unit TB# 分区 为主分区且从0开始，大小为16TBmkpart primary 0 16创建RAID阵列使用 mdadm 工具创建 RAID 阵列sudo mdadm --create --verbose /dev/md0 --level=1 --raid-devices=2 /dev/sda1 /dev/sdb1 --create: 创建阵列 --verbose: 输入详细信息 /dev/md0: 创建后的阵列的设备名 --level: 要创建的 RAID 的级别，这里使用模式 1 --raid-devices: 指定 RAID 副本的磁盘数，在这里指定了 2 ，意思是平时有两个磁盘在工作。如果以后添加了第三块硬盘，那么第三块硬盘将作为备用磁盘。当工作中的两块磁盘有一块坏了，第三块将立刻启动，并将完好的一块的内容复制到新的盘中。查看创建进度$ cat /proc/mdstatPersonalities : [raid1] md0 : active raid1 sdb1[1] sda1[0] 15625745408 blocks super 1.2 [2/2] [UU] [&amp;gt;....................] resync = 0.1% (30076096/15625745408) finish=1319.9min speed=196928K/sec bitmap: 117/117 pages [468KB], 65536KB chunkunused devices: &amp;lt;none&amp;gt;创建完成$ cat /proc/mdstatPersonalities : [raid1] md0 : active raid1 sdb1[1] sda1[0] 15625745408 blocks super 1.2 [2/2] [UU] bitmap: 1/117 pages [4KB], 65536KB chunkunused devices: &amp;lt;none&amp;gt;挂载磁盘创建文件系统sudo mkfs.ext4 -F /dev/md0挂载mount /dev/md0 /home/byls/exos/保存阵列完成以上步骤后，将阵列保存下来，在下次启动的时候自动加载，因此需要将阵列信息保存到 /etc/mdadm/mdadm.conf 文件中。可以通过以下命令来自动扫描活动阵列并追加文件:sudo mdadm --detail --scan | sudo tee -a /etc/mdadm/mdadm.conf更新初始RAM文件系统(initramfs)sudo update-initramfs -u可能出现提示$ sudo update-initramfs -uupdate-initramfs: Generating /boot/initrd.img-5.15.0-52-genericI: The initramfs will attempt to resume from /dev/nvme0n1p6I: (UUID=3f658187-46c6-4e0b-9fc7-1e35d38d9b74)I: Set the RESUME variable to override this.解决方式：可能是SWAP分区的UUID被修改后而没有加入RESUME file# 首先使用如下命令打印/swap分区的UUID号，比对一下确认和上面的系统打印输出一致，锁定为该问题blkid | awk -F\\&quot; &#39;/swap/ {print $2}&#39;# 然后使用如下命令写入/swap分区的UUID号printf &quot;RESUME=UUID=$(blkid | awk -F\\&quot; &#39;/swap/ {print $2}&#39;)\\n&quot; | sudo tee /etc/initramfs-tools/conf.d/resume# 最后更新内核文件sudo update-initramfs -u保存挂截信息，修改 /etc/fstab 文件，在文件最后加入以下内容:/dev/md0 /home/byls/exos/ ext4 defaults 0 0参考 https://www.jianshu.com/p/3e6d5da2db81" }, { "title": "Docker安装qbittorrent", "url": "/posts/qbittorrent/", "categories": "技术积累, Linux", "tags": "linux, docker, qbittorrent", "date": "2022-10-21 21:44:49 +0800", "snippet": "拉取 4.1.9 版本镜像docker pull linuxserver/qbittorrent:4.1.9.99201911190849-6738-0b055d8ubuntu18.04.1-ls54启动docker run --name=byls-qb \\ --network host -d \\ -e WEBUI_PORT=9002 \\ -e TZ=&quot;Asia/Shanghai&quot; \\ -v /home/byls/dockers/qbittorrent:/downloads \\ --restart always \\ linuxserver/qbittorrent:4.1.9.99201911190849-6738-0b055d8ubuntu18.04.1-ls54 web端口使用9002 时区使用 上海 挂载下载目录 /downloads 到宿主机 /home/byls/dockers/qbittorrent登陆账号 admin密码 adminadmin" }, { "title": "Ubuntu2204自启动脚本", "url": "/posts/start/", "categories": "技术积累, Linux", "tags": "linux, ubuntu, system", "date": "2022-10-21 00:13:59 +0800", "snippet": "创建rc-local.service文件sudo cp /lib/systemd/system/rc-local.service /etc/systemd/system然后修改/etc/systemd/system/rc-local.service，在文件最下方添加如下两行：[Install] WantedBy=multi-user.target Alias=rc-local.service创建rc.local文件创建/etc/rc.local，里边写自己想要运行的命令。例：#!/bin/shecho &quot;This is test&quot; &amp;gt; /tmp/my.logexit 0给/etc/rc.local加上可执行权限 sudo chmod +x /etc/rc.local" }, { "title": "Ubuntu 创建桌面快捷方式", "url": "/posts/desktop-icon/", "categories": "技术积累, Linux", "tags": "linux, ubuntu, system", "date": "2022-10-21 00:13:59 +0800", "snippet": "把解压的程序移动到 /opt 目录下sudo mv jetbrains/ /opt在 /usr/share/applications 目录下创建一个扩展名为 .desktop 的文件cd /usr/share/applicationssudo touch idea.desktopsudo vim idea.desktop在文件中写入[Desktop Entry]Name=IDEAName[zh_CN]=IDEAComment=IDEAExec=/opt/jetbrains/idea-IU-222.3345.118/bin/idea.shIcon=/opt/jetbrains/idea-IU-222.3345.118/bin/idea.pngTerminal=falseType=ApplicationCategories=Application;Encoding=UTF-8StartupNotify=true" }, { "title": "使用Docker部署OpenWRT旁路由", "url": "/posts/route/", "categories": "技术积累, AIO", "tags": "Dokcer, OpenWRT, route", "date": "2022-10-13 23:35:34 +0800", "snippet": "设置网卡查看网络$ ifconfigdocker0: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:88ff:fe1a:1fbd prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt; ether 02:42:88:1a:1f:bd txqueuelen 0 (以太网) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 62 bytes 9179 (9.1 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eno2: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500 inet 192.168.1.105 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::27fb:f806:4a65:563a prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt; ether 00:e0:70:ef:34:01 txqueuelen 1000 (以太网) RX packets 80469 bytes 114226692 (114.2 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 22903 bytes 2493642 (2.4 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 19 memory 0x80a00000-80a20000 lo: flags=73&amp;lt;UP,LOOPBACK,RUNNING&amp;gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&amp;lt;host&amp;gt; loop txqueuelen 1000 (本地环回) RX packets 712 bytes 81234 (81.2 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 712 bytes 81234 (81.2 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0我的机器的网卡是eno2开启网卡混杂模式ip link set eno2 promisc on但是重启后N1会失效，永久设置vim /etc/rc.localip link set eno2 promisc on重启查看是否生效，首行出现 PROMISCeno2: flags=4419&amp;lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&amp;gt; mtu 1500 inet 192.168.1.105 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::27fb:f806:4a65:563a prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt; ether 00:e0:70:ef:34:01 txqueuelen 1000 (以太网) RX packets 132735 bytes 188186144 (188.1 MB) RX errors 0 dropped 17 overruns 0 frame 0 TX packets 34291 bytes 4998536 (4.9 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 19 memory 0x80a00000-80a20000 创建Docker虚拟网络docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eno2 macnet eno2 为自己实际的网卡名，一般是eth0 macnet 为名称，macvlan 为模式，另外请将 192.168.1.0 修改为你自己主路由网段。 查看docker network lsdocker部署拉取镜像docker pull unifreq/openwrt-aarch64 # ARMdocker pull sulinggg/openwrt:x86_64 # x86启动docker run --restart always -d --name=byls-openwrt --network macnet --privileged sulinggg/openwrt:x86_64 /sbin/init配置容器网络进入容器编辑网络配置docker exec -it byls-openwrt bashvi /etc/config/network修改 lan 部分的配置：ipaddr gateway dnsconfig interface &#39;lan&#39; option type &#39;bridge&#39; option ifname &#39;eth0&#39; option proto &#39;static&#39; option netmask &#39;255.255.255.0&#39; option ip6assign &#39;60&#39; option ipaddr &#39;192.168.1.11&#39; option gateway &#39;192.168.1.1&#39; option dns &#39;192.168.1.1&#39;配置宿主机和容器通讯# 宿主机创建一个macvlansudo ip link add host2docker(一个网络名称) link eno2(你的物理网卡) type macvlan mode bridge# 设置macvlan ip 并启用sudo ip addr add 192.168.1.10 dev host2docker ip link set host2docker up #启用新建网络# 增加路由表ip route add 目的ip(需要建立通讯的macvlan容器 ip) dev host2docker(上面宿主机建立的macvlan)开启samba共享需要ssh进入openwrtssh root@192.168.1.11进入后给要共享的用户设计共享密码，比如要给root用户共享登陆权限smbpasswd -a root如果没有用户，需要先创建用户# 没有自带useradd命令，也可以直接编辑 /etc/passwd 替代opkg install shadow-common shadow-useradd# 添加用户useradd byls# 设置共享密码smbpasswd -a byls开启webdav共享只能共享一个文件夹参考 https://www.kejiwanjia.com/jiaocheng/57242.html https://blog.csdn.net/zhangjingzheng/article/details/120178257 https://blog.csdn.net/weixin_44907046/article/details/123144254 https://www.bilibili.com/video/av205462504/ " }, { "title": "使用Docker部署NAS", "url": "/posts/nas/", "categories": "技术积累, AIO", "tags": "Dokcer, Redis, MySQL", "date": "2022-10-05 20:21:34 +0800", "snippet": "部署mysqlsudo docker pull mysql:8.0.30sudo docker run -p 3306:3306 \\--name byls-mysql \\--restart=always \\-v /home/byls/dockers/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=bylsmysqladmin \\-d mysql:8.0.30 启动容器名为 byls-mysql 的 mysql 镜像 挂载数据文件到 /home/byls/dockers/mysql/data 目录下 服务端口为 3306，映射到 3306 连接mysql -h 127.0.0.1 -u root -pbylsmysqladmincreate database nextcloud;部署Redissudo docker pull redis:7.0.5sudo docker run -p 6379:6379 \\--name byls-redis \\--restart=always \\-v /home/byls/dockers/redis/data:/data \\-v /home/byls/dockers/redis/redis.conf:/etc/redis/redis.conf \\-d redis:7.0.5 redis-server /etc/redis/redis.conf 启动容器名为 byls-redis 的 redis 镜像 挂载数据文件到 /home/byls/dockers/redis/data 目录下 挂在配置文件到 /home/byls/dockers/redis/redis.conf，并使用配置文件启动 服务端口为 6379，映射到 6379 部署 Nextcloudsudo docker pull nextcloud:24.0.5sudo docker run -p 9001:80 \\--name byls-nextcloud \\--restart=always \\-v /home/byls/dockers/nextcloud/html:/var/www/html \\--link byls-mysql:mysql \\--link byls-redis:redis \\-d nextcloud:24.0.5这里记得绑定一下自己的mysql，不然nextcloud直接用ip连接的时候会报错：报 SQLSTATE[HY000] [2002] No such file or directory 或者 SQLSTATE[HY000] [2002] Connection refusedfrp内网穿透https://github.com/fatedier/frp/releases服务端（服务器）下载服务端并解压wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gztar -zxvf frp_0.44.0_linux_amd64.tar.gz进入解压目录cd frp_0.44.0_linux_amd64vim frps.ini修改为[common]bind_port = 9000 # frp监听的端口，默认是7000，可以改成其他的token = 123456 # 授权码，请改成更复杂的dashboard_port = 7000 # frp管理后台端口，请按自己需求更改dashboard_user = admin # frp管理后台用户名和密码，请改成自己的dashboard_pwd = adminenable_prometheus = true# frp日志配置log_file = /var/log/frp.loglog_level = infolog_max_days = 3启动，报错没日至权限可使用sudo启动./frps -c ./frps.ini &amp;amp;客户端（本地）下载客户端并解压（和服务端是同一个压缩包）wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gztar -zxvf frp_0.44.0_linux_amd64.tar.gz进入解压目录修改 frpc.inicd frp_0.44.0_linux_amd64vim frpc.ini[common]server_addr = xx.xx.xx.xx # 服务器地址server_port = 9000 # 服务端设置的bind_porttoken = 123456 # 服务端设置的token[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 9999[nextcloud]type = tcplocal_ip = 127.0.0.1local_port = 9001remote_port = 9001启动./frpc -c ./frpc.ini &amp;amp;用ssh或者访问nextcloud管理页面试试能不能访问后续nextcloud会有访问域名的校验，所以需要在nextcloud的 config/config.php 中设置你的服务器地址。找到 trusted_domains 列表，加上你的服务器地址 &#39;trusted_domains&#39; =&amp;gt; [ &#39;xx.xx.xx.xx&#39; ],参考 https://www.cnblogs.com/xwgli/p/16512462.html https://www.cnblogs.com/maowenqiang/p/16010447.html https://blog.csdn.net/weixin_43922901/article/details/109261700 " }, { "title": "Linux创建新用户", "url": "/posts/newUser/", "categories": "技术积累, Linux", "tags": "linux, ubuntu, system", "date": "2022-02-22 10:38:20 +0800", "snippet": "切换到 root 用户$ sudo su添加新用户# adduser username授予 sudo 权限# adduser username sudo重新登陆 username 用户查看是否正常" }, { "title": "OES之十：Dcoker部署", "url": "/posts/10-dockerDeploy/", "categories": "技术积累, Spring-OES", "tags": "Dokcer, Redis, MySQL", "date": "2022-01-11 14:09:34 +0800", "snippet": "部署 MinIO拉取镜像sudo docker pull minio/minio启动sudo docker run -p 8081:9000 -p 8082:9001 --name oesminio -v /home/oes/minio/data:/data -e MINIO_ROOT_USER=oesminio -e MINIO_ROOT_PASSWORD=oesminioadmin -d minio/minio server /data --console-address &quot;:9001&quot; 启动容器名为 oesminio 的 minio/minio 镜像 挂在数据文件到 /home/oes/minio/data 目录下 启动控制台端口为 9001，映射到 8082 访问端口为 9000，映射到 8081 部署 Redis拉取镜像sudo docker pull redis启动sudo docker run -p 6379:6379 --name oesredis -v /home/oes/redis/data:/data -v /home/oes/redis/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf --appendonly yes 启动容器名为 oesredis 的 redis 镜像 挂载数据文件到 /home/oes/redis/data 目录下 挂在配置文件到 /home/oes/redis/redis.conf，并使用配置文件启动 服务端口为 3306，映射到 3306 --appendonly yes 开启持久化存储 部署 MySQL拉取镜像sudo docker pull mysql启动sudo docker run -p 3306:3306 --name oesmysql -v /home/oes/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=oesmysqladmin -d mysql 启动容器名为 oesredis 的 redis 镜像 挂载数据文件到 /home/oes/mysql/data 目录下 挂在配置文件到 /home/oes/redis/redis.conf，并使用配置文件启动 服务端口为 3306，映射到 3306 远程客户端连接时需要设置连接参数 allowPublicKeyRetrieval=true 否则报错 Public Key Retrieval is not allowed部署 OESDocker 打包编写DockerfileFROM openjdk:11COPY . /usr/src/oesWORKDIR /usr/src/oesEXPOSE 8089CMD java -jar oes-start/target/oes-start-1.0.0-SNAPSHOT.jar 注：上面的Dockerfile没有写maven打包的过程，所以需要先手动maven打包再开始docker打包打包sudo docker build -t oes:v1 .镜像上传镜像拉取启动sudo docker run --name oes-instance -p 8080:8089 -v /home/oes/oes/logs:/usr/src/oes/logs -d oes:v1" }, { "title": "MiniIO 入门教程", "url": "/posts/buildMinIO/", "categories": "技术积累, MinIO", "tags": "docker, MinIO, file", "date": "2022-01-03 13:54:02 +0800", "snippet": "Minio 简介MinIO 官网 https://min.io/MinIO 官方手册 https://docs.min.io/docs/MinIO 官方中文手册 http://docs.minio.org.cn/docs/ 中文文档有滞后性MinIO 开源地址 https://github.com/minio/minioMiniIO 是一个开源的对象存储服务，适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据等，本文将介绍如何使用MinIO 搭建一个对象存储服务。搭建服务器首先服务器上需要安装 Dokcer（便于操作）拉取镜像docker pull minio/minio启动镜像，把文件存储目录挂载到宿主机上docker run -p 9090:9000 -p 9001:9001 --name minio -v /mydata/minio/data:/data -e MINIO_ROOT_USER=minioadmin -e MINIO_ROOT_PASSWORD=minioadmin -d minio/minio server /data --console-address &quot;:9001&quot;控制台启动之后我们就可以通过访问 http://host:9001 进入控制台，9001端口是在启动命令中加入的参数 --console-address &quot;:9001&quot; 否则会随机端口启动，并且我们把 docker 的9001端口映射到了物理机的 9001 端口，所以可以直接访问物理机的 9001 端口进入控制台启动时设置了账号密码参数 -e MINIO_ROOT_USER=minioadmin -e MINIO_ROOT_PASSWORD=minioadmin 所以可以用此账号登录控制台目录管理上一节的命令中，我们把 /data 目录挂载到了物理机的 /mydata/minio/data 目录下，这里就是MinIO存储的根目录在MinIO中，有两个概念，一个是 桶(Bucket)，其实际上就是在存储根目录下建立不同的文件夹，建立一个名为 avatar 的桶实际上就是创建路径 /mydata/minio/data/avatar另外一个就是文件存储名称，名称中与一般路径相同，可以添加以 / 分割的路径组织文件存储访问可以直接在线访问 .jpg, .png 等图片文件；可以直接在线访问 .mp4 等视频文件首先要保证桶的访问策略是公开的随便往这个桶上传一个文件，然后就可以直接使用保存路径访问这个桶里的文件MinIO 的默认访问端口是 9000，而我们在启动Docker 时把 9000 映射到了 9090，所以我们访问的是 9090如果文件类型不支持在线预览则会直接下载参考https://mp.weixin.qq.com/s/qHjOEeQ3CaA0U4a2YBi3Pwhttps://tonybai.com/2020/03/16/build-high-performance-object-storage-with-minio-part1-prototype/https://juejin.cn/post/6997202001834541069" }, { "title": "Ubuntu命令行升级版本", "url": "/posts/upgrade/", "categories": "技术积累, Linux", "tags": "linux, ubuntu, system", "date": "2021-12-30 18:02:46 +0800", "snippet": "查看系统信息内核版本$ uname -r系统信息$ cat /etc/os-release升级升级包列表$ sudo apt update升级已安装的包$ sudo apt upgrade升级 upgrade 失败的包$ sudo apt dist-upgrade升级$ sudo do-release-upgrade" }, { "title": "OES之八：邮箱验证", "url": "/posts/8-email/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, email", "date": "2021-12-30 17:00:00 +0800", "snippet": "以QQ邮箱为例在qq邮箱中打开 POP3/SMTP 服务（设置-&amp;gt;账户-&amp;gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务），会自动生成一个密钥，记下来，后面会用到 如果你以前在非QQ邮箱APP上登陆过 qq 邮箱，应该对这一步不陌生添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;发送邮件配置spring: # 邮件设置 mail: host: smtp.qq.com username: 941197279@qq.com password: abcdefghigklmnop default-encoding: utf-8此处的password 就是开始提到的生成的密钥接口public interface MailService { /** * 发送简单文本邮件 * * @param mailTo 邮件地址 * @param subject 邮件主题 * @param text 邮件内容 */ void sendSimpleMail(String mailTo, String subject, String text);}接口实现package org.oes.biz.service.impl;import org.oes.biz.service.MailService;import org.oes.common.config.BizConfigurations;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class MailServiceImpl implements MailService { private static final Logger logger = LoggerFactory.getLogger(MailService.class); @Resource private JavaMailSender mailSender; @Override public void sendSimpleMail(String mailTo, String subject, String text) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(BizConfigurations.mailFrom); message.setTo(mailTo); message.setSubject(subject); message.setText(text); mailSender.send(message); logger.info(&quot;邮件已经发送&quot;); }}随便写一个 Controller 测试一下邮箱验证有了邮件服务，我们就可以写验证码服务了，基本思路是随机生成验证码-&amp;gt;保存邮箱和验证码的对应关系-&amp;gt;根据用户的输入验证public interface VerificationService { /** * 给手邮箱发送验证码 * * @param email 邮箱 */ int sendEmailVerificationCode(String email); /** * 验证手机号的验证码 * * @param address 手机号或邮箱 * @param code 验证码 */ void codeVerification(String address, String code);}import org.oes.biz.component.RedisClient;import org.oes.biz.service.MailService;import org.oes.biz.service.VerificationService;import org.oes.common.exception.OesServiceException;import org.oes.common.utils.RandomUtils;import org.oes.common.utils.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.convert.DurationUnit;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.time.Duration;import java.time.temporal.ChronoUnit;import static org.oes.common.constans.OesConstant.VERIFICATION_PREFIX;@Servicepublic class VerificationServiceImpl implements VerificationService { private static final Logger logger = LoggerFactory.getLogger(VerificationServiceImpl.class); /** * 验证码有效时间 300 秒 */ @DurationUnit(ChronoUnit.SECONDS) private final Duration time = Duration.ofSeconds(300); @Resource private RedisClient redisClient; @Resource private MailService mailService; @Override public int sendEmailVerificationCode(String email) { String key = VERIFICATION_PREFIX + email; int code = randomCode(); redisClient.set(key, code + &quot;&quot;, time.getSeconds()); // 发送邮箱验证码邮件 String subject = &quot;在线教育系统验证码&quot;; String text = &quot;您正在注册在线教育系统，验证码为 &quot; + code + &quot;\\n 验证码五分钟内有效，如非本人操作请忽略&quot;; mailService.sendSimpleMail(email, subject, text); logger.error(&quot;向&quot; + email + &quot;发送验证码&quot; + code + &quot;成功&quot;); return code; } @Override public void codeVerification(String address, String code) { if (StringUtils.isBlank(code)) { throw new OesServiceException(&quot;请输入验证码&quot;); } String key = VERIFICATION_PREFIX + address; Object codeInRedis = redisClient.get(key); if (codeInRedis == null) { throw new OesServiceException(&quot;验证码已过期&quot;); } if (!StringUtils.isEquals(code, String.valueOf(codeInRedis))) { throw new OesServiceException(&quot;验证码不正确&quot;); } } /** * 随机生成六位数验证码 */ private int randomCode() { return RandomUtils.randomInt(100000, 1000000); }}然后再随便写一个 Controller 测试一下功能就大功告成啦参考https://cloud.tencent.com/developer/article/1594116" }, { "title": "OES之九：文件上传下载", "url": "/posts/9-file/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, file", "date": "2021-12-30 13:51:10 +0800", "snippet": "上传至服务器本地上传到服务器本地的指定文件夹下，需要判断目录是否存在，如果不存在就创建，创建好之后就可以把 MultipartFile 对象存在指定位置了import org.oes.biz.service.FileService;import org.oes.common.config.BizConfigurations;import org.oes.common.constans.OesConstant;import org.oes.common.exception.OesServiceException;import org.oes.common.utils.StringUtils;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;public class FileServiceImpl implements FileService { @Override public void uploadFile(MultipartFile file, String fileName) { if (StringUtils.isBlank(fileName)) { fileName = file.getOriginalFilename(); } File dest = new File( BizConfigurations.avatarDictionary + &quot;/&quot; + fileName); if (!dest.getParentFile().exists()) { dest.getParentFile().mkdirs(); } try { file.transferTo(dest); } catch (Exception e) { throw new OesServiceException(&quot;文件&quot; + file.getOriginalFilename() + &quot;上传失败&quot;); } }}测试 @RequestMapping(value = &quot;file/upload&quot;, method = RequestMethod.POST) public String fileUp(@RequestParam(&quot;files&quot;) MultipartFile[] files) { JSONObject object=new JSONObject(); for (MultipartFile file : files) { fileService.uploadFile(file, null); } object.put(&quot;success&quot;,1); object.put(&quot;result&quot;,&quot;文件上传成功&quot;); return object.toString(); }在这个 Controller 中使用了 file 数组，如果每次只需要上传一个文件，可以使用单个对象上传至对象存储服务器添加依赖 &amp;lt;!-- MinIO存储 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.minio&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;minio&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.3.4&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.9.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;官方给出的文档可以直接使用 io.minio:minio 但是我在启动的时候遇到了 okhttp3.RequestBody.create() 方法的两个参数类型是反的的错误，所以只能把低版本的 okhttp 排掉，使用高版本的，高版本的已经解决了这个问题MinIO 搭建参见 MiniIO 入门教程配置 Bean添加配置# 系统常量配置oes: minio: endpoint: http://192.168.1.9:9090 root-user: minioadmin root-password: minioadmin{： file=’oes-start/src/main/resources/application-dev.yml’}创建 Beanpackage org.oes.start.tools.minio;import io.minio.BucketExistsArgs;import io.minio.MakeBucketArgs;import io.minio.MinioClient;import org.oes.common.constans.OesConstant;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Shiro 配置类 * * @author XuJian * @since 2022/01/03 */@Configuration(proxyBeanMethods = false)public class MinioConfig { private static final Logger logger = LoggerFactory.getLogger(MinioConfig.class); @Value(&quot;${oes.minio.endpoint}&quot;) private String endpoint; @Value(&quot;${oes.minio.root-user}&quot;) private String accessKey; @Value(&quot;${oes.minio.root-password}&quot;) private String secretKey; @Bean public MinioClient minioClient() { try { MinioClient minioClient = MinioClient.builder().endpoint(endpoint).credentials(accessKey, secretKey).build(); boolean isExist = minioClient.bucketExists(BucketExistsArgs.builder().bucket(OesConstant.AVATARS_BUCKET).build()); if(isExist) { logger.info(&quot;avatar 桶已存在，跳过创建&quot;); } else { // 创建一个名为avatars的存储桶，用于存储照片文件 minioClient.makeBucket(MakeBucketArgs.builder().bucket(OesConstant.AVATARS_BUCKET).build()); } return minioClient; } catch (Exception e) { logger.error(&quot;创建 MinioClient 失败&quot;, e); return null; } }}文件上传服务package org.oes.biz.service.impl;import io.minio.MinioClient;import io.minio.PutObjectArgs;import org.oes.biz.service.FileService;import org.oes.common.exception.OesServiceException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;@Servicepublic class FileServiceImpl implements FileService { private static final Logger logger = LoggerFactory.getLogger(FileService.class); @Resource private MinioClient minioClient; /** * 文件上传服务 * * @param file 文件 * @param fileName 存储文件名（包含目录路径） * @param bucket 存储桶 */ @Override public void uploadFile(MultipartFile file, String fileName, String bucket) { try { minioClient.putObject( PutObjectArgs.builder().bucket(bucket) .object(fileName) .stream(file.getInputStream(), file.getSize(), -1) .contentType(file.getContentType()) .build()); } catch (Exception e) { logger.error(&quot;上传失败&quot;, e); throw new OesServiceException(&quot;文件上传失败，请尝试重新上传！&quot;); } }}此处的服务由于是要提供给 Web 端使用的，所以我直接使用了 MultipartFile 类型传文件，把它转成 ImputStream 再上传写测试 Controller @RequestMapping(value = &quot;file/upload&quot;, method = RequestMethod.POST) public String fileUp(@RequestParam(&quot;files&quot;) MultipartFile[] files) { for (MultipartFile file : files) { fileService.uploadFile(file, file.getOriginalFilename(), &quot;test&quot;); } return &quot;文件上传成功&quot;; }参考https://cloud.tencent.com/developer/article/1594124" }, { "title": "OES之七：权限管理 Shiro", "url": "/posts/7-Shiro/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, Shiro", "date": "2021-12-21 10:55:46 +0800", "snippet": "Shiro 简介Shiro 是一个Java安全框架，用于身份验证、授权、加密和会话管理官方主页 [https://shiro.apache.org/]{https://shiro.apache.org/}SpringBoot 集成 Shiro引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shiro-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;Realm 设置要想自定义实现身份认证和授权功能，就必须继承 org.apache.shiro.authc.AuthenticationException 类，实现自定义的认证 Realm doGetAuthenticationInfo() 用于登录认证，可以在此处实现用户登录时的认证方式，我是用 邮箱+密码 的方式直接去数据库里找进行验证，这里的参数 token 就是在登录的时候传入的，具体见下文。 doGetAuthorizationInfo() 用于实现获取用户的角色和权限，在执行带有 @RequiresPermissions 或 @RequiresRoles 的方法前、执行 subject.hasPermissions() 或 subjwect.hasRoles() 方法时会执行此方法 @Componentpublic class ShiroRealm extends AuthorizingRealm { @Resource private UserService userService; @Resource private CacheManager cacheManager; @PostConstruct private void initConfig() { setAuthenticationCachingEnabled(false); setAuthorizationCachingEnabled(true); setCachingEnabled(true); setCacheManager(cacheManager); } /** * 授权模块，获取用户角色和权限 * * @param principal principal * @return AuthorizationInfo 权限信息 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) { User user = (User) principal.getPrimaryPrincipal(); user = userService.doGetUserAuthorization(user); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.setRoles(user.getRoleNames()); simpleAuthorizationInfo.setStringPermissions(user.getPermissions()); return simpleAuthorizationInfo; } /** * 用户认证 * * @param token AuthenticationToken 身份认证 token * @return AuthenticationInfo 身份认证信息 * @throws AuthenticationException 认证相关异常 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 获取用户输入的邮箱和密码 String email = (String) token.getPrincipal(); String password = new String((char[]) token.getCredentials()); // 通过用户名到数据库查询用户信息 User user = this.userService.findByEmail(email); if (user == null || !StringUtils.isEquals(password, user.getPassword())) { throw new IncorrectCredentialsException(&quot;邮箱或密码错误！&quot;); } if (UserStatusEnum.LOCK.getCode().equals(user.getStatus())) { throw new LockedAccountException(&quot;账号已被锁定，请联系客服！&quot;); } return new SimpleAuthenticationInfo(user, password, getName()); }}ShiroConfig新建一个配置类，用于添加 Shiro 用到的所有的 bean首先是一堆写在 spring.yml 中的配置，此处可以先忽略，直接看方法import org.apache.shiro.cache.CacheManager;import org.apache.shiro.codec.Base64;import org.apache.shiro.session.mgt.SessionManager;import org.apache.shiro.session.mgt.eis.MemorySessionDAO;import org.apache.shiro.session.mgt.eis.SessionDAO;import org.apache.shiro.web.mgt.CookieRememberMeManager;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.apache.shiro.web.servlet.SimpleCookie;import org.crazycake.shiro.RedisCacheManager;import org.crazycake.shiro.RedisManager;import org.crazycake.shiro.RedisSessionDAO;import org.oes.common.constans.OesConstant;import org.oes.common.constans.Strings;import org.oes.common.utils.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.Base64Utils;import java.nio.charset.StandardCharsets;import java.util.Arrays;@Configuration(proxyBeanMethods = false)public class ShiroConfig { @Value(&quot;${spring.redis.host}&quot;) private String host; @Value(&quot;${spring.redis.port}&quot;) private int port; @Value(&quot;${spring.redis.password}&quot;) private String password; @Value(&quot;${spring.redis.timeout}&quot;) private int timeout; @Value(&quot;${spring.redis.database:0}&quot;) private int database; @Value(&quot;${oes.shiro.session-timeout}&quot;) private long shiroSessionTimeout; @Value(&quot;${oes.shiro.cookie-timeout}&quot;) private int shiroCookieTimeout; // ... 方法见下文}对应的配置文件新增内容spring: redis: # Redis数据库索引（默认为 0） database: 0 # Redis服务器地址 host: 127.0.0.1 # Redis服务器连接端口 port: 6379 # Redis 密码 password: lettuce: pool: # 连接池中的最小空闲连接 min-idle: 8 # 连接池中的最大空闲连接 max-idle: 500 # 连接池最大连接数（使用负值表示没有限制） max-active: 2000 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-wait: 10000 # 连接超时时间（毫秒） timeout: 5000# 系统常量配置oes: shiro: session-timeout: 3600 # session 超时时间，单位为秒 cookie-timeout: 864000 # rememberMe cookie有效时长，单位为秒首先是一个 Redis 的管理器，用于登录 Redis 服务，进行存取操作，此处用到了，前五个配置 /** * shiro 中配置 redis 缓存 * * @return RedisManager */ private RedisManager redisManager() { RedisManager redisManager = new RedisManager(); redisManager.setHost(host + Strings.COLON + port); if (StringUtils.isNotBlank(password)) { redisManager.setPassword(password); } redisManager.setTimeout(timeout); redisManager.setDatabase(database); return redisManager; }然后是缓存管理，我们直接使用 Redis 作为缓存管理器，创建一个缓存管理器的 bean @Bean public CacheManager cacheManager() { RedisCacheManager redisCacheManager = new RedisCacheManager(); redisCacheManager.setExpire((int) shiroSessionTimeout); redisCacheManager.setRedisManager(redisManager()); return redisCacheManager; }然后是关于 Cookie 用户设置设置记住我的功能 /** * cookie管理对象 * * @return CookieRememberMeManager */ private CookieRememberMeManager rememberMeManager() { CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); // rememberMe cookie 加密的密钥 String encryptKey = &quot;KEY_OES&quot;; byte[] encryptKeyBytes = encryptKey.getBytes(StandardCharsets.UTF_8); String rememberKey = Base64Utils.encodeToString(Arrays.copyOf(encryptKeyBytes, 16)); cookieRememberMeManager.setCipherKey(Base64.decode(rememberKey)); return cookieRememberMeManager; } /** * rememberMe cookie 效果是重开浏览器后无需重新登录 * * @return SimpleCookie */ private SimpleCookie rememberMeCookie() { // 设置 cookie 名称，对应 login.html 页面的 &amp;lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot;/&amp;gt; SimpleCookie cookie = new SimpleCookie(&quot;rememberMe&quot;); // 设置 cookie 的过期时间，单位为秒，这里为一天 cookie.setMaxAge(shiroCookieTimeout); return cookie; }然后是会话管理器，设置 Shiro 所使用的会话管理的管理器对象 /** * session 管理对象 * * @return DefaultWebSessionManager */ @Bean public SessionManager sessionManager(SessionDAO sessionDAO) { ShiroSessionManager sessionManager = new DefaultWebSessionManager(); // 设置 session超时时间 sessionManager.setGlobalSessionTimeout(shiroSessionTimeout * 1000L); sessionManager.setSessionDAO(sessionDAO); sessionManager.setSessionIdUrlRewritingEnabled(false); return sessionManager; } @Bean public SessionDAO sessionDAO() { RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); redisSessionDAO.setRedisManager(redisManager()); return redisSessionDAO; }最后是 securityManager，这是 Shiro 框架下的核心管理器，Shiro 所有的授权认证行为都将由此管理，在这里设置了认证使用的Realm、会话管理器、缓存管理器、记住我的Cookie @Bean public DefaultWebSecurityManager securityManager(ShiroRealm shiroRealm, SessionManager sessionManager, CacheManager cacheManager) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 配置 SecurityManager，并注入 shiroRealm securityManager.setRealm(shiroRealm); // 配置 shiro session管理器 securityManager.setSessionManager(sessionManager); // 配置 缓存管理类 cacheManager securityManager.setCacheManager(cacheManager); // 配置 rememberMeCookie securityManager.setRememberMeManager(rememberMeManager()); return securityManager; }ShiroEarlyConfig这个类其实可以和 ShiroConfig 合并，因为功能是一样的，但是为了减少对Bean后置处理器的影响，把它独立了出来，它主要实现了一个工厂 bean 创建 ShiroFilterFactoryBean此处还有一个坑 DefaultAdvisorAutoProxyCreator bean在我的系统中Spring并不会自动创建，需要手动创建，否则 Shiro 中的 @RequiresPermissions 注解会失效import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.oes.common.constans.URIs;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Lazy;import java.util.LinkedHashMap;import java.util.stream.Collectors;/** * 将注册时机较早的Bean单独提取出来，并且相关依赖延迟注入， * 尽可能的缩小对Bean后置处理器的影响 * &amp;lt;p&amp;gt; * https://github.com/spring-projects/spring-boot/issues/16097 * https://issues.apache.org/jira/browse/SHIRO-743 */@Configuration(proxyBeanMethods = false)public class ShiroEarlyConfig { @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Lazy DefaultWebSecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置 securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 登录的 url shiroFilterFactoryBean.setLoginUrl(URIs.LOGIN); // 登录成功后跳转的 url shiroFilterFactoryBean.setSuccessUrl(URIs.SUCCESS); // 未授权 url shiroFilterFactoryBean.setUnauthorizedUrl(URIs.UNAUTHORIZED); LinkedHashMap&amp;lt;String, String&amp;gt; filterChainDefinitionMap = URIs.unauthorized.stream() .collect(Collectors.toMap(url -&amp;gt; url, url -&amp;gt; &quot;anon&quot;, (a, b) -&amp;gt; b, LinkedHashMap::new)); filterChainDefinitionMap.put(URIs.LOGOUT, &quot;logout&quot;); // 除登出以外所有 url都必须认证通过才可以访问，未通过认证自动访问 LoginUrl filterChainDefinitionMap.put(URIs.ALL, &quot;user&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; } /* * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions) * 配置以下两个bean(DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor)即可实现此功能 */ /** * 配置此对象的目的是,在spring容器启动时, * 扫描所有的advisor(顾问)对象,基于advisor * 对象中切入点的描述,为目标对象创建代理对象 */ @Bean public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; } @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(@Lazy DefaultWebSecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; }}关于后置处理器，启动时会有如下的日志，虽然只是一个INFO，可能不会影响到系统功能[main] INFO o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean &#39;shiroEarlyConfig&#39; of type [org.oes.start.tools.shiro.ShiroEarlyConfig] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)权限问题在上一节的 ShiroFilterFactoryBean bean 创建的时候有配置一些对 URI 访问时的权限认证 LoginUrl：判断用户未登录时跳转的地址 successUrl：登陆成功跳转 URL UnauthorizedUrl：未授权的 URL 其他 URL 及其使用的过滤器，具体解释可参见 http://www.cppblog.com/guojingjia2006/archive/2014/05/14/206956.html 使用的 URIs 常量类如下package org.oes.common.constans;import java.util.ArrayList;import java.util.List;/** * 资源地址 */public class URIs { public static final String ALL = &quot;/**&quot;; /** * 登录 */ public static final String LOGIN = &quot;/login&quot;; /** * 注册 */ public static final String REGISTER = &quot;/register&quot;; /** * 忘记密码 */ public static final String FORGET = &quot;/forget&quot;; /** * 验证手机验证码 */ public static final String PHONE_VERIFICATION = &quot;/phone&quot;; /** * 验证邮箱验证码 */ public static final String EMAIL_VERIFICATION = &quot;/email&quot;; /** * 设置密码 */ public static final String PASSWORD = &quot;/password&quot;; /** * 未授权 */ public static final String UNAUTHORIZED = &quot;/unauthorized&quot;; /** * 登出 */ public static final String LOGOUT = &quot;/logout&quot;; /** * 登录成功 */ public static final String SUCCESS = &quot;/success&quot;; /** * 角色操作 */ public static final String ROLE = &quot;/role&quot;; /** * 权限操作 */ public static final String PERMISSIONS = &quot;/permissions&quot;; /** * 用户操作 */ public static final String USER = &quot;/user&quot;; /** * 课程操作 */ public static final String COURSE = &quot;/course&quot;; /** * 免认证部分的URL */ public static List&amp;lt;String&amp;gt; unauthorized = new ArrayList&amp;lt;&amp;gt;(); static { unauthorized.add(LOGIN); unauthorized.add(REGISTER); unauthorized.add(PHONE_VERIFICATION); unauthorized.add(EMAIL_VERIFICATION); unauthorized.add(UNAUTHORIZED); unauthorized.add(SUCCESS); }}权限使用我仅使用到了 权限过滤 功能，角色过滤同理 @RequestMapping(path = URIs.TEST, method = RequestMethod.GET) @RequiresPermissions(&quot;perms:test&quot;) public OesHttpResponse test() { return OesHttpResponse.getSuccess(); }访问成功则返回 success，否则会跳转到对应的地址参考https://blog.csdn.net/xiaoxiaole0313/article/details/105501799https://blog.csdn.net/weixin_46504244/article/details/120385617https://blog.csdn.net/palerock/article/details/73457415" }, { "title": "OES之六：跨域请求", "url": "/posts/6-CORS/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, RESTful", "date": "2021-12-16 18:04:37 +0800", "snippet": "由于本项目是完全前后端分离的设计，所以前端在使用后端接口的时候必然涉及到跨域请求跨域CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 当两个域具有相同的通信协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域（协议，域名，端口都必须相同）。跨域就指着协议，域名，端口不一致，出于安全考虑，跨域的资源之间是无法交互的(例如一般情况跨域的JavaScript无法交互)整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一：HEAD、GET、POST（2）HTTP的头信息不超出以下几种字段（没有自定义字段）：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type 需要注意的是 Content-Type 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。凡是不同时满足上面两个条件，就属于非简单请求。简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个 Origin 字段。GET /cors HTTP/1.1Origin: http://example.orgHost: example.orgAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...Origin 字段用来说明本次请求来自哪个源（协议 + 域名 + 端口）。服务端根据这个值，决定是否同意这次请求。 如果 Origin 源不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。（参见5.1节） 如果 Origin 源在许可范围内，服务器返回的响应会多出几个头信息字段。 Access-Control-Allow-Origin: http://example.orgAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：是HTML5中定义的一种解决资源跨域的策略。该字段是必须的。它的值要么是请求时Origin字段的值表示该域可以请求数据，要么是一个 * 表示同意任意跨源请求 Access-Control-Allow-Credentials：可选字段是一个布尔值表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在此字段指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;) 可以返回 FooBar 字段的值。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。如下是一个 PUT 请求，自定义了一个 My-custom-header 头PUT /cors HTTP/1.1My-custom-header: valueOrigin: http://example.orgHost: example.orgAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...浏览器发现这是一个非简单请求，就自动发出一个”预检”请求，这是一个 OPTIONS 方法的 HTTP 请求OPTIONS /cors HTTP/1.1Origin: http://example.orgAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: My-custom-headerHost: example.orgAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到的 HTTP 方法，上例是 PUT。 Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是 My-custom-header 预检请求的回应HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://example.orgAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: My-custom-headerAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain Access-Control-Allow-Origin：同简单请求时的含义 Access-Control-Allow-Methods：必需字段，值是逗号分隔的字符串表明服务器支持的所有跨域请求的方法 Access-Control-Allow-Headers：如果请求包括Access-Control-Request-Headers字段，则此字段是必需。同样是逗号分隔的字符串表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials：同简单请求时的含义 Access-Control-Max-Age：可选字段，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒，在此期间，不用发出另一条预检请求。 服务端处理请求服务端未处理跨域请求后端在没有对跨域请求做处理时，前端（浏览器）会抛出如下的异常信息Access to XMLHttpRequest at &#39;http://localhost:8089/test&#39; from origin &#39;http://localhost:3000&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 此处新建了一个React项目简单地发送了一个Get请求，React项目的域就是 http://localhost:3000解决方案现在有两（三）种解决方案 Filter实现一个 Filter 接口，使用 @WebFiler 注解标明拦截的URL，然后对 response 的 header 进行字段的设置import org.springframework.stereotype.Component;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Component@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;CORSFilter&quot;)public class CORSFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; HttpServletRequest reqs = (HttpServletRequest) req; String curOrigin = reqs.getHeader(&quot;Origin&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, curOrigin == null ? &quot;true&quot; : curOrigin); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PATCH, DELETE, PUT&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); chain.doFilter(req, res); } @Override public void init(FilterConfig filterConfig) { System.out.println(&quot;CORSFilter Config complete&quot;); } @Override public void destroy() {}} WebMvcConfigurer这个下面其实有两种方案，建议直接实现 WebMvcConfigurer 接口，如下import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CORSConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;,&quot;PATCH&quot;) .maxAge(3600); }}另一种是之前的方案，但是现在已经被废弃。WebMvcConfigurerAdapter 实际上还是实现 WebMvcConfigurer 的一个抽象类，jdk1.8之后就不需要这个Adapter了import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class CorsConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowedMethods(&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;,&quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .allowCredentials(true) .maxAge(3600); }}参考https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORShttps://www.ruanyifeng.com/blog/2016/04/cors.html" }, { "title": "OES之五：请求接口", "url": "/posts/5-passValue/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, RESTful", "date": "2021-12-13 19:45:48 +0800", "snippet": "RESTful接口REST（Representational State Transfer）表述性状态转换，REST指的是一组架构约束条件和原则URI几点规范： 不用大写 用减号连接 -，不用下划线 _ 连接； URI中的名词表示资源集合，使用复数形式 URI不使用动词，通过方法表示动作 参数列表要encode 避免层级过深的URI 访问 Composite 资源要通过父实体。比如用户地址，地址脱离用户没有意义，所以URI要先访问 user，再访问 address，即 /user/address request方法通过标准HTTP方法对资源CRUD： GET：查询 POST：创建单个资源 PUT：更新单个资源（全量），客户端提供完整的更新后的资源 PATCH：负责部分更新，与 PUT 对应，客户端提供要更新的那些字段。PUT/PATCH 一般仅操作单个资源 DELETE：删除 格式 Content-Type: application/jsonPOST /user HTTP/1.1Host: api.example.orgAccept: application/jsonContent-Type: application/jsonContent-Length: 24 { &quot;userName&quot;: &quot;abcd&quot;, &quot;password&quot;: &quot;123456&quot;} Content-Type: application/x-www-form-urlencoded (浏览器POST表单用的格式)POST /login HTTP/1.1Host: api.example.orgContent-Length: 31Accept: text/htmlContent-Type: application/x-www-form-urlencoded userName=abcd&amp;amp;password=123456 Content-Type: multipart/form-data; boundary=—-RANDOM_jDMUxq4Ot5 (表单有文件上传时的格式)@RequestParam 与 @RequestBody 及 @PathVariableSpringBoot 项目的 Controller 需要接受来自客户端的 HTTP 请求，这些请求中的数据可能直接放在 URI 中作为参数，也可能放在请求体中@RequestParam 就是用于解析直接传入的参数例如 /login?userName=abcd&amp;amp;password=123456@RequestBody 用于解析在请求体中的数据，可以解析复杂对象@PathVariable 用于解析数据作为 URI的一部分传入的情况，如传入一个 ID：DELETE /user/10001，表示删除 ID 为 10001 的用户使用 Postman 测试传参数测试传对象测试参考https://blog.csdn.net/qq_41606973/article/details/86352787" }, { "title": "OES之四：打包", "url": "/posts/4-Package/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot, maven", "date": "2021-12-03 12:08:55 +0800", "snippet": "到目前为止，这个工程可以说是成功建立了，它虽然只有一些基本的数据库操作，但现在你可以在 IDEA 中轻松的运行它但是，我们想将它在服务器上启动，就必须通过命令行进行打包、启动的操作在 OES之一：开始 一节中，我们在父模块下新建了四个子模块，现在我们要把整个项目打包，以方便部署父模块首先是父模块的pom.xml，在这个文件中做了以下设置 设置包的基本配置：包名、版本、打包类型。其中，打包类型一定要设置为 pom 方式 继承了 org.springframework.boot » spring-boot-starter-parent » 2.5.7 在你使用 IDE 创建子模块时，IDE一般会自动加入到 modules 中 属性 properties，这是一些你定义的常量，方便管理，这里只定义了 maven 编译时使用的 jdk 版本。等打包之后可以用 javap -v xxx.class 命令看一下编译打包时用的 jdk 是不是你设置的版本 依赖项 dependencyManagement 中的内容在下面的例子中被省略了 最后是 build 配置，如果使用Spring Initializr 创建这个父工程，默认的是spring-boot-maven-plugin，此处应把它去掉，这个应该只出现在你启动类所在的模块中。在这里只使用 maven 的插件，而 maven-surefire-plugin 这个插件在打包的时候默认会运行单元测试，在此处把它关掉。如果不需要额外的配置，此处 pom 中甚至不要 build 标签设置（亲测可以运行） &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;org.oes&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;OES&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.7&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;oes-biz&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;oes-common&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;oes-gateway&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;oes-start&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;!-- 此处省略了依赖项 --&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;skipTests&amp;gt;true&amp;lt;/skipTests&amp;gt; &amp;lt;!--默认关掉单元测试 --&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;子模块子模块的pom与父模块的pom区别不大，只是继承的不再是 spring-boot-starter-parent，而是你的父模块 org.oes » OES »1.0.0-SNAPSHOT另外，如果这个模块是启动类所在的模块，就要把下面的 build 部分加上，否则不要加build 中的 spring-boot-maven-plugin 插件中设置了启动类的路径，打包执行的方式（这些也可以不指定，直接使用默认选项）&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.oes&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;OES&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;oes-start&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;!-- 此处省略了依赖项 --&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;mainClass&amp;gt;org.oes.start.Application&amp;lt;/mainClass&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;打包有两种方式打包，如果你在 IDEA 中，可以直接点边栏上的 maven 插件中的选项，建议先点 clean 再点 package如果你在命令行，进入工程的根目录，执行 mvn clean package 就会自动先清理再打包了对于其中一个模块，会看到如下图的输出 (图例为oes-common)最后会得到下图的结果，表明打包成功启动把所有的子模块都打成 jar 包后，进入工程根目录，执行 java -jar 命令启动即可注：其实在哪里启动都可以，只不过如果你的 logback.xml 中使用的是相对路径，那么你的 log 文件的位置会变 图中输出的图像只需要在 resources 目录下建一个 banner.txt 就可以替换掉啦使用 mvn 启动也可以通过 spring-boot 的 maven 插件 spring-boot-maven-plugin 方式启动，但是比较繁琐首先需要在工程根目录下执行 mvn install 命令把所有的模块打包（其实只需要打包除启动模块外的模块，所以也可在子模块中挨个执行），安装在本地的 maven 仓库中然后在 启动模块的目录下 执行 mvn spring-boot:run，注意，一定要在启动模块的目录下，否则会找不到启动类找不到启动类的解释：如下所示，有一个名为 classesDirectory 的配置，默认是下面的值，所以如果在其他地方启动就会找不到这个位置，导致找不到启动类&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;classesDirectory&amp;gt;${project.build.outputDirectory}&amp;lt;/classesDirectory&amp;gt; &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;问题汇总Maven 打包异常：Unable to find main class 这个问题应该是由于在父模块的 pom 中加入了 spring-boot-maven-plugin，移动到子模块中就好了Maven 打包异常：程序包 xxx 不存在 其中的程序包是来自其他子模块 一般是由于你改了一些文件然后重新打包，但是打包前没有做 clean 导致的，所以强烈建议先 clean 再 packageMaven 打包异常：maven-surefire 运行 test 失败 一般是由于你在 test文件夹下写了一些单元测试，但是又不是所有的测试都能通过，所以报错测试失败 要么把失败的测试用例删掉 要么配置一下跳过测试，参见父模块的 pom 文件设置，也可以在命令行加参数 -Dmaven.test.skip=true" }, { "title": "OES之三：日志", "url": "/posts/3-Logback/", "categories": "技术积累, Spring-OES", "tags": "Spring, logback, slf4j", "date": "2021-12-02 16:40:43 +0800", "snippet": "引包这里采用了 logback-classic 方案，据资料说 logback 性能要比 log4j 好 因为定义 slf4j 日志标准的和 logback 的开发者是同一个人，所以在定义和实现之间相比其他实现少了一个适配层而 logback 依赖 slf4j 等包，所以 logback-classic 实际上是整合了所有需要的包，方便使用 官方手册 http://logback.qos.ch/manual/index.html&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.7&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;注：SpringBoot 已经集成了这个日志框架，所以 SpringBoot 项目可以直接跳过引包spring-boot-starter其中包含了 spring-boot-starter-logging配置基础配置这是一个基础的配置文件，里面没有任何内容，后续的所有配置都将在 &amp;lt;configuration&amp;gt; 标签下&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&amp;gt;&amp;lt;/configuration&amp;gt;标签里的属性是可选的，没有特殊要求可以不用配置 scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为 true 。 scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当 scan 为 true 时，此属性生效。默认的时间间隔为1分钟。 debug: 当此属性设置为 true 时，将打印出 logback 内部日志信息，实时查看 logback 运行状态。默认值为 false 。 property 标签property 标签用于定义一些在配置文件中会使用到的常量，比如日志目录&amp;lt;configuration&amp;gt; &amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot; /&amp;gt;&amp;lt;/configuration&amp;gt;appender 标签负责写日志的核心组件，定义了日志的输出位置、格式等问题，它有两个必要属性 name 和 class 。name 指定 appender 名称，class 指定 appender 的全限定名。日志输出位置，有 ConsoleAppender, FileAppender, SMTPAppender, DBAppender, AsyncAppender 等。ConsoleAppender把日志输出到控制台，有以下子标签： encoder：对日志进行格式化。属性 class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;。有子标签 pattern 格式问题见下文 target：字符串 System.out(默认) 或 System.err FileAppender把日志输出到文件，有以下子标签： file：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值 append：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是 true encoder：同 ConsoleAppender prudent：如果是 true，日志会被安全的写入文件，即使其他的 FileAppender 也在向此文件做写入操作，效率低，默认是 false RollingFileAppender滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子标签： file, append, encoder：同 FileAppender prudent：当为true时，不支持 FixedWindowRollingPolicy 支持 TimeBasedRollingPolicy，但是有两个限制——不支持也不允许文件压缩；不能设置file 标签，必须留空。 rollingPolicy：当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。属性class定义具体的滚动策略类： class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot; 是最常用的滚动策略，根据时间来制定滚动策略，既负责滚动也负责触发滚动。有以下子标签： fileNamePattern：必要标签，包含文件名及 %d 转换符，%d 可以包含一个 java.text.SimpleDateFormat 指定的时间格式，如：%d{yyyy-MM-dd}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的 file 子标签可有可无，通过设置 file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到 file 指定的文件（活动文件），活动文件名不会改变；如果没设置file，活动文件名会根据fileNamePattern 的值，每隔一段时间改变一次。/ 或者 \\ 会被当做目录分隔符。 maxHistory：可选标签，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动且 maxHistory 是3，则只保存最近3天的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot; 是根据固定窗口算法重命名文件的滚动策略，它只负责滚动，触发滚动依赖 apper 下的另一个子标签 triggeringPolicy。有以下子标签： minIndex：窗口索引最小值 maxIndex：窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。 fileNamePattern：必须包含 %i 例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log，会产生归档文件 mylog1.log 和 mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 log%i.log.zip triggeringPolicy: 触发 RollingFileAppender 的滚动。策略 class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot; 会查看当前活动文件的大小，如果超过指定大小会触发滚动。只有一个标签: maxFileSize：活动文件的大小，默认值是10MB。 例：　　　&amp;lt;appender name=&quot;logfile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; 　　　　　　&amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt; 　　　　　　　　　&amp;lt;fileNamePattern&amp;gt;logFile.log.%d{yyyy-MM-dd}&amp;lt;/fileNamePattern&amp;gt; 　　　　　　　　　&amp;lt;maxHistory&amp;gt;3&amp;lt;/maxHistory&amp;gt; 　　　　　　&amp;lt;/rollingPolicy&amp;gt; 　　　　　　&amp;lt;encoder&amp;gt; 　　　　　　　　　&amp;lt;pattern&amp;gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&amp;lt;/pattern&amp;gt; 　　　　　　&amp;lt;/encoder&amp;gt; 　　　&amp;lt;/appender&amp;gt; 　　　&amp;lt;appender name=&quot;test&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; 　　　　　　&amp;lt;file&amp;gt;test.log&amp;lt;/file&amp;gt; 　　　　　　&amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&amp;gt; 　　　　　　　　　　&amp;lt;fileNamePattern&amp;gt;tests.%i.log.zip&amp;lt;/fileNamePattern&amp;gt; 　　　　　　　　　　&amp;lt;minIndex&amp;gt;1&amp;lt;/minIndex&amp;gt; 　　　　　　　　　　&amp;lt;maxIndex&amp;gt;3&amp;lt;/maxIndex&amp;gt; 　　　　　　&amp;lt;/rollingPolicy&amp;gt; 　　　　　　&amp;lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&amp;gt; 　　　　　　　　　　&amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt; 　　　　　　&amp;lt;/triggeringPolicy&amp;gt; 　　　　　　&amp;lt;encoder&amp;gt; 　　　　　　　　　&amp;lt;pattern&amp;gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&amp;lt;/pattern&amp;gt; 　　　　　　&amp;lt;/encoder&amp;gt; 　　　&amp;lt;/appender&amp;gt; AsyncAppender异步添加日志，不单独使用，一般通过引用其它具体的appender来使用。如：&amp;lt;!-- logfile 是一个 FileAppder --&amp;gt;&amp;lt;appender name=&quot;ASYNC&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;logfile&quot; /&amp;gt;&amp;lt;/appender&amp;gt;logger 标签设置某一包或类下的日志打印级别、appender&amp;lt;!--控制指定 Logger 的日志输出（包括等级和输出位置）, additivity 表示日志信息是否向上传递，默认为 true 传递--&amp;gt; &amp;lt;logger name=&quot;exampleLogger&quot; level=&quot;warn&quot; additivity=&quot;false&quot;&amp;gt; &amp;lt;!--可多个appender--&amp;gt; &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt; &amp;lt;/logger&amp;gt;需要说明的是，additivity 属性表示的是这一条日志除了会写到它本身的appender中，是否还会写到上级的 appender 中（即会不会不重复打印）结合下一节的 root 标签定义举例，additivity 表示一条 exampleLogger 的日志在打到 FILE 中后是否还会打到 STDOUT 中 日志级别从低到高 TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATALroot 标签指定日志级别及输出的appender，与logger标签类似，不过是全局日志输出设置，在 logger 中指定对应属性后可以覆盖此配置 &amp;lt;root level=&quot;info&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt; &amp;lt;/root&amp;gt;pattern 标签：日志格式定义每行日志记录的格式，官网地址 https://logback.qos.ch/manual/layouts.html 功能 变量名 简写 说明   %logger %c或%lo 当前日志名称，如: Slf4jAndLogbackMain   %class %C 日志调用所在类，如: com.dragon.study.log.Slf4jAndLogbackMain   %method %M 日志所在方法，如: main   %caller   日志调用位置，如：at com.dragon.study.log.Slf4jAndLogbackMain.main(Slf4jAndLogbackMain.java:15)   %thread %t 日志调用所有线程序,如：main   %level %p或%le 日志级别，如：INFO   %date %d 日期，如: 2018-12-15 21:40:12,890   %msg %m 日志记录内容   %exception %ex 异常记录 宽度设置 %20logger   当字符数少于20个字符时，则左侧留空白   %-20logger   当字符数少于20个字符时，则右侧留空白   %.30logger   当字符数据大于30个时，则截断 显示设置 %highligth   突出显示   %green(%red、%blue、%white)   字体显示为指定颜色   {length}   可指定长度，如%logger{36} 网络访问设置（依赖logger-access包） %remoteIP %a 远程ip   %localIP %A 本地ip   %clientHost %h 远程主机名   %localPort   本地端口   %requestMethod %m http请求方法   %protocol %H http请求协议   %statusCode %s http请求status code   %requestURL %r http请求地址   %requestURI %U http请求资源地址   %queryString %q http请求参数   %server %v 服务器地址   %elapsedTime %D http请求处理的时间，单位是毫秒   %elapsedSeconds %T http请求处理的时间，单位是秒   %date %t 日志记录时间   %threadName %I 处理请求的线程名   %reqAttribute{attributeName}   http请求attribute值   %reqCookie{cookie}   http请求cookie值   %reqContent   http请求体内容   %fullRequest   http完整请求   %responseContent   http响应   %fullResponse   http完整响应 配置文件在 oes-start 的 resource 文件中新建 logback.xml 用于自定义配置，根据以上的说明写一个简单的配置文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot; /&amp;gt; &amp;lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt; &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt; &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&amp;gt; &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 每天生成日志文件 --&amp;gt; &amp;lt;appender name=&quot;oesAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; &amp;lt;file&amp;gt;${LOG_HOME}/oes.log&amp;lt;/file&amp;gt; &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt; &amp;lt;!--日志文件输出的文件名 --&amp;gt; &amp;lt;FileNamePattern&amp;gt;${LOG_HOME}/oes.log.%d{yyyy-MM-dd}&amp;lt;/FileNamePattern&amp;gt; &amp;lt;!--日志文件保留天数 --&amp;gt; &amp;lt;MaxHistory&amp;gt;2&amp;lt;/MaxHistory&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt; &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&amp;gt; &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 日志输出级别 --&amp;gt; &amp;lt;root level=&quot;INFO&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;stdout&quot;/&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;logger name=&quot;oesLogger&quot; additivity=&quot;false&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;oesAppender&quot;/&amp;gt; &amp;lt;/logger&amp;gt;&amp;lt;/configuration&amp;gt;使用写一个简单的测试 Controller，测试效果import org.slf4j.Logger;import org.slf4j.LoggerFactory;@RestControllerpublic class MainController { private static final Logger logger = LoggerFactory.getLogger(&quot;oesLogger&quot;); @GetMapping(&quot;/log&quot;) public String log() { logger.error(&quot;Test logger in MainController&quot;); return &quot;log success&quot;; }}日志如下2021-12-02 18:42:22.883 [http-nio-8089-exec-1] ERROR oesLogger - Test logger in MainController" }, { "title": "MySQL、jdbcType、Java Type之间的映射关系", "url": "/posts/JDBCType/", "categories": "技术积累, Mybatis", "tags": "Mybatis, jdbcType", "date": "2021-12-01 22:30:06 +0800", "snippet": " MySQL Type JdbcType Java Type CHAR CHAR String VARCHAR VARCHAR String LONG VARCHAR LONGVARCHAR String NUMERIC NUMERIC java.math.BigDecimal DECIMAL DECIMAL java.math.BigDecimal BIT BIT boolean BOOLEAN BOOLEAN boolean TINYINT TINYINT byte SMALLINT SMALLINT short INTEGER INTEGER int BIGINT BIGINT long REAL REAL float FLOAT FLOAT double DOUBLE DOUBLE double   BINARY byte[]   VARBINARY byte[]   LONGVARBINARY byte[] DATE DATE java.sql.Date TIME TIME java.sql.Time TIMESTAMP/DATETIME TIMESTAMP java.sql.Timestamp CLOB CLOB Text BLOB BLOB Blob   ARRAY Array   DISTINCT mapping of underlying type   STRUCT Struct   REF Ref   DATALINK java.net.URL 参考： http://www.mybatis.org/mybatis-3/apidocs/reference/org/apache/ibatis/type/JdbcType.html https://blog.csdn.net/loongshawn/article/details/50496460 " }, { "title": "OES之二：连接数据库", "url": "/posts/2-Database/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot", "date": "2021-12-01 22:19:48 +0800", "snippet": "整合 MybatisMyBatis-Spring-Boot-Starter 官方文档 http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/引入依赖 &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.27&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;此处引入了 mybatis-spring-boot-starter，这是一个 mybatis 整合了 SpringBoot 的包，使用这个包可以极大地减少我们手动配置的工作量配置# mybatis映射文件路径配置mybatis: type-aliases-package: org.oes.biz.entity mapper-locations: classpath:mapper/*.xml# 如果你不想使用下一节中的Druid，需要添加以下数据源配置，否则不需要spring: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/oes_db?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=GMT%2b8 username: root password: 123456type-aliases-package 是实体类的包路径，在这里配置之后就可以在 Mapper.xml 文件中直接使用类名了，而不需要使用类的完整路径mapper-locations 是 Mapper.xml 文件的路径，这些文件要放在 oes-biz 的 resources/mapper 目录下还有 Mapper.java 没有扫描到，这些将会被放在 oes-biz 模块下（/oes-biz/src/main/java/org/oes/biz/mapper）所以添加 @MapperScan 注解，指定包名import org.mybatis.spring.annotation.MapperScan;@MapperScan(&quot;org.oes.biz.mapper&quot;)@ComponentScan(&quot;org.oes&quot;)@SpringBootApplicationpublic class Application { ... }为了便于区分不同环境下的配置，我们把 application.yml 进一步拆分，新建三个文件 application-prod.yml 生产环境配置 application-dev.yml 开发环境配置 application-test.yml 测试环境配置 以开发环境为例spring: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/oes_db?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=GMT%2b8 username: root password: 123456然后在 application.yml 中使用这个配置# mybatis映射文件路径配置mybatis: type-aliases-package: org.oes.biz.entity mapper-locations: classpath:mapper/*.xmlspring: datasource: active: dev这样启动的时候就会默认加载 dev 配置，如果想要加载其他配置就可以在命令行中加入参数生产环境启动 mvn spring-boot:run -Dspring-boot.run.profiles=prod或 java -jar -Dspring.profiles.active=prod oes-start.jar 打包启动参见 OES之四：打包代码现在可以在 oes-biz 中写数据层的代码了建好数据库表，建好与数据库表一致的实体类，如package org.oes.biz.entity;import java.util.Date;public class Course { /** * 课程ID */ private Long courseId; /** * 课程创建时间 */ private Date gmtCreate; /** * 课程修改时间 */ private Date gmtModified; /** * 课程分类 ID */ private Long categoryId; /** * 开课教师 ID */ private Long teacherId; /** * 开课时间 */ private Date gmtStart; /** * 结课时间 */ private Date gmtEnd; /** * 课程状态 */ private String status; /** * 是否免费 */ private String isFree; /** * 收费价格 */ private Long price; // getter 和 setter 省略掉了 // ...}写一个 Mapperpackage org.oes.biz.mapper;import org.oes.biz.entity.Course;import org.apache.ibatis.annotations.Param;public interface CourseMapper { int insert(@Param(&quot;course&quot;) Course course);}写一个与这个 Mapper 类关联的 xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;&amp;lt;mapper namespace=&quot;org.oes.biz.mapper.CourseMapper&quot; &amp;gt; &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;org.oes.biz.entity.Course&quot; &amp;gt; &amp;lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt; &amp;lt;result column=&quot;gmt_create&quot; property=&quot;gmtCreate&quot; jdbcType=&quot;DATE&quot; /&amp;gt; &amp;lt;result column=&quot;gmt_modified&quot; property=&quot;gmtModified&quot; jdbcType=&quot;DATE&quot; /&amp;gt; &amp;lt;result column=&quot;category_id&quot; property=&quot;categoryId&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt; &amp;lt;result column=&quot;teacher_id&quot; property=&quot;teacherId&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt; &amp;lt;result column=&quot;gmt_start&quot; property=&quot;gmtStart&quot; jdbcType=&quot;DATE&quot; /&amp;gt; &amp;lt;result column=&quot;gmt_end&quot; property=&quot;gmtEnd&quot; jdbcType=&quot;DATE&quot; /&amp;gt; &amp;lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;is_free&quot; property=&quot;isFree&quot; jdbcType=&quot;CHAR&quot; /&amp;gt; &amp;lt;result column=&quot;price&quot; property=&quot;price&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;course&quot;&amp;gt; insert into course(gmt_create, gmt_modified,category_id,teacher_id,gmt_start,gmt_end,status,is_free,price) values (#{course.gmtCreate,jdbcType=DATE}, #{course.gmtModified,jdbcType=DATE}, #{course.categoryId,jdbcType=BIGINT}, #{course.teacherId,jdbcType=BIGINT}, #{course.gmtStart,jdbcType=DATE}, #{course.gmtEnd,jdbcType=DATE}, #{course.status,jdbcType=VARCHAR}, #{course.isFree,jdbcType=CHAR}, #{course.price,jdbcType=BIGINT}) &amp;lt;/insert&amp;gt;&amp;lt;/mapper&amp;gt; 关于 MySQL Type、jdbcType、Java Type 的对应关系请移步 MySQL、jdbcType、Java Type之间的映射关系写一个 service 调用这个 Mapperpackage org.oes.biz.service;import org.oes.biz.entity.Course;public interface CourseService { int createCourse(Course course);}package org.oes.biz.service.impl;import org.oes.biz.entity.Course;import org.oes.biz.mapper.CourseMapper;import org.oes.biz.service.CourseService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class CourseServiceImpl implements CourseService { @Resource private CourseMapper courseMapper; public int createCourse(Course course) { return courseMapper.insert(course); }}再写一个 Controller 调用这个 service 就可以启动项目来测试啦整合 DruidDruid官方文档 https://github.com/alibaba/druid/wiki引入依赖 &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; ... &amp;lt;!-- druid 数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;配置spring: application: name: oes # 项目名称 datasource: type: com.alibaba.druid.pool.DruidDataSource druid: # 数据库连接设置 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/oes_db?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=GMT%2b8 username: root password: 123456 # 连接池配置 max-active: 20 # 最大连接数 max-wait: 6000 # 最大等待时间 min-idle: 1 # 最少连接数 test-on-borrow: true test-on-return: true # 监控配置 filters: stat,wall # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙 aop-patterns: org.oes.biz.service.* #Spring监控配置，说明请参考Druid Github Wiki，配置_Druid和Spring关联监控配置 web-stat-filter: # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter enabled: true url-pattern: /* exclusions: /druid/*,*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico session-stat-enable: true session-stat-max-count: 10 principal-session-name: session_name principal-cookie-name: cookie_name profile-enable: stat-view-servlet: # 监控统计页面，配置_StatViewServlet配置默认false enabled: true url-pattern: /druid/* # 配置DruidStatViewServlet reset-enable: false # 禁用HTML页面上的“Reset All”功能 login-username: admin # 监控页面登录的用户名 login-password: 123456 # 监控页面登录的密码 allow: 127.0.0.1 #IP白名单(没有配置或者为空，则允许所有访问) deny: #IP黑名单 (存在共同时，deny优先于allow)此处的配置项较多，注释写的比较简单，具体可以参考官方给出的文档 alibaba/druid启动启动项目，控制台出现下图红框中的日志说明 Durid 配置成功如果你在 yml 中配置启用了 stat-view-servlet，就可以访问 http://localhost:8089/durid 进入监控页面了（需要输入你配置的账号密码）Mybatis 分页TODO" }, { "title": "OES之一：开始", "url": "/posts/1-Start/", "categories": "技术积累, Spring-OES", "tags": "Spring, SpringBoot", "date": "2021-12-01 20:51:26 +0800", "snippet": "写在开始此系列将以我独立开发的一个 SpringBoot 项目为基础，跟随我的开发过程，记录我在开发过程中的步骤及问题项目地址 https://github.com/BeiyanLuansheng/OES官方手册 Spring Guides官方Demo Spring Projects项目初始创建名为OES的空maven工程，新建四个子模块，使项目目录结构如下（子模块以oes-start为例）- OES ├── oes-biz [系统功能实现] ├── oes-common [通用工具类] ├── oes-start [启动类及网关] | ├── src [源文件] | | ├── main [工程主文件] | | | ├── java [代码] | | | | └── org.oes.start | | | | └── Application.java [启动类] | | | └── resources [资源文件] | | └── test [测试文件] | ├── target [编译文件, IDE运行时自动创建] | └── pom.xml └── pom.xml此时 OES 的 pom.xml 文件如下&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;org&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;OES&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;oes-biz&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;oes-common&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;oes-start&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt;&amp;lt;/project&amp;gt;SpringBoot 项目在 OES 的 pom.xml 文件中继承 SpringBoot &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.7&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; 你可以凭借缩进来判断加在了哪一个标签下再添加maven打包插件 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;在 oes-start 下的 pom.xml 中添加以下内容，以使用 SpringBoot 的基础功能 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;添加配置在 resources 目录下新建配置文件 application.yml application.yml 和 application.properties 可以二选一，效果等同，不过 YML 是树形结构，更直观如果两各文件同时存在，先加载 YML，后加载的 application.properties 会覆盖 YML 中的配置server: port: 8089 # tomcat端口号 servlet: context-path: / # 根路径 encoding: # 编码集设置 force: true charset: UTF-8 enabled: true tomcat: uri-encoding: UTF-8启动在 Application.java 中写import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&quot;org.oes&quot;)@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }}注意 @SpringBootApplication 注解仅会扫描当前包（即org.oes.start）下的所有 @Service 等注解为保证你写在 oes-biz 模块中的 @Service 或 @Component 也能被扫描到，需要手动添加注解 @ComponentScan，后面写上你要扫描的包路径，如果需要扫描多个包，写成 @ComponentScan({&quot;cn.a.b&quot;, &quot;com.c.d&quot;}) 的形式之后你可以在 oes-start 模块中写一个简单的 Controller，如package org.oes.start.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MainController { @GetMapping(&quot;/test&quot;) public String getStr() { return &quot;Hello, World&quot;; }}然后启动项目，访问在 application.yml 中配置好的端口号，如 http://localhost:8089/test" }, { "title": "诗词文", "url": "/posts/%E8%AF%97%E8%AF%8D%E6%96%87/", "categories": "文, 词", "tags": "诗词", "date": "2021-11-30 20:33:00 +0800", "snippet": "相见欢李煜无言独上西楼，月如钩。 寂寞梧桐深院锁清秋。剪不断，理还乱，是离愁。别是一般滋味在心头。" }, { "title": "6 物理层", "url": "/posts/6-PhysicalLayer/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-12 20:42:26 +0800", "snippet": "6.1 基础信源：将消息转换为信号的设备，如计算机等。发送设备：将信源产生的信号进行适当的变换装置，使之适合于在信道中传输。主要包括编码和调制。信道：信号传输通道，如物理介质。噪声：自然界和通信设备中所产生的干扰。接收设备：完成发送设备反变换，还原原始发送信号。信宿：信号终点，将信号转换为供人们能识别的消息。数据(data)：传送消息的实体。信号(signal)：数据的电气的或电磁的表示：$y(t)=A\\sin(\\omega t+\\theta)$“模拟的”(analogous)：参数的取值是连续的“数字的”(digital)：参数的取值是离散的码元(code)：信号基本波形（信号基本单元）频带(Spectrum)：信号频率范围带宽(Bandwidth)：有效带宽数据通信方式：单工、半双工、全双工并行通信 vs 串行通信 异步通信：将比特分成小组发送，小组可以是5-8位的一个字符，发送方可以在任何时刻发送这些比特组，而接收方不知道他们什么时候到达。传送数据时，加一个字符起始位和字符终止位。 同步通信：数据以一个区块为单位，传送数据时要先送出一个或多个同步字符，再送出数据。 信源产生的是模拟数据，为了在数字通信系统中传输，需要信源编码。典型的信源编码：PCM，PCM包括三个步骤： 采样：目的就是要用一系列在时间上离散的采样值，代替时间上连续的模拟数据，即实现时间上的离散化。 量化：就是使采样值在取值上离散化 编码：就是将量化后的采样值用一定位数的二进制数码来表示。如果量化级数为N，则每个采样值就编码成log~2~N位二进制码6.2 物理介质6.2.1 导引型传输介质 架空明线：易受天气和外界电磁干扰，对外界噪声敏感，带宽有限 双绞线：主要用于基带传输 屏蔽双绞线 STP (Shielded Twisted Pair) 非屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆：主要用于频带传输 光纤：基本原理是光的全反射，分为多模光纤和单模光纤两类6.2.2 非导引型传输介质 自由空间 无线电传播途径 不同频段具有不同传播特性 地波传播：频率较低（大约2 MHz以下）的电磁波趋于沿地球表面传播 有一定的绕射能力 在低频和甚低频段，地波传播距离可以超过数百米或数千公里 天波传播：电离层，距离地表约60~400km高度 频率较高（大约在2~30MHz之间）的电磁波会被电离层反射 电离层的密度和厚度随时间随机变化 电磁波可以传播10000km以上 随参信道 视线传播 频率高于30MHz的电磁波将穿透电离层，不会被反射回来 沿地面绕射能力也很弱 通常采用视线无障碍的点对点直线传播 可以设立地面中继站或卫星中继站进行接力传输 6.3 信道狭义信道：信号传输介质广义信道：包括信号传输介质和通信系统的一些变换装置，如发送设备、接收设备、天线、调制器等6.3.1 信道传输特性恒参信道传输特性 各种有线信道和部分无线信道，如微波视线传播链路和卫星链路等，都属于恒参信道 理想的恒参信道是一个理想的无失真传输信道 对信号幅值产生固定的衰减 对信号输出产生固定的时延 随参信道传输特性 许多无线信道都是随参信道 信号的传输衰减随时间随机变化 信号的传输时延随时间随机变化 存在多径传播现象 6.3.2 信道容量信道容量是指信道无差错传输信息的最大平均信息速率奈奎斯特(Nyquist)信道容量公式：理想无噪声信道的信道容量：$C=2B\\log_2M$ C为信道容量，单位为b/s（或bps）；B为信道带宽，单位为Hz；M为进制数，即信号状态数 是理想信道的极限容量香农(Shannon)信道容量公式：有噪声信道的信道容量：$C=B\\log_2(1+S/N)$ S/N为信噪比，即信号能量与噪声能量之比，但是S/N通常以分贝（dB）为单位描述，所以需要按如下公式转换成能量比：$(S/N){dB}=10\\log{10}(Signal Power/Noise Power)$6.4 基带传输信源发出的原始电信号是基带信号，基带信号往往包含有较多的低频成分，甚至有直流成分。 模拟信源→模拟基带信号 数字信源→数字基带信号 直接在信道中传送基带信号称为基带传输，实现基带传输的系统称为基带传输系统。在信道中直接传输数字基带信号，称为数字基带传输，相应的系统称为数字基带传输系统。基带信号比较适合在具有低通特性的有线信道中传输，通常不适合在无线信道中直接传输。信道的传输特性会引起波形失真，并会受噪声的影响，信道中的信号传播一定距离后，信号质量就会有所下降，甚至出现传输误码现象6.4.1 典型数字基带信号码型单极不归零码（Not Return to Zero-NRZ）：这种码型易于产生，但不适合长距离传输双极不归零码单极归零码（Return to Zero-RZ） 码元不为零的时间占一个码元周期的百分比称为占空比。 若码元不为零时间为Tb/2，码元周期为Tb，则该单极归零码的占空比为50%双极归零码差分码 (相对码)：相邻脉冲有电平跳变表示1，无跳变表示06.4.2 典型数字基带传输码型 对于直接传输信号码型来说，如果传输的一直是一个高(或低)电平的信号，信道容易产生直流分量的积累，对信道有害，而且接收方不易区分时钟AMI (Alternative Mark Inversion) 码：全称是信号交替反转码，编码规则： 信息码中的0编码为AMI传输码中的0（零电平） 信号码中的1交替编码为AMI传输码中的+1（正脉冲）和-1(负脉冲) AMI码便于在物理层检错：连续出现两个+1或两个-1，显然出错了双相码 (Biphase Code) 又称曼彻斯特（Manchester）码： 双相码只有正、负两种电平 每个比特持续时间的中间时刻要进行电平跳变 正（高）电平跳到负（低）电平表示1，负电平跳到正电平表示0 双相码在每个比特周期中间时刻都会有电平跳变，因此便于提取定时信息 双相码利用了两个脉冲编码信息码中的一个比特，相当于双极码中的两个比特 10Mbps的以太网采用曼彻斯特码差分双相码，双相码的另一种码型，也称为差分曼彻斯特码： 差分双相码的每个比特周期的中间时刻也要进行电平跳变，但该跳变仅用于同步 利用每个比特开始处是否存在电平跳变编码信息：开始处有跳变表示1，无跳变表示0 IEEE802.5令牌环网采用差分曼彻斯特码nBmB：nBmB码将n位二进制信息码作为一组，映射成m位二进制新码组，其中m&amp;gt;n 由于m&amp;gt;n，因此2m个码的新码组中只会用到2n个，多出（2^m^-2^n^）个码，所以可以从2^m^个码中优选出2^n^个码作为有效码，以获得良好的编码性能，其余码则作为禁用码，可以用于检错 快速以太网（100BASE-TX和100BASE-FX）传输码采用的是4B5B编码，这样只需从2^5^=32个码中优化选择2^4^=16个码，以便保证足够的同步信息，并且可以利用剩余的16个禁用码进行差错检测6.5 频带传输许多带通信道（如无线信道）不具有低通特性，因此不能在这些信道中直接传输基带信号，只能利用基带信号去调制与对应信道传输特性相匹配的载波信号，通过在信道中传送经过调制的载波信号实现将基带信号所携带信息传送出去。利用模拟基带信号调制载波，称为模拟调制，利用数字基带信号调制载波，称为数字调制，数字调制就是利用数字基带信号控制（或影响）载波信号的某些特征参量。频带传输系统通常选择正弦波信号作为载波：$y=a\\cos(2\\pi ft+\\varphi)$，对其做二进制数字调制：2ASK，2FSK，2PSK6.5.1二进制数字调制6.5.1.1 二进制幅移键控 (2ASK)利用二进制基带信号控制载波信号的幅值变化：$y’(t)=s(t)\\cos(2\\pi ft)$二进制基带信号s(t)为单极不归零码信号波形6.5.1.2 二进制频移键控 (2FSK)选择两个不同频率的载波，$f_1$ 和 $f_2$，二进制基带信号编码的信息（比特）序列为 ${b_n}$，$\\displaystyle y’(t)=\\begin{cases} \\cos(2\\pi f_1 t), &amp;amp;b_n=0\\ \\cos(2\\pi f_1 t), &amp;amp;b_n=1 \\end{cases}, 0&amp;lt;t&amp;lt;T$6.5.1.3 二进制相移键控 (2PSK)利用二进制基带信号控制载波信号的相位变化，二进制基带信号编码的信息（比特）序列为 ${b_n}$$y’(t)=\\cos(2\\pi ft+\\varphi(b_n))$，其中 $\\varphi(b_n)=\\begin{cases}\\varphi_0, &amp;amp;b_n=0\\ \\varphi_0+\\pi, &amp;amp;b_n=1\\end{cases}$载波信号初始相位φ~0~=-π/2 ：6.5.1.4 二进制差分相移键控（2DPSK）利用相邻两个码元载波间的相对相位变化表示数字基带信号的数字信息，二进制基带信号编码的信息（比特）序列为 ${b_n}$：$y’(t)=\\cos(2\\pi ft+\\varphi_{n-1}+\\Delta\\varphi(b_n))$，其中 $\\Delta\\varphi(b_n)=\\begin{cases}0, &amp;amp;b_n=0\\ \\pi, &amp;amp;b_n=1\\end{cases}$虚线为前一码元调制信号或初始参考载波信号：6.5.1.5 二进制数字调制性能频带利用率： 2ASK、2PSK以及2DPSK的频带利用率相同 2FSK的频带利用率最低误码率： 在相同信噪比下，2PSK的误码率最低，而2ASK的误码率最高 抗噪声性能：二进制相移键控 &amp;gt; 二进制频移键控 &amp;gt; 二进制幅移键控对信道特性的敏感性： 2ASK对信道特性变化比较敏感，性能最差 2FSK与2PSK对信道特性变化不敏感6.5.2 多进制数字调制：QAM在确定带宽与频带利用率的情况下，提高数据传输速率的有效方法：提高每个码元传输信息量，每个码元调制多个比特信息，即多进制数字调制数据传输速率 (比特率) R~b~（bps）与码元传输速率 (调制速率、波特率) R~B~（Baud）以及进制数M（通常为2的幂次）之间的关系为：$R_b=R_B\\log_2M$多进制数字调制需要更大的信噪比，发送端需要增大发送信号的功率。正交幅值调制（QAM）也称为幅值相位联合键控(APK)，具有高频带利用率，且可以自适应调整调制速率。QAM的调制信号的幅值和相位均受基带信号调制，可表示为：$y’(t)=A_n\\cos(2\\pi ft)+B_n\\sin(2\\pi ft)$，其中 $\\begin{cases}A_n=s_n \\cos\\varphi_n \\B_n= - s_n \\sin \\varphi_n\\end{cases}$QAM信号是由两路相互正交载波经调制后叠加而成，两路载波信号的幅值分别被离散幅值序列 ${An}$ 和 ${Bn}$ 所调制，分别称为同相信号（I信号）和正交信号（Q信号）QAM已调信号的矢量端点在I-Q平面上的分布，称为QAM星座图QAM优点：频带利用率高；抗噪声能力强；调制解调系统简单6.6 物理层接口规程物理层接口特性 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。" }, { "title": "5 数据链路层", "url": "/posts/5-DataLinkLayer/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-11 22:09:24 +0800", "snippet": "5.1 数据链路层服务 主机和路由器：结点(nodes) 连接相邻结点的通信信道：链路(links)，有线链路(wired links)、无线链路(wireless links)、局域网(LANs) 链路层(第2层)数据分组：帧(frame)，封装网络层数据报数据链路层负责通过一条链路从一个节点向另一个物理链路直接相连的相邻结点传送数据报。组帧(framing)：封装数据报构成数据帧，加首部和尾部。完成帧同步：通过在首部和尾部加入特定的比特串。链路接入(link access)：如果是共享介质，需要解决信道接入(channel access)。帧首部中的“MAC”地址，用于标识帧的源和目的，不同于IP地址！相邻结点间可靠交付：在低误码率的有线链路上很少采用 (如光纤，某些双绞线等)。无线链路：误码率高，需要可靠交付流量控制(flow control)：协调(pacing)相邻的发送结点和接收差错检测(error detection)：信号衰减和噪声会引起差错。接收端检测到差错：通知发送端重传或者直接丢弃帧差错纠正(error correction)：接收端直接纠正比特差错全双工和半双工通信控制 全双工：链路两端结点同时双向传输 半双工：链路两端结点交替双向传输 5.2 差错编码差错编码基本原理：D→DR，其中R为差错检测与纠正比特（冗余比特）。即加入了冗余信息，使得原本不存在的比特位建立联系。 分组码：多见于计算机网络 线性分组码：R建立起的D之间的关系是线性的。此类多见 非线性分组码：R建立起的D之间的关系是非线性的。 卷积码：应用于通信领域 差错编码不能保证100%可靠5.2.1 差错编码的检错能力差错编码可分为检错码与纠错码 对于检错码，如果编码集的汉明距离d~s~=r+1，则该差错编码可以检测r位的差错 对于纠错码，如果编码集的汉明距离d~s~=2r+1，则该差错编码可以纠正r位的差错 奇偶校验码 1比特校验位：检测奇数位差错 二维奇偶校验：检测奇数位差错、部分偶数位差错；纠正同一行/列的奇数位错 Internet校验和(Checksum) 发送端：将“数据”(校验内容)划分为16位的二进制“整数”序列，求和(sum)：补码求和(最高位进位的“1”，返回最低位继续加）。校验和(Checksum)：sum的反码。放入分组(UDP、TCP、IP)的校验和字段。 接收端：与发送端相同算法计算。计算得到的”checksum”：为16位全0（或sum为16位全1）则无错，否则有错 5.2.2 循环冗余校验码(CRC)检错能力更强大的差错编码将数据比特，D，视为一个二进制数，选择一个r+1位的比特模式 (生成比特模式)，G。目标：选择r位的CRC比特，R，满足： &amp;lt;D,R&amp;gt;刚好可以被G整除(模2) 接收端检错：利用G除&amp;lt;D,R&amp;gt;，余式全0，无错；否则，有错！ 可以检测所有突发长度小于r+1位差错。 广泛应用于实际网络 (以太网，802.11 WiFi，ATM)期望：D * 2^r^ XOR R = nG相当于：D * 2^r^ = nG XOR R相当于：如果利用G去除D*2r, 则余式即为R=余式[D * 2^r^ / G]5.3 多路访问控制(MAC)协议5.3.1 MAC协议两类“链路”： 点对点链路 拨号接入的PPP 以太网交换机与主机间的点对点链路 **广播链路 **(共享介质) 早期的总线以太网 HFC的上行链路 802.11无线局域网 单一共享广播信道，两个或者两个以上结点同时传输：干扰(interference)冲突(collision)：结点同时接收到两个或者多个信号→接收失败！多路访问控制协议(multiple access control protocol)：采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据；必须基于信道本身，通信信道共享协调信息；无带外信道用于协调5.3.1.1 理想MAC协议给定：速率为R bps的广播信道，期望： 当只有一个结点希望传输数据时，它可以以速率 R发送. 当有M个结点期望发送数据时，每个节点平均发送数据的平均速率是R/M 完全分散控制：无需特定结点协调；无需时钟、时隙同步 简单5.3.1.2 MAC协议分类 信道划分(channel partitioning)MAC协议 多路复用技术 TDMA、FDMA、CDMA、WDMA等 随机访问(random access)MAC协议 信道不划分，允许冲突 采用冲突“恢复”机制 ALOHA, S-ALOHA, CSMA, CSMA/CD CSMA/CD应用于以太网；CSMA/CA应用802.11无线局域网 轮转(“taking turns”)MAC协议 结点轮流使用信道 主结点轮询；令牌传递 蓝牙、FDDI、令牌环网 5.3.2 信道划分MAC协议5.3.2.1 TDMATDMA: time division multiple access “周期性”接入信道 每个站点在每个周期，占用固定长度的时隙(e.g.长度=分组传输时间) 未用时隙空闲(idle) 例如：6-站点LAN，1,3,4传输分组，2,5,6空闲5.3.2.2 FDMAFDMA: frequency division multiple access 信道频谱划分为若干频带(frequency bands) 每个站点分配一个固定的频带 无传输频带空闲例如：6站点LAN, 1,3,4频带传输数据, 2,5,6频带空闲。5.3.3 随机访问MAC协议当结点要发送分组时：利用信道全部数据速率R发送分组，由于没有事先的结点间协调，所以存在两个或多个结点同时传输导致冲突。随机访问MAC协议需要定义：如何检测冲突；如何从冲突中恢复 (e.g., 通过延迟重传) 典型的随机访问MAC协议：时隙(sloted)ALOHA、ALOHA、CSMA、CSMA/CD、CSMA/CA5.3.3.1 时隙ALOHA协议假定： 所有帧大小相同 时间被划分为等长的时隙（每个时隙可以传输1个帧） 结点只能在时隙开始时刻发送帧 结点间时钟同步 如果2个或2个以上结点在同一时隙发送帧，结点即检测到冲突运行：当结点有新的帧时，在下一个时隙(slot)发送 如果无冲突：该结点可以在下一个时隙继续发送新的帧 如果冲突：该结点在下一个时隙以概率p重传该帧，直至成功优点: 单个结点活动时，可以连续以信道全部速率传输数据 高度分散化：只需同步时隙 简单缺点: 容易冲突，浪费时隙 空闲时隙 结点也许能以远小于分组传输时间检测到冲突 时钟同步 效率(efficiency)：长期运行时，成功发送帧的时隙所占比例 (很多结点，有很多帧待发送)假设N个结点有很多帧待传输，每个结点在每个时隙均以概率p发送数据对于给定的一个结点，在一个时隙将帧发送成功的概率= p(1-p)^N-1^对于任意结点成功发送帧的概率= Np(1-p)^N-1^最大效率：求得使Np(1-p)^N-1^最大的p*对于很多结点，求Np*(1-p*)^N-1^当N趋近无穷时的极限，可得：最大效率= 1/e = 0.37。即最好情况下信道被成功利用的时间仅占37%5.3.3.2 ALOHA协议非时隙(纯)Aloha：更加简单，无需同步当有新的帧生成时立即发送，这也导致冲突可能性增大：在t~0~时刻发送帧，会与在 (t~0~-1, t~0~+1) 期间其他结点发送的帧冲突。效率：P(给定结点成功发送帧) = P(该结点发送) * P(无其他结点在[t~0~-1, t~0~]期间发送帧) * P(无其他结点在[t~0~, t~0~+1]期间发送帧)= p * (1-p)^N-1^ * (1-p)^N-1^ = p . (1-p)^2(N-1)^ 选取最优的p，并令n→∞= 1/(2e) = 0.18 比时隙ALOHA协议更差5.3.3.3 CSMA协议载波监听多路访问协议CSMA (carrier sense multiple access)：发送帧之前，监听信道(载波)：信道空闲时发送完整帧；信道忙时推迟发送： 1-坚持CSMA：持续监听信道，一旦发现空闲即发送数据。 非坚持CSMA：随机等待一段时间后再监听信道 P-坚持CSMA：以概率P持续监听信道，以概率1-P随机等待一段时间后再监听信道 但由于信号传播延迟，冲突可能仍然发生。如果两个结点同时监听到空闲然后同时发送数据，同样会发生冲突。5.3.3.4 CSMA/CD协议CSMA/CD (CSMA with Collision Detection)：短时间内可以检测到冲突，冲突后传输中止，减少信道浪费。冲突检测: 有线局域网易于实现：测量信号强度，比较发射信号与接收信号 无线局域网很难实现：接收信号强度淹没在本地发射信号强度下 “边发边听，不发不听”条件：网络带宽：R bps，数据帧最小长度：Lmin (bits)，信号传播速度：V (m/s)下，需满足：L / R ≥ 2d~max~ / V L~min~ / R = 2d~max~ / V 由于实际存在中继，可能存在其他延迟：L~min~ / R = RTT~max~ 效率：$\\displaystyle\\frac 1 {1+5t_{prop} / t_{trans}}$t~prop~ = LAN中2个结点间的最大传播延迟t~trans~ = 最长帧传输延迟 t~prop~ 趋近于0或者t~trans~ 趋近于∞时，效率趋近于1，远优于ALOHA，并且简单、分散！5.3.4 轮转访问MAC协议信道划分MAC协议： 网络负载重时，共享信道效率高，且公平 网络负载轻时，共享信道效率低 随机访问MAC协议： 网络负载轻时，共享信道效率高，单个结点可以利用信道的全部带宽 网络负载重时，产生冲突开销 轮转访问MAC协议： 综合两者的优点，两种举例： 轮询(polling)：主结点轮流“邀请”从属结点发送数据。典型应用：“哑(dumb)” 从属设备 问题：轮询开销；等待延迟；单点故障 令牌传递(token passing)：控制令牌依次从一个结点传递到下一个结点.。令牌：特殊帧 问题：令牌开销；等待延迟；单点故障 5.4 ARP协议 32位IP地址：接口的网络层地址，用于标识网络层(第3层)分组，支持分组转发。IP地址是层次地址：不可“携带”，IP地址依赖于结点连接到哪个子网 MAC地址(或称LAN地址,物理地址,以太网地址)：用于局域网内标识一个帧从哪个接口发出，到达哪个物理相连的其他接口。48位MAC地址(用于大部分LANs)，固化在网卡的ROM中，有时也可以软件设置。e.g.：1A-2F-BB-76-09-AD。局域网中的每块网卡都有一个唯一的MAC地址。MAC地址由IEEE统一管理与分配，网卡生产商购买MAC地址空间(前24比特)。MAC地址是“平面”地址：可“携带”，可以从一个LAN移到另一个LAN 类比：MAC地址：身份证号；IP地址：邮政地址ARP：地址解析协议。解决在同一个LAN内已知目的接口的IP地址前提下确定其MAC地址问题。ARP表：LAN中的每个IP结点(主机、路由器)维护一个表，存储某些LAN结点的IP/MAC地址映射关系：&amp;lt; IP地址; MAC地址; TTL&amp;gt;。经过TTL (Time To Live)时间以后该映射关系会被遗弃(典型值为20min)。A想要给同一局域网内的B发送数据报，但B的MAC地址不在A的ARP表中，所以： A广播ARP查询分组，其中包含B的IP地址，目的MAC地址 = FF-FF-FF-FF-FF-FF。 LAN中所有结点都会接收ARP查询，B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC 地址，利用单播帧向A发送应答。 A在其ARP表中，缓存B的IP-MAC地址对，直至超时。超时后，再次刷新。ARP是“即插即用”协议，结点自主创建ARP表，无需干预。A通过路由器R向B发送数据报：假设A知道B的IP地址，A知道第一跳路由器R (左)接口IP地址 (默认网关)，A知道第一跳路由器R (左)接口MAC地址 (ARP协议)。 A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址。 A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址是R(左)接口的MAC地址，封装A到B的IP数据报。 帧从A发送至R，R接收帧，提取IP数据报，传递给上层IP协议。 R转发IP数据报（源和目的IP地址不变）R创建链路层帧，其中源MAC地址是R(右)接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报。5.5 以太网5.5.1 以太网(ETHERNET)物理拓扑 总线(bus)：所有结点在同一冲突域(collision domain) (可能彼此冲突) 星型(star)：中心交换机(switch)，每个结点一个单独冲突域(结点间彼此不冲突) 以太网：不可靠、无连接服务无连接(connectionless)：发送帧的网卡与接收帧的网卡间没有“握手”过程。不可靠(unreliable)：接收网卡不向发送网卡进行确认。差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议 (e.g., TCP)，否则，发生数据丢失。以太网的MAC协议：采用二进制指数退避算法的CSMA/CD 二进制指数退避算法用于计算随机等待的时间5.5.1.1 以太网CSMA/CD算法 NIC从网络层接收数据报，创建数据帧。 监听信道：如果NIC监听到信道空闲，则开始发送帧；如果NIC监听到信道忙，则一直等待到信道空闲，然后发送帧。 NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功！ 如果NIC检测到其他结点传输数据，则中止发送，并发送堵塞信号 (jam signal) 中止发送后，NIC进入二进制指数退避：第m次连续冲突后：取n = Min(m, 10)，NIC 从{0,1,2, …, 2^n^-1}中随机选择一个数K，NIC等待K·512比特的传输延迟时间，再返回第2步。 连续冲突次数越多，平均等待时间越长。 一般情况下，连续16次冲突后就不在发送，向上层报告错误。 5.5.1.2 以太网帧结构发送端网卡将IP数据报(或其他网络层协议分组)封装到以太网帧中： 前导码(Preamble)(8B)：用于发送端与接收端的时钟同步。7个字节的10101010，第8字节为10101011。一般情况下，我们所说的以太网帧长度不包含前导码的长度。 目的MAC地址、源MAC地址(各6B)： 如果网卡的MAC地址与收到的帧的目的MAC地址匹配，或者帧的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。否则，网卡丢弃(不接收)该帧。 类型(Type)(2B)：指示帧中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等) 数据(Data)(46-1500B)：指上层协议载荷。 R=10Mbps，RTT~max~=512μs，L~min~ / R = RTT~max~ L~min~=512bits=64B，Data~min~=L~min~-18=46B CRC(4B)：循环冗余校验码，丢弃差错帧5.5.2 交换机链路层设备 主机利用独享(dedicated)链路直接连接交换机 存储-转发以太网帧，交换机缓存帧 检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧 交换机在每段链路上利用CSMA/CD收发帧，但无冲突，且可以全双工。每段链路一个独立的冲突域。透明(transparent)：主机感知不到交换机的存在即插即用(plug-and-play)交换(switching)：A-A’与B-B’的传输可以同时进行，没有冲突每个交换机有一个交换表(switch table)，每个入口(entry)：(主机的MAC地址，到达主机的接口，时间戳)交换机通过自学习(self-learning)，获知到达主机的接口信息，无需配置。当收到帧时，交换机“学习”到发送帧的主机（通过帧的源MAC地址），位于收到该帧的接口所连接的LAN网段，将发送主机MAC地址/接口信息记录到交换表中。5.5.2.1 帧过滤/转发当交换机收到帧: 记录帧的源MAC地址与输入链路接口（自学习） 利用目的MAC地址检索交换表 if 在交换表中检索到与目的MAC地址匹配的入口(entry) then {if 目的主机位于收到帧的网段（源和目的主机连在交换机的同一个接口上） then 丢弃帧else 将帧转发到该入口指向的接口}else 泛洪(flood) /* 向除收到该帧的接口之外的所有接口转发 */5.5.2.2 交换机 vs. 路由器均为存储-转发设备： 路由器：网络层设备 (检测网络层分组首部) 交换机：链路层设备 (检测链路层帧的首部) 均使用转发表： 路由器：利用路由算法(路由协议)计算(设置)，依据IP地址 交换机：利用自学习、泛洪构建转发表，依据MAC地址 5.5.3 虚拟局域网(VLAN)虚拟局域网(Virtual Local Area Network)：支持VLAN划分的交换机，可以在一个物理LAN架构上配置、定义多个VLAN基于端口的VLAN：分组交换机端口 (通过交换机管理软件)，于是，单一的物理交换机就像多个虚拟交换机一样运行。 流量隔离(traffic isolation)：去往/来自端口1-8的帧只到达端口1-8，同理，也可以基于MAC地址定义VLAN，而不是交换端口 动态成员：端口可以动态分配给不同VLAN 在VLAN间转发：通过路由(就像在独立的交换机之间)。而实践中，厂家会将交换机与路由器集成在一起 跨越多交换机的VLAN，可以使用多线缆连接，每个线缆连接一个VLAN，但显然每个交换机都会浪费一个端口。中继端口(trunk port)：在跨越多个物理交换机定义的VLAN承载帧。为多VLAN转发802.1帧容易产生歧义，所以必须携带VLAN ID信息，802.1q协议为经过中继端口转发的帧增加/去除额外的首部域5.5 PPP协议点对点数据链路控制：一个发送端，一个接收端，一条链路。比广播链路容易：无需介质访问控制(Media Access Control)；无需明确的MAC寻址。e.g., 拨号链路，ISDN链路常见的点对点数据链路控制协议： HDLC (High Level Data Link Control) PPP (Point-to-Point Protocol)5.5.1 PPP设计需求 组帧：将网络层数据报封装到数据链路层帧中。可以同时承载任何网络层协议分组(不仅IP数据报)；可以向上层实现分用（多路分解）。 比特透明传输：数据域必须支持承载任何比特模式 差错检测：(无纠正) 连接活性(connection liveness)检测：检测、并向网络层通知链路失效 网络层地址协商：端结点可以学习/配置彼此网络地址 无需支持的功能：无需差错纠正/恢复；无需流量控制；不存在乱序交付；无需支持多点链路。差错恢复、流量控制等由高层协议处理。5.5.2 PPP数据帧 标志(Flag)：定界符(delimiter) 地址(Address)：无效(仅仅是一个选项)，目前全部取1 控制(Control)：无效；未来可能的多种控制域 协议(Protocol)：上层协议 (eg, PPP-LCP, IP, IPCP, etc) 信息(info)：上层协议分组数据 校验(check)：CRC校验，用于差错检测 通过协商，可以省略地址字段和控制字段等字节，一个PPP数据帧最多可以节省5个字节的长度：地址字段1字节、控制字段1字节、协议字段1字节、校验字段2个字节。5.5.3 字节填充数据透明传输要求数据域必须允许包含标志模式&amp;lt;01111110&amp;gt;发送端：在数据中的&amp;lt;01111110&amp;gt;和&amp;lt;01111101&amp;gt;字节前添加额外的字节&amp;lt;01111101&amp;gt; (“填充(stuffs)”)接收端： 单个字节&amp;lt;01111101&amp;gt;表示一个填充字节； 连续两个字节&amp;lt;01111101&amp;gt;：丢弃第1个，第2个作为数据接收； 单个字节&amp;lt;01111110&amp;gt;：标志字节 综上，字节&amp;lt;01111101&amp;gt;相当于转义符，如果在数据域中出现了标志字节&amp;lt;01111110&amp;gt;或者转义符自身，就需要在原字节之前加一个转义符，将它转成原本的含义，而非特殊含义“标志”或“转义”。在交换网络层数据之前，PPP数据链路两端必须： 配置PPP链路：最大帧长；身份认证(authentication)；协商配置各个可变字段的长度；etc. 学习/配置网络层信息：对于IP协议，通过交换IPCP协议 (IP Control Protocol )报文 (IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置 " }, { "title": "4 网络层", "url": "/posts/4-NetworkLayer/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-10 22:55:52 +0800", "snippet": "4.1 网络层服务网络层：从发送主机向接收主机传送数据段（segment），发送主机将数据段封装到数据报（datagram）中；接收主机向传输层交付数据段（segment）。每个主机和路由器都运行网络层协议（非端到端的），路由器检验所有穿越它的IP数据报的头部域，以决策如何处理IP数据报。网络层核心功能：转发与路由 转发(forwarding)：将分组从路由器的输入端口转移到合适的输出端口 转发表确定在本路由器如何转发分组 路由(routing)：确定分组从源到目的经过的路径 路由算法(协议)（routing algorithms）确定通过网络的端到端路径 某些网络（如ATM, 帧中继, X.25）的重要功能：连接建立——数据分组传输之前两端主机需要首先建立虚拟/逻辑连接。网络设备（如路由器）参与连接的建立。 网络层连接与传输层连接的对比： 网络层连接：两个主机之间 (路径上的路由器等网络设备参与其中) 传输层连接：两个应用进程之间（对中间网络设备透明） 无连接服务(connection-less service)：如数据报网络(datagram network) 不事先为系列分组的传输确定传输路径 每个分组独立确定传输路径 不同分组可能传输路径不同 连接服务(connection service)：如虚电路网络(virtual-circuit network) 首先为系列分组的传输确定从源到目的经过的路径 (建立连接) 然后沿该路径（连接）传输系列分组，系列分组传输路径相同 传输结束后拆除连接 数据报网络与虚电路网络是典型两类分组交换网络 类似于传输层的无连接服务（UDP）和面向连接服务（TCP），但是网络层服务既有主机到主机的服务，也有网络核心的实现4.2 虚电路网络虚电路：一条从源主机到目的主机，类似于电路的路径(逻辑连接) 分组交换 每个分组的传输利用链路的全部带宽（实际的电路交换利用的是链路的部分资源，频率或时隙等） 源到目的路径经过的网络层设备共同完成虚电路功能 通信过程：呼叫建立(call setup)→数据传输→拆除呼叫 1.初始呼叫 –&amp;gt; 2. 呼叫到达 –&amp;gt; 3.接受呼叫 –&amp;gt; 4.呼叫建立 –&amp;gt; 5.数据流开始 –&amp;gt; 6.接收数据每条虚电路包括： 从源主机到目的主机的一条路径 虚电路号 (VCID)， 沿路每段链路一个编号 沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路 沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址。因为同一条VC ，在每段链路上的VCID通常不同。路由器转发分组时依据转发表改写/替换虚电路号。 虚电路经过的每个网络设备（如路由器），维护每条经过它的虚电路连接状态链路、网络设备资源(如带宽、缓存等)可以面向VC进行预分配虚电路信令协议(signaling protocols)：用于VC的建立、维护与拆除 (路径选择)；应用于虚电路网络，如ATM、帧中继 (frame-relay) 网络等；目前的Internet不采用4.3 数据报网络数据报网络是网络层无连接的，所以每个分组携带目的地址，路由器根据分组的目的地址转发分组。路由器基于路由协议/算法构建转发表，检索转发表转发数据报，而转发表更新导致了每个分组独立选路。转发表确定在本路由器如何转发分组，所以对于Internet网络来说，路由器就需要保存40多亿IP地址，显然检索效率会大大降低，所以它维护的是一个地址范围(聚合转发表入口)。如： 目的地址范围 链路接口 从11001000 00010111 00010000 00000000至11001000 00010111 00010111 11111111 0 从11001000 00010111 00011000 00000000至11001000 00010111 00011011 11111111 1 从11001000 00010111 00011100 00000000至11001000 00010111 00011111 11111111 2 其他（默认路由，默认路径） 3 最长前缀匹配优先：在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口（entry）。数据报网络与VC网络对比： Internet (数据报网络) ATM (VC网络) 链路类型众多，特点、性能各异，统一服务困难 电话网络演化而来 计算机之间的数据交换：“弹性”服务，没有严格时间需求 核心业务是实时对话：严格的时间、可靠性需求，需要有保障的服务 “智能”端系统 (计算机)可以自适应、性能控制、差错恢复 “哑(dumb)” 端系统（非智能）电话机、传真机 简化网络，复杂“边缘” 简化“边缘”，复杂网络 4.4 IP协议Internet网络层主机、路由器网络层主要功能： 路由协议进行路径选择，生成路由表 IP协议做出了寻址规约(conventions)，定义了数据报(分组)格式以及分组处理规约 ICMP(互联网控制报文)协议提供差错报告、路由器“信令” ICMP协议相当于IP协议的伴随协议，实现IP协议的同时一般也要实现ICMP协议4.4.1 IP数据报&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;0&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;4&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;8&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;12&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;16&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;24&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td&amp;gt;31&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;4&quot;&amp;gt;&amp;lt;b&amp;gt;版本号&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;4→IPv4&amp;lt;br/&amp;gt;6 → IPv6&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;4&quot;&amp;gt;&amp;lt;b&amp;gt;首部长度&amp;lt;/b&amp;gt;：IP分组首部长度，以4字节为单位&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;服务类型(TOS)&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;指示期望获得哪种类型的服务，只有在网络提供区分服务时使用，一般情况下不使用，Internet不提供区分服务，所以通常IP分组里该值为00H&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;16&quot;&amp;gt;&amp;lt;b&amp;gt;总长度&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;IP分组的总字节数(首部+数据)&amp;lt;br/&amp;gt;最大65535B，最小20B&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;16&quot; rowspan=&quot;2&quot;&amp;gt;&amp;lt;b&amp;gt;标识&amp;lt;/b&amp;gt;：IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;3&quot;&amp;gt;&amp;lt;b&amp;gt;标志位&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;DF(Don&#39;tFragment)为1禁止分片；为0允许分片;&amp;lt;br/&amp;gt;MF(MoreFragment)为1非最后一片；为0最后一片(或未分片)&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;12&quot; rowspan=&quot;2&quot;&amp;gt;&amp;lt;b&amp;gt;片偏移&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;一个IP分组分片封装原IP分组数据的相对偏移量，片偏移字段以8字节为单位&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;保留&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;DF&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;MF&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;生存时间(TTL)&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;IP分组在网络中可以通过的路由器数(跳步数)，路由器转发一次分组，TTL减1；如果TTL=0，路由器则丢弃该IP分组并向源主机发送一个ICMP数据包&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;协议&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;指示IP分组封装的是哪个协议的数据包，它实现复用/分解&amp;lt;br/&amp;gt;6为TCP，表示封装的为TCP段；17为UDP，表示封装的是UDP数据报&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;16&quot;&amp;gt;&amp;lt;b&amp;gt;首部检验和&amp;lt;/b&amp;gt;：&amp;lt;br/&amp;gt;实现对IP分组首部的差错检测。计算校验和时，该字段置全0；采用反码算数运算求和，和的反码作为首部校验和字段；逐跳计算、逐跳校验&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;&amp;lt;b&amp;gt;源IP地址&amp;lt;/b&amp;gt;：标识发送分组的源主机/路由器(网络接口)的IP地址&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;&amp;lt;b&amp;gt;目的IP地址&amp;lt;/b&amp;gt;：标识接收分组的目的主机/路由器(网络接口)的IP地址&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;24&quot;&amp;gt;&amp;lt;b&amp;gt;选项字段&amp;lt;/b&amp;gt;：长度可变，范围在1~40B之间：携带安全、源选路径、时间戳和路由记录等内容，但实际上很少被使用&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;填充&amp;lt;/b&amp;gt;：范围在0~3B之间：补齐整个首部，符合32位对齐，即保证首部长度是4字节的倍数&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;数据&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;4.4.2 IP分片最大传输单元(MTU)：链路层数据帧可封装数据的上限。不同链路的MTU不同，所以就导致一个分组在一条链路上可以传输，但在下一条链路上传输可能需要被拆分。 1个IP分组分为多片IP分组，IP分片到达目的主机后进“重组”(reassembled) IP首部的相关字段用于标识分片以及确定分片的相对顺序：总长度、标识、标志位和片偏移分片过程：假设原IP分组总长度为L，待转发链路的MTU为M。若L&amp;gt;M，且DF=0，则可以/需要分片。通常分片时，每个分片的标识复制原IP分组的标识，除最后一个分片，其他分片均分为MTU允许的最大分片。一个最大分片可封装的数据应该是8的倍数，因此，一个最大分片可封装的数据为：$\\displaystyle d=\\lfloor\\frac {M-20} 8\\rfloor\\times 8$需要的总片数为：$\\displaystyle n=\\lceil\\frac {L-20} d \\rceil$每片的片偏移字段取值为：$\\displaystyle F_i=\\frac d 8 \\times (i-1),\\; 1\\le i\\le n$每片的总长度字段为：$L_i=\\begin{cases} d+20 &amp;amp; 1\\le i\\le n \\\\ L-(n-1)d &amp;amp; i=n \\end{cases}$每片的MF标志位为：$MF_i=\\begin{cases}1&amp;amp;1\\le i\\lt n \\\\ 0 &amp;amp; i=n\\end{cases}$4.4.3 IP编址接口(interface)：主机/路由器与物理链路的连接。它实现网络层功能。IP地址：32比特(IPv4)编号标识主机、路由器的接口。IP地址与每个接口关联，由于一个主机通常只有一个接口，所以通常也叫主机地址而不是接口地址。 路由器通常有多个接口，而主机通常只有一个或两个接口 (e.g.，有线的以太网接口，无线的802.11接口)将IP地址的高位比特称为网络号(NetID)，低位比特称为**主机号(HostID) **。IP子网：IP地址具有相同网络号的设备接口，不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口。4.4.4 有类IP地址“有类”编址： A类地址 (50%)：NetID(8位) HostID(24位)，最高位为0 0.0.0.0~127.255.255.255 B类地址 (25%)：NetID(16位) HostID(16位)，最高两位为10 128.0.0.0~191.255.255.255 C类地址 (12.5%)：NetID(24位) HostID(8位)，最高三位为110 192.0.0.0~223.255.255.255 D类地址 (6.25%)：32位HostID，最高四位为1110 224.0.0.0~239.255.255.255 E类地址 (6.25%)：32位HostID，最高四位为1111 240.0.0.0~255.255.255.255 D类地址不再区分网络号和主机号，用于标识互联网中的一组主机，这些主机理论上可以分布在互联网的每个地方。只能作为目的地址，称为多播地址。 E类地址保留，作为研究使用。4.4.4.1 特殊IP地址 NetID HostID 作为IP分组源地址 作为IP分组目的地址 用途 全0 全0 可以 不可以 在本网范围内表示本机；在路由表中用于表示默认路由(相当于表示整个Internet网络) 全0 特定值 不可以 可以 表示本网内某个特定主机 全1 全1 不可以 可以 本网广播地址(路由器不转发) 特定值 全0 不可以 可以 网络地址，表示一个网络 特定值 全1 不可以 可以 直接广播地址，对特定网络上的所有主机进行广播 127 非全0或非全1的任何数 可以 可以 用于本地软件环回测试，称为环回地址 4.4.4.2 私有IP地址 Class NetID Blocks A 10 1 B 172.16 到 172.31 16 C 192.168.0 到 192.168.255 256 4.4.5 IP子网划分与子网掩码子网划分：ABC类IP子网还是过大，继续划分一个IP子网为更小范围网络。IP地址：高位比特为网络号(NetID) ；原网络主机号部分高位比特为子网号(SubID)；低位比特为主机号(HostID)。子网掩码：形如IP地址，也是32位，写成点分十进制形式。取值：NetID、SubID位全取1，HostID位全取0 A网的默认子网掩码为：255.0.0.0 B网的默认子网掩码为：255.255.0.0 C网的默认子网掩码为：255.255.255.0 借用3比特划分子网的B网的子网掩码为：255.255.224.0 利用子网地址+子网掩码准确确定子网大小，将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址。 例：目的IP地址：172.32.1.112，子网掩码：255.255.254.0 172.32.1.112 = 10101100 00100000 00000001 01110000 255.255.254.0= 11111111 11111111 11111110 00000000 位与运算：10101100 00100000 00000000 00000000 = 172.32.0.0 子网地址：172.32.0.0(子网掩码：255.255.254.0) 地址范围：172.32.0.0~172.32.1.255 可分配地址范围：172.32.0.1~172.32.1.254 广播地址：172.32.1.255 子网的划分会导致一些损失，因为使得每个子网的开头(子网地址)和末尾(广播地址)的地址不能分配给路由器或主机使用，但带来了性能的提升。4.4.6 CIDR与路由聚集无类域间路由(CIDR：Classless InterDomain Routing)： 消除传统的 A 类、B 类和 C 类地址界限：NetID+SubID→Network Prefix (Prefix)可以任意长度。 融合子网地址与子网掩码，方便子网划分：无类地址格式：a.b.c.d/x，其中x为前缀长度 例如：子网201.2.3.64，255.255.255.192 → 201.2.3 .64/26 提高IPv4 地址空间分配效率 提高路由效率： 将多个子网聚合为一个较大的子网，构造超网(supernetting)；路由聚合(route aggregation)选用更具体的路由：最长前缀匹配优先！路由聚合以后，如果聚合后的子网缺少了一部分，则在路由器的路由表中一定会有多条路由表项，于是在路由的时候就需要最长前缀匹配优先。4.5 DHCP协议动态主机配置协议(DHCP：Dynamic Host Configuration Protocol)： 从服务器动态获取：IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址 “即插即用” 允许地址重用 支持在用地址续租 支持移动用户加入网络 DHCP工作过程： 主机广播“DHCP discover”(发现报文) DHCP服务器利用“DHCP offer” (提供报文) 进行响应 主机请求IP地址：“DHCP request” (请求报文) DHCP服务器分配IP地址：“DHCP ack” (确认报文)DHCP协议在应用层实现：请求报文封装到UDP数据报中 –&amp;gt; IP广播 –&amp;gt; 链路层广播(e.g. 以太网广播)DHCP服务器构造ACK报文：包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址4.6 NAT设计动机： 只需从ISP申请一个IP地址：由于IPv4地址耗尽 本地网络设备IP地址的变更，无需通告外界网络 变更ISP时，无需修改内部网络设备IP地址 内部网络设备对外界网络不可见，即不可直接寻址(安全)实现： 替换：利用(NAT IP地址,新端口号)替换每个外出IP数据报的(源IP地址,源端口号) 记录：将每对(NAT IP地址, 新端口号)与(源IP地址, 源端口号)的替换信息存储到NAT转换表中 替换：根据NAT转换表，利用(源IP地址, 源端口号)替换每个进入内网IP数据报的(目的IP地址,目的端口号)，即(NAT IP地址, 新端口号)NAT存在的争议： 路由器应该只处理第3层功能，但NAT更改了第四层的数据。 违背端到端通信原则：传输层是端到端的，即对第三层设备路由器等应该是透明的，应用开发者必须考虑到NAT的存在，e.g., P2P应用 地址短缺问题应该由IPv6来解决NAT穿透的解决方案： 静态配置NAT，将特定端口的连接请求转发给服务器。 例如(138.76.29.7, 2500)总是转发给(10.0.0.1, 25000) 利用UPnP(Universal Plug and Play)互联网网关设备协议 (IGD-Internet Gateway Device )自动配置。 学习到NAT公共IP地址(138.76.29.7)，然后在NAT转换表中，(自动)增删端口映射 中继(如Skype)。NAT内部的客户与中继服务器建立连接；外部客户也与中继服务器建立连接；中继服务器桥接两个连接的分组。4.7 ICMP互联网控制报文协议 ICMP (Internet Control Message Protocol)支持主机或路由器完成差错(或异常)报告和网络探询。4.7.1 ICMP报文 差错报告报文 (5种) 目的不可达：无法到达目的或已到达但无法交付给目的 源抑制(Source Quench)：用于网络层的拥塞控制，路由器发现缓存已满时构造此类报文发给源主机，但目前的Internet中并无此类拥塞控制 超时/超期：TTL超时后，路由器丢弃报文并构造此类报文发给源主机 参数问题：报文头部某些字段头问题 重定向 (Redirect)：在路由器看来此报文不应由自己来转发，而应由其他路由器转发 网络探询报文 回声(Echo)请求与应答报文(Reply)：探测网络是否可达 时间戳请求与应答报文：获取时间戳 几种 ICMP 报文已不再使用：信息请求与应答报文；子网掩码请求和应答报文；路由器询问和通告报文几种不发送 ICMP差错报告报文的特殊情况： 对ICMP差错报告报文不再发送 ICMP差错报告报文 除第1个IP数据报分片外，对所有后续分片均不发送ICMP差错报告报文 对所有多播IP数据报均不发送 ICMP差错报告报文 对具有特殊地址（如127.0.0.0 或 0.0.0.0）的IP数据报不发送ICMP 差错报告报文 4.7.2 ICMP报文格式ICMP报文封装到IP数据报中传输ICMP差错报告报文数据封装 IP数据报的数据字段是UDP数据报时，前8个字节就是整个UDP头 IP数据报的数据字段是TCP数据报时，前8个字节包含了源地址、源端口号，目的地址、目的端口号等重要信息4.7.3 ICMP的应用：Traceroute探测路径上的所有路由器： 源主机向目的主机发送一系列UDP数据报：第1组IP数据报TTL =1，第2组IP数据报TTL=2, …。要保证目的端口号为不可能使用的端口号。 这样当第n组数据报(TTL=n)到达第n个路由器时：路由器丢弃数据报，向源主机发送携带路由器名称和IP地址信息的ICMP报文(type=11, code=0)。当ICMP报文返回到源主机时，记录RTT 停止准则：UDP数据报最终到达目的主机，目的主机返回“目的端口不可达”ICMP报文 (type=3,code=3)，此时源主机停止。 4.8 IPv6最初动机：32位IPv4地址空间已分配殆尽其他动机：改进首部格式——支持快速处理/转发数据报；支持QoS4.8.1 IPv6数据报格式固定长度的40字节基本首部不允许分片：只能由源主机分，目的主机组&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;0&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;4&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;8&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;12&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;16&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt; &amp;lt;td&amp;gt;24&amp;lt;/td&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td/&amp;gt;&amp;lt;td&amp;gt;31&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;4&quot;&amp;gt;&amp;lt;b&amp;gt;版本号&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;优先级(priority)&amp;lt;/b&amp;gt;：标识数据报的优先级&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;20&quot;&amp;gt;&amp;lt;b&amp;gt;流标签(flow Label)&amp;lt;/b&amp;gt;: 标识同一“流”中的数据报&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;16&quot; align=&quot;center&quot;&amp;gt;&amp;lt;b&amp;gt;载荷长度&amp;lt;/b&amp;gt;：最大64KB&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;下一个首部&amp;lt;/b&amp;gt;：标识下一个选项首部或上层协议首部(如TCP首部)。如果有扩展首部则指向扩展首部位置，同时每个扩展首部的此字段指向下个扩展首部，最后一个扩展首部指向上层协议首部&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;8&quot;&amp;gt;&amp;lt;b&amp;gt;跳步限制&amp;lt;/b&amp;gt;: 对应于TTL&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;&amp;lt;b&amp;gt;源IP地址&amp;lt;/b&amp;gt;(128位)&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;&amp;lt;b&amp;gt;目的IP地址&amp;lt;/b&amp;gt;(128位)&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr align=&quot;center&quot;&amp;gt; &amp;lt;td colspan=&quot;32&quot;&amp;gt;载荷（扩展首部+数据）&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;与IPv4相比的变化： 校验和(checksum)：彻底移除，以减少每跳处理时间 选项(options)：允许，但是从基本首部移出，定义多个选项首部，通过“下一个首部”字段指示 ICMPv6：新版ICMP 附加报文类型，e.g. “Packet Too Big”——分组过大直接丢弃，发送此报文 多播组管理功能 4.8.2 IPv6地址IPv6地址表示形式 一般形式：1080:0:FF:0:8:800:200C:417A 压缩形式：FF01:0:0:0:0:0:0:43，压缩→FF01::43 IPv4-嵌入形式：0:0:0:0:0:FFFF:13.1.68.3 或 ::FFFF:13.1.68.3 地址前缀：2002:43c:476b::/48 IPv6不再使用掩码，统一使用CIDR URLs：http://[3FFE::1:800:200C:417A]:8000 IPv6基本地址类型 单播(unicast)：一对一通信 多播(multicast)：一对多通信 任意播(anycast)：一对一组之一（最近一个）通信 没有广播地址，定义为一个特殊的多播地址。不可能在某个时刻所有路由器同时被更新为IPv6，所以IPv4和IPv6路由器共存，使用隧道协议使其共存。隧道(tunneling)：IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络4.9 路由算法网络抽象：图G = (N, E)，N = 路由器集合，E = 链路集合费用(Costs)：每段链路的费用可以总是1，或者是，带宽的倒数、拥塞程度等 图的抽象在网络领域应用很广泛 e.g.:P2P，其中，N是 peers集合，而E是TCP连接集合关键问题：源到目的（如u到z）的最小费用路径是什么？路由算法：寻找最小费用路径的算法路由算法分类 静态路由：手工配置；路由更新慢；优先级高 动态路由：路由更新快；定期更新；及时响应链路费用或网络拓扑变化 全局信息：所有路由器掌握完整的网络拓扑和链路费用信息。e.g. 链路状态(LS)路由算法 分散(decentralized)信息：路由器只掌握物理相连的邻居以及链路费用，邻居间信息交换、运算的迭代过程。e.g. 距离向量(DV)路由算法 4.9.1 链路状态路由算法Dijkstra 算法 所有结点(路由器)掌握网络拓扑和链路费用：通过“链路状态广播”；所有结点拥有相同信息 计算从一个结点(“源”)到达所有其他结点的最短路径：获得该结点的转发表 迭代：k次迭代后，得到到达k个目的结点的最短路径 c(x,y)：结点x到结点y链路费用；如果x和y不直接相连，则=∞ D(v)：从源到目的v的当前路径费用值 p(v)：沿从源到v的当前路径，v的前序结点 N’：已经找到最小费用路径的结点集合初始化:N&#39; = {u}for 所有结点v if v毗邻u then D(v) = c(u,v) else D(v) = ∞Loop 找出不在 N’中的w ，满足D(w)最小 将w加入N&#39; 更新w的所有不在N’中的邻居v的D(v) : D(v) = min( D(v), D(w) + c(w,v) ) /*到达v的新费用或者是原先到达v的费用，或者是已知的到达w的最短路径费用加上w到v的费用 */until 所有结点在N’中算法存在震荡(oscillations)可能：假设链路费用是该链路承载的通信量。初始为图1，此时会认为图2的代价更小，更新路由表为图2，又认为图3的代价更小，更新路由表为图3，又认为图2的代价更小，如此往复。如果一个B发往A的数据报恰好遇上了每次更新路由表，那么它将一直在B和B和D之间转发，直到TTL耗尽。4.9.2 距离向量路由算法核心：Bellman-Ford方程(动态规划)令d~x~(y)=从x到y最短路径的费用（距离），则d~x~(y) = min~v~ {c(x,v) + d~v~(y) }x到邻居v的费用 + 从邻居v到达目的y的费用（距离），在x的所有邻居v中取最小值重点：结点获得最短路径的下一跳, 该信息用于转发表中由于从结点x到结点y的最小费用未知，则需要对其估计，D~x~(y) = 从结点x到结点y的最小费用估计。x维护距离向量(DV)：D~x~ = [D~x~(y): y є N ]结点x已知到达每个邻居的费用为c(x,v)，就能维护其所有邻居的距离向量：D~v~ = [D~v~(y): y є N ]核心思想：每个结点不定时地将其自身的DV估计发送给其邻居，当x接收到邻居的新的DV估计时，即依据B-F更新其自身的距离向量估计：D~x~(y) ← min~v~{c(x,v) + D~v~(y)} for each node y ∊ N。D~x~(y)将最终收敛于实际的最小费用 d~x~(y)。距离向量路由算法的特点： 异步迭代：引发每次局部迭代的因素：局部链路费用改变或来自邻居的DV更新。 分布式：每个结点只当DV变化时才通告给邻居，邻居在必要时（其DV更新后发生改变）再通告它们的邻居。 好消息(链路费用降低)传播快，坏消息(链路费用增大)传播慢——无穷计数问题消除无穷计数问题： 毒性逆转(poisoned reverse)：如果一个结点到达某目的的最小费用路径是通过某个邻居，则通告给该邻居结点到达该目的的距离为无穷大 定义最大度量(maximum metric)：定义一个最大的有效费用值，如15跳步，16跳步表示∞4.8.3 层次路由将任意规模网络抽象为一个图计算路由过于理想化，标识所有路由器，将整个网络抽象成一个“扁平”网络在实际网络（尤其是大规模网络）中不可行： 网络规模：考虑6亿目的结点的网络：路由表几乎无法存储，路由计算过程的信息（e.g. 链路状态分组、DV）交换量巨大，会淹没链路。 管理自治：每个网络的管理可能都期望自主控制其网内的路由；互联网(internet) = 网络之网络(network of networks) 为此提出了层次路由。聚合路由器为一个区域——自治系统AS(autonomous systems)：同一AS内的路由器运行相同的路由协议(算法) 自治系统内部路由协议(“intra-AS” routing protocol)：只知道自己系统内的网络拓扑结构。 不同自治系统内的路由器可以运行不同的AS内部路由协议 网关路由器(gateway router)：在不同AS之间路由，位于AS“边缘”；通过链路连接其他AS的网关路由器自治系统间(Inter-AS)路由任务： 确定路由器应该将该数据报转发给哪个网关路由器：网关路由器必须学习到哪些目的网络可以通过那个邻网到达，并将这些网络可达性信息传播给本网络内部路由器。 到达某网络有多条路径，需要去确定在多AS间选择。策略：热土豆路由：将分组发送给最近的网关路由器.4.8.4 Internet路由Internet采用层次路由AS内部路由协议也称为内部网络协议IGP(interior gateway protocols)，最常见的AS内部路由协议： 路由信息协议：RIP(Routing Information Protocol) 开放最短路径优先：OSPF(Open Shortest Path First) 内部网关路由协议：IGRP(Interior Gateway Routing Protocol)：Cisco私有协议 4.8.4.1 RIP基于距离向量路由算法： 距离度量：跳步数 (max = 15 hops)，每条链路1个跳步 每隔30秒，邻居之间交换一次DV，成为通告(advertisement) 每次通告：最多25个目的子网(IP地址形式) 链路失效、恢复：如果180秒没有收到通告则推断邻居/链路失效，经过该邻居的路由不可用，重新计算路由；向邻居发送新的通告；邻居再依次向外发送通告（如果转发表改变）；可能发生无穷计数问题 (定义最大度量技术)；毒性逆转技术用于预防乒乓(ping-pong)环路(另外：无穷大距离 = 16 hops) 适用于小规模的自治系统，超过15跳的系统RIP不再适用。RIP路由表是利用一个称作route-d (daemon)的应用层进程进行管理，告报文周期性地通过UDP数据报发送。4.8.4.2 OSPF OSPF (Open Shortest Path First) “开放”：公众可用，非私有。采用链路状态路由算法 LS分组扩散（通告） 每个路由器构造完整的网络(AS)拓扑图 利用Dijkstra算法计算路由 OSPF通告中每个入口对应一个邻居 OSPF通告在整个AS范围泛洪，OSPF报文直接封装到IP数据报中 与OSPF极其相似的一个路由协议：IS-IS路由协议OSPF优点： 安全(security)：所有OSPF报文可以被认证(预防恶意入侵) 允许使用多条相同费用的路径 (RIP只能选一条)：负载均衡 对于每条链路，可以针对不同的TOS设置多个不同的费用度量 (e.g., 卫星链路可以针对“尽力”(best effort) ToS设置“低”费用；针对实时ToS设置“高”费用)：实现不同类型数据的分流 集成单播路由与多播路由：多播OSPF协议(MOSPF) 与OSPF利用相同的网络拓扑数据 OSPF支持对大规模AS分层(hierarchical)分层的OSPF：两级分层 局部区(Area)，主干区(Backbone) 链路状态通告只限于区内 每个路由器掌握所在区的详细拓扑 只知道去往其他区网络的“方向” (最短路径) 区边界路由器(Area Border Routers)：“汇总”到达所在区网络的距离，通告给其他区边界路由器。 主干路由器(Backbone Routers)：在主干区内运行OSPF路由算法。 AS边界路由器(AS boundary routers)：连接其他AS。4.8.4.3 BGPInternet AS间路由协议：边界网关协议BGP (Border Gateway Protocol)，事实上的标准域间路由协议，将Internet “粘合”为一个整体的关键。BGP为每个AS提供了一种手段： eBGP：从邻居AS获取子网可达性信息. iBGP：向所有AS内部路由器传播子网可达性信息. 基于可达性信息与策略，确定到达其他网络的 “好”路径容许子网向Internet其余部分通告它的存在。BGP会话(session)：两个BGP路由器 (“Peers”)交换BGP报文：实现通告去往不同目的前缀（prefix）的路径 **(路径向量(path vector)协议)。报文交换基于半永久的TCP**连接。BGP报文： OPEN：与peer建立TCP连接，并认证发送方 UPDATE：通告新路径 (或撤销原路径) KEEPALIVE：在无UPDATE时，保活连接；也用于对OPEN请求的确认 NOTIFICATION：报告先前报文的差错；也被用于关闭连接 当AS3通告一个前缀给AS1时：AS3承诺可以将数据报转发给该子网；AS3在通告中会聚合网络前缀。路径属性与BGP路由：通告的前缀信息包括BGP属性：前缀+属性= “路由”两个重要属性： AS-PATH(AS路径)：包含前缀通告所经过的AS序列。e.g., AS 67,AS 17 NEXT-HOP(下一跳)：开始一个AS-PATH的路由器接口，指向下一跳AS。 可能从当前AS到下一跳AS存在多条链路 BGP路由选择，基于策略(policy-based) 路由：网关路由器收到路由通告后，利用其输入策略(import policy)决策接受/拒绝该路由。e.g., 从不将流量路由到AS x。路由器可能获知到达某目的AS的多条路由，基于以下准则选择： 本地偏好(preference)值属性：策略决策(policydecision) 最短AS-PATH 最近NEXT-HOP路由器：热土豆路由(hot potato routing) 附加准则 A,B,C是提供商网络/AS(provider network/AS) X,W,Y是客户网络(customer network/AS) W,Y是桩网络(stub network/AS)：只与一个其他AS相连 X是双宿网络(dual-homed network/AS)：连接两个其他ASX不期望经过他路由B到C的流量，因此，X不会向B通告任何一条到达C的路由 A向B通告一条路径：AW B向X通告路径：BAW B不应该向C通告路径BAW，因为B路由CBAW的流量没有任何“收益”，因为W和C均不是B的客户。B期望强制C通过A向W路由流量；期望只路由去往/来自其客户的流量！ 采用不同的AS内与AS间路由协议的原因： 策略(policy)： inter-AS：期望能够管理控制流量如何被路由，谁路由经过其网络等. intra-AS：单一管理，无需策略决策 规模(scale)： 层次路由节省路由表大小，减少路由更新流量 适应大规模互联网 性能(performance)： intra-AS：侧重性能 inter-AS：策略主导 " }, { "title": "3 传输层", "url": "/posts/3-TransportLayer/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-09 14:22:08 +0800", "snippet": "网络层提供主机之间的逻辑通信机制，而传输层提供应用进程之间的逻辑通信机制3.1 多路复用和多路分用 多路复用（发送端）：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment，交给网络层 多路分用（接收端）：传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程工作方式： 主机接收IP数据报：每个数据报携带源IP地址和目的IP地址，还携带一个传输层的段(Segment)，每个段携带源端口号和目的端口号 收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket：网络层不关心端口号信息 3.1.1 无连接的多路分用 利用端口号创建Socket UDP的Socket用二元组标识：(目的IP地址，目的端口号) 主机收到UDP段后检查段中的目的端口号，将UDP段导向绑定在该端口号的Socket，所以只要目的IP和目的端口号相同，来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket3.1.2 面向连接的多路分用 TCP的Socket用四元组标识：(源IP地址，源端口号，目的IP地址，目的端口号) 接收端利用所有的四个值将Segment导向合适的Socket 服务器可能同时支持多个TCP Socket，每个Socket用自己的四元组标识：Web服务器为每个客户端开不同的Socket，可能创建多个进程，每个进程一个Socket；也可能创建多个线程，每个线程一个Socket 3.2 无连接传输协议UDPUDP基于IP协议,解决了复用/分用、简单的错误校验两个问题，UDP协议不可靠，数据可能丢失，可能非按序到达 在应用层增加可靠性机制以实现可靠的数据传输（增加了实现难度）无连接：UDP发送方和接收方之间不需要握手；每个UDP段的处理独立于其他段 优点：无连接减少了延迟（DNS使用UDP的原因），并且无需维护连接状态因此实现起来也简单；头部开销少；没有拥塞控制，应用可更好地控制发送时间和速率 用途：流媒体应用、DNS、SNMP UDP报文段格式： 源端口号 目的端口号 UDP段(包含头部)的长度 校验和 应用数据（消息） 校验和checksum 目的：检测UDP段在传输中是否发生错误（如位翻转） 发送方：计算前将校验和字段设为全0，然后将段的内容视为16-bit整数，(校验和计算)计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和；将校验和放入校验和字段 接收方：计算所收到段的校验和，将其与校验和字段进行对比：不相等——检测出错误；相等——没有检测出错误（但可能有错误） 3.3 可靠数据传输信道的不可靠特性决定了可靠数据传输协议(RDT)的复杂性3.3.1 可靠数据传输原理 发送方调用rdt_send() 将待发送数据交给可靠数据传输协议 可靠数据传输协议调用 udt_send() 将数据发送给传输层 数据发送到接收方的传输层，调用rdt_rcv() 将数据传给可靠数据传输协议 RDT整理后调用deliver_data将完整的数据发给接收方上层应用 第2、3步的通信都是双向的，以保证传输数据的完整性（可靠性）3.3.2 RDT3.3.2.1 RDT1.0可靠信道上的可靠数据传输协议假设底层信道完全可靠，无丢失无错误，因此双方无需进行控制信息的传递，发送方只需把消息发送一次即可，接收方收到的消息即是完整的消息。3.3.2.2 RDT2.0可能产生位错误的信道上的可靠数据传输协议利用校验和检测底层信道可能翻转分组中的位错误，双方要进行控制信息的传递以纠正错误： ACK (确认机制)——接收方显式地告知发送方分组已正确接收； NAK——接收方显式地告知发送方分组有错误，发送方收到NAK后，重传分组基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest)协议 Rdt 2.0中引入的新机制：差错检测；接收方反馈控制消息: ACK/NAK；重传 在实现的过程中，利用了停-等协议，即发送方发送了一个packet后，只有在收到来自接收方的确认消息后才能继续下一步操作。3.3.2.3 RDT2.1、2.2在RDT2.0中没有ACK/NAK消息发生错误/被破坏的处理方案，于是提出了新的解决方案 RDT2.1 如果ACK/NAK坏掉发送方就重传，但这有可能会产生重复分组，所以RDT2.1为每个分组增加了序列号（使用0，1标识——基于停-等协议），所以接收方可以根据序列号丢弃重复分组 相比与2.0，发送方为每个分组增加了序列号，并且需要检验ACK/NAK消息是否发生错误，而且由于状态必须“记住”“当前”的分组，所以序列号FSM的状态数量翻倍；接收方需要判断分组是否重复即是否收到了期望的序列号 RDT2.2：无NAK消息协议 在RDT2.1的基础上删除NAK，接收方通过ACK告知最后一个被正确接收的分组，在ACK消息中显式地加入被确认分组的序列号，发送方收到重复ACK之后，处理方式与收到NAK相同，重传当前分组 3.3.2.4 RDT3.0如果信道既可能发生错误，也可能丢失分组在这个协议中，引入了定时器，发送方会等待合理的时间，如果时间内未收到ACK，则重传，而如果分组只是延迟而不是丢了也同样会引发重传，但序列号机制能够处理这种问题 Rdt 3.0能够正确工作，但由于停-等操作规定了需要等待接收方响应之后才进行下一步操作，所以性能很差3.3.3 滑动窗口协议3.3.3.1 流水线机制与滑动窗口协议由于RDT3.0的性能限制在于等待ACK消息的过程中带宽资源闲置，所以在流水线机制下，允许发送方在收到ACK之前连续发送多个分组，因而也需要更大的序列号范围，发送方/接收方需要更大的存储空间以缓存分组滑动窗口协议 (Sliding-window protocol)：窗口是允许的序列号的范围，窗口尺寸为N表示最多有N个等待确认的消息。随着协议的运行，窗口在序列号空间内向前滑动（序列号会越来越大）。 主要的滑动窗口协议：GBN、SR3.3.3.2 GBN（Go-Back-N）发送方：分组头部包含k-bit的序列号，窗口尺寸为N，即最多允许N个分组未确认，如果上层应用发来的数据没有可用的序列号时调用refuse_data(data) 拒绝。ACK(n)：确认到序列号n(包含n)的分组均已被正确接收——累积确认为空中的分组设置计时器(timer)，超时Timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组接收方：无缓存，只需要记住唯一的expectedseqnum (期望序列号)，对于乱序到达的分组直接丢弃，重新确认序列号最大的、按序到达的分组ACK机制: 发送拥有最高序列号的、已被正确接收的分组的ACK3.3.3.3 SR (Selective Repeat)GBN的丢失信息会导致所有序列号高于已经确认的序列号的包全部重发，因而造成资源浪费。在GBN的基础上改进得SR协议： 发送方只重传那些没收到ACK的分组，为每个分组设置定时器 接收方对每个分组单独进行确认，设置缓存机制，缓存乱序到达的分组，设置一个接收方窗口，将乱序到达的分组缓存，等待前面的分组到达后与前面的分组一起合并和交给上层 收到在窗口内的分组时先发送ACK(n)，再判断是不是乱序到达的分组，是就缓存，不是就合并交付移动窗口 收到窗口左侧的分组发送ACK(n) 收到窗口右侧的分组忽略 序列号空间大小与窗口尺寸需满足：N~S~+N~R~&amp;lt;=2^k^3.4 TCP3.4.1 TCP段结构3.4.1.1 TCP段结构3.4.1.2 序列号序列号是segment中第一个字节的编号，而不是segment的编号（$NextSeqNum = SeqNum + length(data)$）建立TCP时，双方随机选择序列号3.4.1.3 ACK指的是希望接收到的下一个字节的序列号使用的是累计确认机制（该序列号之前的所有字节均已被正确接收到） 关于乱序到达的Segment，TCP规范中没有规定，由TCP的实现者做出决策3.4.2 TCP可靠数据传输TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务，使用了以下机制 流水线机制 累积确认 TCP使用单一重传定时器。触发重传的事件：超时；收到重复ACK 3.4.2.1 RTT和超时为了设置定时器的超时时间，必须参考网络的RTT时间，而RTT是变化的，所以必须测量RTTSampleRTT：测量从段发出去到收到ACK的时间。多次测量取平均值得到估计值EstimatedRTT（指数加权移动平均）：$EstimatedRTT = (1- \\alpha)EstimatedRTT + \\alphaSampleRTT$ （$\\alpha$一般取0.125）超时时间设置为：EstimatedRTT+ 安全边界。所以如果EstimatedRTT变化大就意味着需要设置较大的边界，所以就需要测量RTT的变化值：SampleRTT与EstimatedRTT的差值： $DevRTT = (1- \\beta)*DevRTT +\\beta * SampleRTT-EstimatedRTT $ 所以超时时间的设置：$TimeoutInterval = EstimatedRTT + 4*DevRTT$3.4.2.2 发送方从应用层收到数据：创建Segment（设置序列号）–&amp;gt;开启计时器–&amp;gt;设置超时时间：超时事件：重传引起超时的Segment，重启定时器收到ACK：如果确认此前未确认的Segment，更新滑动窗口（SendBase），如果窗口中还有未被确认的分组，重新启动定时器。3.4.2.3 接收方ACK生成 接收方事件 接收方TCP动作 收到按序到达的段（之前无等待发ACK的段） 等待500ms，看是否有下一个段到达，如果没有就直接发送ACK 收到按序到达的段（之前有等待发ACK的段） 立即发送它的确认消息 收到乱序到达的段 立即发送重复的ACK消息，声明期望的段 3.4.2.4 快速重传机制TCP的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大，所以重发丢失的分组之前要等待很长时间使之超时。Sender会连续地发送多个分组，如果某个分组丢失，可能会引发多个重复的ACK，所以可以通过重复ACK检测分组丢失。如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失。快速重传：在定时器超时之前即进行重传。 问题：为什么是收到3次相同的ACK？3.4.3 TCP流量控制接收方为TCP连接分配缓冲区(buffer)，而上层应用可能处理buffer中数据的速度较慢，所以就需要流量控制以保证发送方不会传输的太多、太快以至于淹没接收方（buffer溢出）。流量控制实际上是速度匹配机制。假定TCP receiver丢弃乱序的段，则Buffer中的可用空间(spare room)= RcvWindow= RcvBuffer-[LastByteRcvd -LastByteRead]Receiver通过在段的头部字段将RcvWindow 告诉SenderSender限制自己已经发送的但还未收到ACK的数据不超过接收方的RcvWindow尺寸Receiver告知Sender RcvWindow=0，这会导致即使Reciver空闲了也无法通知Sender，所以需要一个机制来使Sender可以发送一个小的段从而可以带回Reciver的信息，避免了上面的死锁。3.4.4 TCP连接管理TCP sender和receiver在传输数据前需要建立连接初始化TCP变量：如分配序列号、分配缓存区、交换流量控制信息。3.4.4.1 TCP建立：三次握手Client：连接发起者Server: 等待客户连接请求 Client主机向Server发送一个TCP SYN segment： SYN=1, seq=client_isn 不携带数据 SYN标志位置1 传递选择的初始序列号 Server主机收到SYN，同意建立连接，回复SYNACK段 SYN=1, seq=serever_isn, ack=client_isn+1 Server分配buffer 选择Server端的初始序列号，并告知Client Client收到SYNACK，答复ACK段，SYN标志不再位置1，也可包含数据。 SYN=0, seq=client_isn+1, ack=server_isn+1 3.4.4.2 TCP关闭Client和Server都可发起关闭请求，多数是客户机发起。 Client向server发送TCP FIN 控制segment Server收到FIN, 回复ACK. 关闭连接, 发送FIN. Client收到FIN, 回复ACK。进入“等待” ——如果收到FIN，会重新发送ACK Server收到ACK. 连接关闭.3.4.4.3 TCP生命周期TCP客户端：TCP服务端：3.5 拥塞控制拥塞的表现： 分组丢失（路由器缓存溢出） 分组延迟过大（在路由器缓存中排队）3.5.1 拥塞的成因和代价$\\lambda_{in}$：实际需要发送的数据$\\lambda’_{in}$：实际需要发送的数据+需要重传的数据$\\lambda_{out}$：实际接收的数据 两个senders，两个receivers，一个路由器且无限缓存：这种条件下不需要重传，但拥塞时分组延迟太大。对于路由器：$\\lambda_{in} = \\lambda_{out}$ 两个senders，两个receivers，一个路由器且有限缓存：可能丢包，所以Sender需要重传分组。对于路由器： 情况a：Sender能够通过某种机制获知路由器buffer信息，有空闲才发。$\\lambda_{in}=\\lambda’{in}=\\lambda{out}$ 情况b：丢失后才重发。$\\lambda’{in}&amp;gt;\\lambda{out}$ 情况c：分组丢失和定时器超时后都重发，$\\lambda’_{in}$变得更大 由于重传，网络要做更多的工作，造成了资源的浪费。 四个发送方，多跳：可能丢包或超时都会引起重传。当拥塞时，一个分组被drop，任何用于该分组的“上游”传输能力全都被浪费掉3.5.2 拥塞控制的方法3.5.2.1 端到端拥塞控制网络层不需要显式的提供支持，端系统通过观察loss，delay等网络行为判断是否发生拥塞。TCP采取这种方法。3.5.2.2 网络辅助的拥塞控制路由器向发送方显式地反馈网络拥塞信息，通过简单的拥塞指示（1bit：SNA, DECbit, TCP/IP ECN, ATM）指示发送方应该采取何种速率3.5.2.3 ATM ABR拥塞控制**ABR **(available bit rate)： 如果发送方路径“underloaded”，使用可用带宽 如果发送方路径拥塞，将发送速率降到最低保障速率 **RM **(resource management) cells： 发送方发送 交换机设置RM cell位(网络辅助) NI bit: rate不许增长 CI bit: 拥塞指示 RM cell由接收方返回给发送方RM cell中显式的速率(ER)字段：两个字节。拥塞的交换机可以将ER置为更低的值，发送方获知路径所能支持的最小速率数据cell中的EFCI位：拥塞的交换机将其设为1，如果RM cell前面的data cell的EFCI位被设为1，那么发送方在返回的RM cell中置CI位3.5.3 TCP拥塞控制Sender限制发送速率：$LastByteSent-LastByteAcked&amp;lt;= CongWin$，则速率 $rate ≈\\frac{CongWin}{RTT}\\ Bytes/sec$CongWin（发送窗口）保证了动态调整以改变发送速率，它反映所感知到的网络拥塞。感知网络拥塞：Loss事件=timeout或3个重复ACK。发生loss事件后，发送方降低速率。调整发送速率：加性增—乘性减；慢启动3.5.3.1 加性增—乘性减: AIMD原理：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss，一旦发生loss，速率直接减半。方法: AIMD Additive Increase：每个RTT将CongWin增大一个MSS——拥塞避免 Multiplicative Decrease：发生loss后将CongWin减半 3.5.3.2 TCP慢启动: SS原理：当连接开始时，指数性增长——收到每个ACK将CongWin加1 (即每个RTT将CongWin翻倍)。初始速率很慢，但是快速攀升。当CongWin达到Loss事件前值的1/2时，触发拥塞避免机制，指数性增长切换为线性增长。实现方法：Threshold变量。Loss事件发生时，Threshold被设为Loss事件前CongWin值的1/2，然后开始线性增长。Loss事件处理 3个重复ACKs：CongWin切到一半然后线性增长 Timeout事件：CongWin直接设为1个MSS，然后指数增长，达到threshold后, 再线性增长。 3个重复ACKs表示网络还能够传输一些 segments，而timeout事件表明拥塞更为严重。 3.5.4 TCP性能分析TCP吞吐率 忽略掉Slow start，假定发生超时时CongWin的大小为W，吞吐率是W/RTT 超时后，CongWin=W/2，吞吐率是W/2RTT 平均吞吐率为：0.75W/RTT TCP的公平性 公平：如果K个TCP Session共享相同的瓶颈带宽R，那么每个Session的平均速率为R/K。TCP是公平的。 公平性与UDP：多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率。使用UDP的话可以以恒定速率发送，能够容忍丢失，于是产生了不公平。 公平性与并发TCP连接：某些应用会打开多个并发连接，如Web浏览器，于是产生公平性问题。 例子：链路速率为R，已有9个连接，新来的应用请求1个TCP，获得R/10的速率，新来的应用请求11个TCP，获得R/2的速率 " }, { "title": "2 应用层", "url": "/posts/2-ApplicationLayer/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-08 21:41:25 +0800", "snippet": "2.1 基本原理2.1.1 网络应用的体系结构 客户机/服务器结构(Client-Server, C/S) 服务器：7*24小时提供服务；永久性访问地址/域名；利用大量服务器实现可扩展性 客户机：与服务器通信，使用服务器提供的服务；间歇性接入网络；可能使用动态IP地址；不会与其他客户机直接通信 Web应用 点对点结构(Peer-to-peer, P2P) 没有永远在线的服务器，任意端系统/节点之间可以直接通讯，节点间歇性接入网络，节点可能改变IP地址 优点在于高度可伸缩，缺点在于难于管理 文件传输应用 混合结构(Hybrid) 文件传输使用P2P结构，文件的搜索采用C/S结构——集中式 每个节点向中央服务器登记自己的内容，而在查找感兴趣的内容时向中央服务器提交查询请求 Napster 2.1.2 网络应用进程通信同一主机上运行的进程之间由操作系统提供进程间通信机制不同主机上运行的进程间靠消息交换通信，进程间通信利用socket发送/接收消息实现 进程寻址：通过标识符(IP地址+端口号)在不同主机上的进程间通信 使用IP地址对主机寻址 为主机上每个需要通信的进程分配一个端口号，使用端口号对主机上的进程寻址 HTTP Server: 80 Mail Server：25 应用层协议：网络应用需遵循应用层协议 公开协议：由RFC定义的，允许互操作的协议(HTTP、SMTP) 私有协议：多数P2P文件共享应用 应用层协议内容 消息的类型(type)：请求消息、响应消息 消息的语法(syntax)/格式：消息中有哪些字段(field)、每个字段如何描述 字段的语义(semantics)：字段中信息的含义 规则(rules)：进程何时发送/响应消息、进程如何发送/响应消息 2.1.3 网络应用的服务需求 数据丢失(data loss)/可靠性(reliability) 某些网络应用能够容忍一定的数据丢失：网络电话 某些网络应用要求100%可靠的数据传输：文件传输，telnet 时间(timing)/延迟(delay) 有些应用只有在延迟足够低时才“有效”，如：网络电话/网络游戏 带宽(bandwidth) 某些应用只有在带宽达到最低要求时才“有效”：网络视频 某些应用能够适应任何带宽——弹性应用：email   TCP服务 UDP服务 连接 面向连接: 客户机/服务器进程间需要建立连接 无连接 传输 可靠的传输 不可靠的数据传输 流量控制 发送方不会发送速度过快，超过接收方的处理能力 不提供 拥塞控制 当网络负载过重时能够限制发送方的发送速度 不提供 时间/延迟保障 不提供 不提供 带宽保障 不提供最小带宽保障 不提供 2.2 web应用2.2.1 HTTP连接 HTTP连接使用TCP传输服务： 服务器在80端口等待客户的请求 浏览器发起到服务器的TCP连接(创建套接字Socket) 服务器接受来自浏览器的TCP连接 浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP消息 关闭TCP连接 HTTP协议是无状态的，服务器不维护任何有关客户端过去所发请求的信息。 有协议的更复杂，需要维护每个用户的历史信息状态，而且当客户或者服务器失效会产生状态的不一致，解决这种不一致代价高 HTTP1.0 HTTP1.1 非持久性连接(Nonpersistent HTTP)每个TCP连接最多允许传输一个对象 持久性连接(Persistent HTTP)每个TCP连接允许传输多个对象 每个对象需要2个RTT操作系统需要为每个TCP连接开销资源(overhead) 发送响应后，服务器保持TCP连接的打开 无流水(pipelining)的持久性连接 带有流水机制的持久性连接(HTTP 1.1的默认选项) 客户端只有收到前一个响应后才发送新的请求 客户端只要遇到一个引用对象就尽快发出请求 每个被引用的对象耗时1个RTT 理想情况下，收到所有的引用对象只需耗时约1个RTT RTT(Round Trip Time)：从客户端发送一个很小的数据包到服务器并返回所经历的时间 响应时间 = 建立TCP连接的1个RTT + 发送HTTP请求消息到HTTP响应消息的前几个字节到达的1个RTT + 响应消息中所含的文件/对象传输时间 = 2RTT + 文件发送时间 2.2.2 HTTP消息格式2.2.2.1 请求消息(request) HTTP 1.0 GET方法： 输入信息通过request行的URL字段上传 POST方法：网页经常需要填写表格(form)，在请求消息的消息体(entity body)中上传客户端的输 HEAD方法：请Server不要将所请求的对象放入响应消息中 HTTP 1.1 GET, POST, HEAD PUT：将消息体中的文件上传到URL字段所指定的路径 DELETE：删除URL字段所指定的文件 2.2.2.2 响应消息(response)HTTP响应状态代码，响应消息的第一行： 200 OK 301 Moved Permanently 400 Bad Request 404 Not Found 505 HTTP Version Not Supported2.2.3 Cookie技术 HTTP协议无状态，但很多应用需要服务器掌握客户端的状态Cookie技术：某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)。Cookie的组件： TTP响应消息的cookie头部行 HTTP请求消息的cookie头部行 保存在客户端主机上的cookie文件，由浏览器管理 Web服务器端的后台数据库Cookie能够用于：身份认证、购物车、推荐、Web e-mail、…… 但是cookie存在用户隐私泄露的问题2.2.4 Web缓存/代理服务器技术：条件GET 为了缩短客户请求的响应时间、减少机构/组织的流量、在大范围内(Internet)实现有效的内容分发，所以提出了在不访问服务器的前提下满足客户端的HTTP请求的技术——Web缓存/代理服务器技术。浏览器向缓存/代理服务器发送所有的HTTP请求：如果所请求对象在缓存中，缓存返回对象；否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象。所以缓存既充当客户端，也充当服务器，一般由ISP(Internet服务提供商)架设。条件性GET方法目标：如果缓存有最新的版本，则不需要发送请求对象缓存：在HTTP请求消息中声明所持有版本的日期(在HTTP请求消息有 If-modified-since: &amp;lt;date&amp;gt;)服务器：如果缓存的版本是最新的，则响应消息中不包含对象(响应消息为 HTTP/1.0 304 Not Modified)，如果不是最新的，正常返回请求对象 在HTTP响应消息中有一行 Last-Modified header line，表明最后一次的修改时间2.3 Email应用Email应用的构成组件 邮件客户端(user agent)：Client应用或者Web页面 邮件服务器 SMTP协议(Simple Mail Transfer Protocol)：在邮件服务器之间传递消息使用的协议 客户端：发送消息的服务器 服务器：接收消息的服务器 2.3.1 SMTP协议使用TCP在25端口建立持久性连接进行email消息的可靠传输，传输过程的三个阶段：握手、消息的传输、关闭。命令/响应交互模式： 命令(command)：ASCII文本 响应(response)：状态代码和语句 Email消息只能包含7位ASCII码SMTP服务器利用CRLF.CRLF确定消息的结束。 SMTP与HTTP对比： HTTP是拉式(pull)，而SMTP是推式(push) HTTP的每个对象封装在独立的响应消息中，SMTP的多个对象在由多个部分构成的消息中发送 都使用命令/响应交互模式 命令和状态代码都是ASCII码 2.3.2 Email消息格式Email消息由三部分组成： 头部行(header) To From Subject 空白行 消息体：消息本身，只能是ASCII字符而为了传输非文本类型的数据，对如上的消息做出了扩展。MIME：多媒体邮件扩展。通过在邮件头部增加额外的行以声明MIME的内容类型。2.3.3 邮件访问协议邮件访问协议：从服务器获取邮件 POP (Post Office Protocol)：认证/授权(客户端&amp;lt;—-&amp;gt;服务器)和下载 IMAP (Internet Mail Access Protocol)：更多功能、更加复杂、能够操纵服务器上存储的消息 所有消息统一保存在一个地方：服务器 允许用户利用文件夹组织消息 支持跨会话(Session)的用户状态：文件夹的名字、文件夹与消息ID之间的映射等 HTTP：163, QQ Mail等(网页版使用)2.3.3.1 POP3协议 认证过程 客户端命令 User：声明用户名 Pass：声明密码 服务器响应 +OK -ERR 事务阶段 List：列出消息数量 Retr：用编号获取消息 Dele：删除消息 Quit POP协议有两种模式： “下载并删除”模式：用户如果换了客户端软件，无法重读该邮件 “下载并保持”模式：不同客户端都可以保留消息的拷贝 POP3是无状态的2.3.3.2 IMAP协议所有消息统一保存在一个地方：服务器允许用户利用文件夹组织消息，支持跨会话(Session)的用户状态：文件夹的名字、文件夹与消息ID之间的映射等2.4 DNS应用DNS：Domain Name System 域名解析系统 多层命名服务器构成的分布式数据库 应用层协议：完成名字的解析。Internet核心功能，用应用层协议实现DNS服务：域名向IP地址的翻译；主机别名；邮件服务器别名；Web服务器负载均衡2.4.1 分布式层次式数据库根域名服务器：本地域名解析服务器无法解析域名时，访问根域名服务器。顶级域名服务器(TLD, top-level domain)：负责com, org, net,edu等顶级域名和国家顶级域名，例如cn, uk, fr等。权威(Authoritative)域名服务器：组织的域名解析服务器，提供组织内部服务器的解析服务。组织或服务提供商负责维护。本地域名解析服务器：不严格属于层级体系，每个ISP有一个本地域名服务器，是默认域名解析服务器。当主机进行DNS查询时，查询被发送到本地域名服务器，作为代理(proxy)，将查询转发给(层级式)域名解析服务器系统。 迭代查询：被查询服务器返回域名解析服务器的名字。“我不认识这个域名，但是你可以问题这服务器” 递归查询：将域名解析的任务交给所联系的服务器 只要域名解析服务器获得域名—IP映射，即缓存这一映射，一段时间过后，缓存条目失效(删除) 本地域名服务器一般会缓存顶级域名服务器的映射，因此根域名服务器不经常被访问2.4.2 DNS记录资源记录(RR, resource records)，RR format: (Name, Value, Type, TTL) Type=A Name：主机域名 Value：IP地址 Type=NS Name：域(edu.cn) Value：该域权威域名解析服务器的主机域名 Type=CNAME Name：某一真实域名的别名，如 www.ibm.com – servereast.backup2.ibm.com Value：真实域名 Type=MX Value是与name相对应的邮件服务器 2.4.3 DNS协议和消息格式DNS协议：查询 (query) 和回复 (reply) 消息，消息格式相同消息头部： Identification：16位查询编号，回复使用相同的编号 flags：查询或回复、期望递归、递归可用、权威回答为公司 “Network Utopia”注册域名： 在域名管理机构(如Network Solutions)注册域名networkutopia.com。向域名管理机构提供你的权威域名解析服务器的名字和IP地址，域名管理机构向com顶级域名解析服务器中插入两条记录 (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A) 在权威域名解析服务器中为www.networkuptopia.com加入Type A记录，为networkutopia.com加入Type MX记录 2.5 FTPfile transfer protocol，基于C/S架构。FTP有两个连接，一个用于控制，一个用于数据传输。FTP客户端使用TCP在端口21联系FTP服务器，通过控制连接授权客户端，客户端浏览远程目录，通过控制连接发送命令，当服务器接收文件传输命令时，服务器打开第二个TCP数据连接(用于文件)到客户端，传输一个文件后，服务器关闭数据连接。控制连接被称为带外传输2.6 P2P应用2.6.1 原理 没有服务器 任意端系统之间直接通信 节点阶段接入Internet 节点可能更换IP地址问题：从一个服务器向N个节点分发一个文件F需要多长时间？ 设： u~s~ ——服务器上传带宽 u~i~ ——节点i的上传带宽 d~i~ ——节点i的下载带宽 C/S架构 服务器发送N个副本的时间：NF/u~s~ 客户机i的下载时间：F/d~i~ 分发N个F所需时间：d~cs~=max{ NF/u~s~ , F/min{d~i~} }——时间关于N是线性增长的 P2P 服务器必须发送一个副本(最小的消耗时间)：F/u~s~ 客户机i的下载时间：F/d~i~ 下载总量：NF bits 最快的上传速率(服务器和所有的节点都在上传)：u~s~ + Σu~i~ 分发N个F所需要的时间：d~P2P~ = max { F/u~s~, F/min(d~i~) , NF/(u~s~ + Σu~i~) }——非线性的 2.6.2 文件分发：BitTorrent 洪流(torrent)：参与一个特定文件分发的所有对等方的集合 文件块(chunk)：一个洪流中的对等方下载等长度的文件块，典型长度256KB 追踪器(tracker)：一个对等方加入一个洪流时，它向追踪器注册自己并周期性地通知追踪器它还在线BitTorrent 文件划分为256KB的chunk 节点加入torrent时没有chunk，但是会逐渐积累；每个节点向tracker注册以获得节点清单，与某些节点(“邻居”)建立连接 下载的同时，节点需要向其他节点上传chunk 节点可能加入或离开：一旦节点获得完整的文件，它可能(自私地)离开或(无私地)留下 获取chunk 给定任一时刻，不同的节点持有文件的不同chunk集合 节点(Alice)定期查询每个邻居所持有的chunk列表 节点发送请求，请求获取缺失的chunk：稀缺优先 发送chunk：tit-for-tat Alice向正在向其发送Chunk且速率最快的4个邻居发送chunk：每10秒重新评估top 4 每30秒随机选择一个其他节点，向其发送chunk：新选择节点可能加入top 4，“optimistically unchoke” 2.6.3 索引技术2.6.3.1 集中式索引 节点加入时，通知中央服务器：IP地址和内容 Alice查找“Hey Jude” Alice从Bob处请求文件 存在的问题：内容和文件传输是分布式的，但是内容定位是高度集中式的 单点失效问题 性能瓶颈 版权问题2.6.3.2 洪泛式查询：Query flooding完全分布式架构(Gnutella采用这种架构)——每个节点对它共享的文件进行索引，且只对它共享的文件进行索引、覆盖网络(overlay network)：Graph 节点X与Y之间如果有TCP连接，那么构成一个边 所有的活动节点和边构成覆盖网络 边：虚拟链路 节点一般邻居数少于10个 查询消息通过已有的TCP连接发送，节点转发查询消息，如果查询命中，则利用反向路径发回查询节点。2.6.3.3 层次是覆盖网络介于集中式索引和洪泛查询之间的方法每个节点或者是一个超级节点，或者被分配一个超级节点节点和超级节点间维持TCP连接，某些超级节点对之间维持TCP连接超级节点负责跟踪子节点的内容2.7 Socket编程2.7.1 应用编程接口(API) 应用层(Application)：Web/RPC/中间件编程 Socket编程 NetBIOS编程——Windows 传输层(Transport) 网络层(Network) 基于NDIS网络编程——Windows 基于LibPcap/WinPcap、Libnet、Libnids、Libicmp编程 数据链路层(Data link) 直接网卡编程，硬件相关的 基于Packet Driver编程，屏蔽网卡细节，适用于所有网卡 物理层(Physical) API：为了使应用层的应用进程可以和相邻层(传输层)传递数据，需要一个接口，即API。所以API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口典型的应用编程接口： socket interface(socket、套接字)——Berkeley UNIX Windows Socket Interface(WINSOCK)——微软 Transport Layer Interface(TLI)——AT&amp;amp;T UNIX 系统 V2.7.2 Socket API概述 标识通信端点(对外)：IP地址+端口号(16位整数) 操作系统/进程管理套接字(对内)：套接字描述符(socket descriptor)——小整数 Socket抽象 类似于文件的抽象：当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息，操作系统返回套接字描述符 操作系统维护一个套接字描述符表，存储的是指向套接字数据结构的指针 地址结构：sockaddr_in struct aockaddr_in{ u_char sin_len; /*地址长度*/ u_char sin_family; /*地址族*/ u_short sin_port; /*端口号*/ struct in_addr sin_addr; /*IP地址*/ char sin_zero[8]; /*未用(置0)*/} 地址族：为了适应不同协议的变化，引入了地址族，其在TCP/IP下使用的值为AF_INET 2.7.3 Socket API函数所有的API都是在WINSOCK中的，与UNIX下的socket大同小异2.7.3.1 WSAStartupint WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); 使用Socket的应用程序在使用Socket之前必须首先调用此函数加载DLL 第一个参数指明程序请求使用的WinSock版本：高位字节指明副版本、低位字节指明主版本 第二个参数是返回实际的WinSock的版本信息：指向WSADATA结构的指针/* 例 */wVersionRequested = MAKEWORD(2, 1);err = WSAStartup(wVersionRequested, &amp;amp;wsaData);2.7.3.2 WSACleanupint WSACleanup (void);应用程序在完成对请求的Socket库的使用，最后要调用WSACleanup函数解除与Socket库的绑定，释放Socket库所占用的系统资源2.7.3.3 socketsd = socket(protofamily,type,proto); 用于创建套接字 操作系统返回套接字描述符(sd) 第一个参数指明协议族：在TCP/IP下为PF_INET 第二个参数指明套接字类型：在TCP/IP下可以为SOCK_STREAM、SOCK_DGRAM或SOCK_RAW 第三个参数指明协议号：默认为0，当某类套接字只面向一类协议时直接使用0即可，而面向多个协议时就需要指定协议号了 Socket面向TCP/IP的服务类型 应用层 ———– 应用进程 ​ / \\ SOCK_STREAM SOCK_DGRAM ​ / SOCK_RAW \\ 传输层–TCP UDP 网络层———-IP/ICMP/IGMP2.7.3.4 Closesocketint closesocket(SOCKET sd) unix下该函数名是close，也就是关闭文件的函数 该函数是关闭描述符为sd的套接字 但如果多个进程共享一个套接字，调用该函数是将套接字引用计数减1，减至0才关闭，它清除掉的只是该进程中对它的引用 而一个进程中的多线程对一个套接字的使用是无计数的，也就是说，在一个线程中关闭了一个套接字意味着其他线程也不能再访问该套接字了 返回0表示成功，返回SOCKET_ERROR表示失败2.7.3.5 bindint bind(sd, localadr, addrlen); 绑定套接字的本地端点地址：IP地址+端口号 由于在创建SOCKET的时候可能没有对应的地址信息，所以要进行地址信息的绑定 客户程序一般不需要调用bind函数，操作系统自动设置 服务端需要绑定端口号，而不能绑定特定的IP，一旦绑定了特定IP意味着其他IP就不能访问该服务器了，所以为了解决该问题，服务端绑定的是一个地址通配符INADDR_ANY2.7.3.6 listenint listen(sd, queuesize); C/S架构下将服务器端的流套接字置为监听状态，所以此函数仅被服务器调用，仅用于面向连接(TCP)的流套接字 第二个参数设置连接请求队列的大小，服务器从队列中提取 返回0表示成功，返回SOCKET_ERROR表示失败2.7.3.7 connectconnect(sd,saddr,saddrlen); 使客户套接字(sd)与特定计算机的特定端口(saddr)的套接字(服务)进行连接 仅用于客户端，可用于TCP客户端，也可用于UDP客户端 TCP客户端：建立TCP连接，客户端调用此函数对服务器发起连接请求 UDP客户端：指定服务器端点地址，UDP是无连接的，所以即使调用commect 成功，也有可能无法与服务器通信 2.7.3.8 acceptnewsock = accept(sd,caddr,caddrlen); 服务程序调用accept从处于监听状态的流套接字sd的客户连接请求队列中取出排在最前的一个客户请求，并且创建一个新的套接字来与客户套接字创建连接通道 如果直接使用服务器的主套接字则服务器在同一时刻只能与一个客户端连接，所以使用创建新套接字来达到并行连接的目的(并发的TCP服务器) 仅用于服务器，仅用于TCP套接字2.7.3.9 send, sendtosend(sd,*buf,len,flags);sendto(sd,*buf,len,flags,destaddr,addrlen); send是没有指定服务器的地址的，也就是说连接已经建立了，故可用于： TCP套接字(客户端与服务器端均可) 调用了 connect 的UDP客户端的套接字(连接模式的UDP套接字) sendto函数用于UDP服务器端套接字与未调用connect函数的UDP客户端套接字2.7.3.10 recv, recvfromrecv(sd,*buffer,len,flags);recvfrom(sd,*buf,len,flags,senderaddr,saddrlen); recv函数从TCP连接的另一端接收数据，或者从调用了connect函数的UDP客户端套接字接收服务器发来的数据 recvfrom函数用于从UDP服务器端套接字与未调用connect函数的UDP客户端套接字接收对端数据2.7.3.11 setsockopt, getsockoptint setsockopt(int sd, int level, int optname, *optval, int optlen);int getsockopt(int sd, int level, int optname, *optval, socklen_t *optlen); setsockopt函数用来设置套接字sd的选项参数 getsockopt函数用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optval2.7.4 网络字节顺序由于五层网络模型中不存在表示层，所以无法进行不同机器间的表示转化，于是TCP/IP定义了标准的用于协议头中的二进制整数表示：网络字节顺序(network byte order)某些Socket API函数的参数需要存储为网络字节顺序(如IP地址、端口号等)，因此实现本地字节顺序与网络字节顺序间转换的函数有： htons：本地字节顺序→网络字节顺序(16bits) ntohs：网络字节顺序→本地字节顺序(16bits) htonl：本地字节顺序→网络字节顺序(32bits) ntohl：网络字节顺序→本地字节顺序(32bits)2.7.5 客户端软件设计2.7.5.1 解析服务器IP地址由于客户端可能使u用域名或IP地址来标识服务器，而IP协议需要32位的二进制IP地址，所以需要将域名或IP地址转换为32位的IP地址。 函数inet_addr() 实现点分十进制IP地址到32位IP地址转换 函数gethostbyname() 实现域名到32位IP地址转换，返回一个指向结构hostent的指针以上两个函数得到的已经是网络字节顺序，可以直接使用。2.7.5.2 解析服务器端口号客户端还可能使用服务名(如HTTP)标识服务器端口，因此需要将服务名转换为熟知端口号。 函数getservbyname()，返回一个指向结构servent的指针2.7.5.3 解析协议号客户端可能使用协议名(如:TCP)指定协议，因此需要将协议名转换为协议号(如：6) 函数getprotobyname()实现协议名到协议号的转换，返回一个指向结构protoent的指针2.7.5.4 TCP/UDP客户端软件流程TCP： 确定服务器IP地址与端口号 创建套接字 分配本地端点地址(IP地址+端口号)——不需要设计软件时手动来做，系统自动完成 连接服务器(套接字)——connect() 遵循应用层协议进行通信——根据协议确定客户端和服务器哪方先发信息 关闭/释放连接UDP： 确定服务器IP地址与端口号——并非只是每次的第一步做，之后可能每次都需要做 创建套接字 分配本地端点地址(IP地址+端口号)——自动完成 指定服务器端点地址，构造UDP数据报——connect()，构造的UDP数据报可以发给不同的服务器，此时需要重复做第一步 遵循应用层协议进行通信——一定是UDP客户端先给服务器发信息 关闭/释放套接字2.7.6 服务器软件设计 循环无连接(Iterative connectionless)服务器，基本流程： 创建套接字 绑定端点地址(INADDR_ANY+端口号) 反复接收来自客户端的请求 遵循应用层协议，构造响应报文，发送给客户 数据发送： 服务器端不能使用connect()函数 无连接服务器使用sendto()函数发送数据报 获取客户端点地址： 调用recvfrom()函数接收数据时，自动提取 循环面向连接(Iterative connection-oriented)服务器，基本流程： 创建(主)套接字，并绑定熟知端口号； 设置(主)套接字为被动监听模式，准备用于服务器； 调用accept()函数接收下一个连接请求(通过主套接字)，创建新套接字用于与该客户建立连接； 遵循应用层协议，反复接收客户请求，构造并发送响应(通过新套接字)； 完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3. 并发无连接(Concurrent connectionless)服务器，基本流程： 主线程1：创建套接字，并绑定熟知端口号； 主线程2：反复调用recvfrom()函数，接收下一个客户请求，并创建新线程处理该客户响应； 子线程1：接收一个特定请求； 子线程2：依据应用层协议构造响应报文，并调用sendto()发送； 子线程3：退出(一个子线程处理一个请求后即终止)。 并发面向连接(Concurrent connection-oriented)服务器，基本流程： 主线程1：创建(主)套接字，并绑定熟知端口号； 主线程2：设置(主)套接字为被动监听模式，准备用于服务器； 主线程3：反复调用accept()函数接收下一个连接请求(通过主套接字)，并创建一个新的子线程处理该客户响应； 子线程1：接收一个客户的服务请求(通过新创建的套接字)； 子线程2：遵循应用层协议与特定客户进行交互； 子线程3：关闭/释放连接并退出(线程终止)。 客户端与服务器的实现范例参见PPT" }, { "title": "1 概述", "url": "/posts/1-Introdution/", "categories": "学习笔记, 计算机网络", "tags": "计算机网络, HITCN, 2020秋", "date": "2020-12-08 10:56:33 +0800", "snippet": "1.1 计算机网络1.1.1 计算机网络与Internet计算机网络：计算机网络就是互连的、自治的计算机集合。 自治：无主从关系 互连：互联互通——通信链路。通过交换网络互连主机，在距离远、数量大时保证互连。Internet：全球最大的互联网络。ISP(Internet Service Provider) 网络互连的“网络之网络” 数以百万计的互连的计算设备集合： 主机 (hosts) = 端系统 (end systems) 运行各种网络应用 通信链路：光纤, 铜缆, 无线电, 卫星…… 分组交换： 转发分组 (数据包)：路由器 (routers) 和交换机 (switches) 为网络应用提供通信服务的通信基础设施：Web, VoIP, email, 网络游戏, 电子商务, 社交网络, … 为网络应用提供应用编程接口 (API)：支持应用程序“连接”Internet，发送/接收数据。提供类似于邮政系统的数据传输服务1.1.2 网络协议 协议是计算机网络有序运行的重要保证 任何通信或信息交换过程都需要规则 协议规范了网络中所有信息发送和接收过程网络协议(network protocol)：简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作” (actions)协议的三要素： 语法 (Syntax)：数据与控制信息的结构或格式；信号电平 语义 (Semantics)：需要发出何种控制信息；完成何种动作以及做出何种响应；差错控制 时序 (Timing)：事件顺序；速度匹配1.2 计算机网络结构1.2.1 计算机网络结构 计算机网络由三部分构成：网络边缘、接入网络、网络核心 网络边缘：主机、 网络应用 主机(端系统)：位于“网络边缘”，运行网络应用程序。如：Web, email 客户/服务器(client/server)应用模型：客户发送请求，接收服务器响应。如：Web应用，文件传输FTP应用 对等(peer-peer, P2P)应用模型：无 (或不仅依赖)专用服务器，通信在对等实体之间直接进行。如：Gnutella, BT, Skype, QQ 接入网络，物理介质：有线或无线通信链路 通过接入网络将网络边缘接入核心网 (边缘路由器) 带宽：数据传输速率。 典型的接入网络： 数字用户线路 (DSL)：利用已有的电话线连接中心局的DSLAM，一般上传下载带宽是不同的，因此被称为非对称数字用户线路 电缆网络：频分多路复用——在不同频带 (载波)上传输不同频道。各家庭共享家庭至电缆头端的接入网络，不同于DSL的独占至中心局的接入。 典型家庭网络的接入 机构 (企业)接入网络 (Ethernet)：端系统通常直接连接以太网交换机 (switch) 无线接入网络：通过共享的无线接入网络 (基站 (base station)或称为“接入点 (access point)”) 连接端系统与路由器 无线局域网 (LANs)：同一建筑物内 (30m)；802.11b/g (WiFi)：11Mbps、54Mbps传输速率 广域无线接入：通过电信运营商 (蜂窝网) ，接入范围在几十公里；3G、 4G: LTE、移动互联网；1 Mbps、10 Mbps、100Mbps 网络核心 (核心网络)：互联的路由器 (或分组转发设备)；网络之网络 网络核心的关键功能：路由+转发 网络核心解决的基本问题：通过数据交换 (Data Exchange)实现数据从源主机通过网络核心送达目的主机 1.2.2 Internet结构端系统通过接入ISP (access ISPs )连接到Internet：家庭、公司和大学ISPs接入ISP必须进一步互连：这样任意两个主机才可以互相发送分组 通过 IXP (Internet exchange point) 互联 通过对等链路 (peering link) 互联可能出现区域网络 (regional networks)连接接入ISP和运营商ISP内容提供商网络(content provider networks，如： Google、Microsoft等) 可能运行其自己的网络，并就近为端用户提供服务、内容1.3 数据交换1.3.1 电路交换最典型电路交换网络：电话网络电路交换的三个阶段：建立连接 (呼叫/电路建立)；通信；释放连接 (拆除电路)电路交换的显著特点是独占资源的电路交换网络通过多路复用 (Multiplexing)共享中继线1.3.2 多路复用多路复用(Multiplexing)：链路/网络资源 (如带宽)划分为“资源片”，将资源片分配给各路“呼叫” (calls)，每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”(idle) (无共享)典型多路复用方法： 频分多路复用 (frequency division multiplexing-FDM )：频分多路复用的各用户占用不同的带宽 (Hz) 资源，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 时分多路复用 (time division multiplexing-TDM )：将时间划分为一段段等长的时分复用帧 (TDM 帧)，每个用户在每个 TDM 帧中占用固定序号的时隙。每用户所占用的时隙周期性出现。时分复用的所有用户是在不同的时间占用相同的频带宽度。 波分多路复用 (Wavelength division multiplexing-WDM)：波分复用就是光的频分复用* 码分多路复用 (Code division multiplexing-CDM )：每个用户分配一个唯一的m bit码片序列(chipping sequence)，其中“0”用“-1”表示、“1”用“+1”表示，例如：S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)；各用户使用相同频率载波，利用各自码片序列编码数据，编码信号 = (原始数据) × (码片序列) 条件：各用户码片序列相互正交 各用户生成编码信号以后，在信道中会相互叠加形成新的传输信号，在接收端则可以使用想接收用户的码片解码，如下 1.3.3 报文交换报文：源 (应用)发送信息整体。比如：一个文件报文交换直接整体发送一个文件1.3.4 分组交换分组：报文分拆出来的一系列相对较小的数据包分组交换需要报文的拆分与重组，产生额外开销。分组交换不像电路交换会申请特定的独占的链路资源，所以存在多个主机共享同一段链路资源 (分组序列不确定，按需共享链路)，因此称其为统计多路复用 (Statistical Multiplexing)报文交换与分组交换均采用存储-转发 (store-and-forward)交换方式。区别： 报文交换以完整报文进行“存储-转发” 分组交换以较小的分组进行“存储-转发”·1.3.5 性能比较1.3.5.1 报文交换 vs 分组交换发送主机：接收应用报文 (消息) 拆分为较小长度为 L bits的分组 (packets)；在传输速率为R的链路上传输分组分组传输延迟 (时延) (delay)= L bits / R (bits/sec) 报文交换： 报文长度为M bits 链路带宽为R bps 每次传输报文需要M/R秒 跳步数：h 路由器数：n 报文交付时间：T = hM / R = (n+1)M / R 分组交换： 报文被拆分为多个分组 分组长度为L bits 每个分组传输时延为L/R秒 跳步数：h 路由器数：n 报文交付时间：T = M / R + (h-1)L / R = M / R + nL / R 1.3.5.2 分组交换 vs 电路交换分组交换允许更多用户同时使用网络——网络资源充分共享分组交换适用于突发数据传输网络，资源充分共享，简单、无需呼叫建立，但可能产生拥塞 (congestion)：分组延迟和丢失，所以需要协议处理可靠数据传输和拥塞控制。1.4 计算机网络性能速率即数据率(data rate)或称数据传输速率或比特率(bit rate)：单位时间 (秒)传输信息 (比特)量，计算机网络中最重要的一个性能指标。单位：b/s (或bps)、kb/s、Mb/s、Gb/s k=103、M=106、G=109“带宽” (bandwidth) 原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹 (Hz)。网络的“带宽”通常是数字信道所能传送的“最高数据率”，单位：b/s (bps)延迟/时延(delay或latency)，四种分组延迟： d~proc~： 结点处理延迟 (nodal processing delay) 差错检测 确定输出链路 通常&amp;lt; msec d~queue~： 排队延迟 (queueing delay) 等待输出链路可用 取决于路由器拥塞程度 R： 链路带宽(bps)、L： 分组长度 (bits)、a： 平均分组到达速率，流量强度 (traffic intensity)= La/R La/R ~ 0： 平均排队延迟很小 La/R -&amp;gt; 1： 平均排队延迟很大 La/R &amp;gt; 1： 超出服务能力，平均排队延迟无限大！ d~trans~： 传输延迟 (transmission delay)——车队通过收费站时间 L： 分组长度(bits) R： 链路带宽 (bps) d~trans~ = L/R d~prop~： 传播延迟 (propagation delay)——每台车从第一个收费站跑到第二个收费站用时 d： 物理链路长度 s： 信号传播速度 (~2×108 m/sec) d~prop~ = d/s 时延带宽积 = 传播时延 * 带宽 = d~prop~ * R (bits) 链路的时延带宽积又称为以比特为单位的链路长度分组丢失 (丢包)：队列缓存容量有限，分组到达已满队列将被丢弃 (即丢包)，丢弃分组可能由前序结点或源重发 (也可能不重发)丢包率= 丢包数 / 已发分组总数吞吐量 (Throughput)：表示在发送端与接收端之间传送数据速率 (b/s) 即时吞吐量： 给定时刻的速率 平均吞吐量： 一段时间的平均速率 瓶颈链路 (bottleneck link)：端到端路径上，限制端到端吞吐量的链路。1.5 计算机网络体系结构网络体系结构是从功能上描述计算机网络结构，计算机网络体系结构简称网络体系结构 (network architecture) 是分层结构，每层遵循某个/些网络协议完成本层功能，计算机网络体系结构是计算机网络的各层及其协议的集合，体系结构是一个计算机网络的功能层次及其关系的定义，体系结构是抽象的。实体(entity) 表示任何可发送或接收信息的硬件或软件进程。协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”。任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的”。下层协议的实现对上层的服务用户是透明的。同系统的相邻层实体间通过接口进行交互，通过服务访问点 SAP(Service Access Point)，交换原语，指定请求的特定服务。1.5.1 OSI参考模型开放系统互连 (OSI)参考模型是由国际标准化组织 (ISO) 于1984年提出的分层网络体系结构模型，目的是支持异构网络系统的互联互通。OSI参考模型解释的通信过程如下图，可以看出应用层、表示层、会话层、传输层是端到端的。数据封装：增加控制信息，构造协议数据单元 (PDU)。控制信息主要包括: 地址（Address）: 标识发送端/接收端 差错检测编码（Error-detecting code）: 用于差错检测或纠正 协议控制（Protocol control）: 实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS）、 和安全控制等七层功能： 应用层（Application）：支持用户通过用户代理（如浏览器）或网络接口使用网络（服务） 表示层（Presentation）：处理两个系统间交换信息的语法与语义（syntax and semantics ）问题 数据表示转化：转换为主机独立的编码 加密/解密 压缩/解压缩 会话层（Session）：对话控制（dialog controlling）：建立、维护 同步：在数据流中插入“同步点” 最“薄”的一层 传输层（Transport）：负责源-目的（端-端）的（进程间） 完整报文传输 分段与重组 SAP寻址：确保将完整报文提交给正确进程，如端口号 连接控制 流量控制 差错控制 网络层（Network）：负责源主机到目的主机数据分组（packet）传输，可能穿越多个网络 逻辑寻址（Logical addressing）：全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址 路由（Routing）：路由器（或网关）互连网络，并路由分组至最终目的主机 转发（Forwarding） 数据链路层（Data link）：负责结点-结点（node-to-node）数据传输 组帧（Framing） 物理寻址（Physical addressing）：在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端 流量控制（Flow control）：避免淹没接收端 差错控制（Error control）：检测并重传损坏或丢失帧，并避免重复帧 访问控制（Access control）：在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权 物理层（Physical） 接口特性：机械特性、电气特性、功能特性、规程特性 比特编码 数据率 比特同步：时钟同步 传输模式：单工（Simplex）——单向传输、半双工（half-duplex）——交替双向通信、全双工（full-duplex）——同时双向通信 1.5.2 TCP/IP参考模型在TCP/IP参考模型下，是网络接口无关的，只要能封装成IP数据报，即可在网际传输。1.5.3 五层参考模型 综合 OSI 和 TCP/IP 的优点 应用层: 支持各种网络应用，FTP, SMTP, HTTP 传输层: 进程-进程的数据传输，TCP, UDP 网络层: 源主机到目的主机的数据分组路由与转发，IP协议、路由协议等 链路层: 相邻网络元素（主机、交换机、路由器等）的数据传输，以太网（Ethernet）、802.11 (WiFi)、PPP 物理层:比特传输5层参考模型下的网络通信过程与数据封装1.6 计算机网络发展历史略" }, { "title": "图灵机 (Turing Machine)", "url": "/posts/4-TuringMachine/", "categories": "学习笔记, 形式语言与自动机", "tags": "形式语言与自动机, HIT-FLAA, 2020春", "date": "2020-07-15 12:33:48 +0800", "snippet": "1 形式化定义图灵机(Turing Machine)：TM是一个七元组$P=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,B,\\,F)$，其中， $Q$ 是有限的状态集； $\\Sigma$ 是有限的输入字符集； $\\Gamma$ 是有限的纸带字符集； $\\delta$ 是状态转移函数，是一个映射 $Q\\times \\Gamma \\Rightarrow Q\\times \\Gamma \\times {R,L}$，状态转移函数 $\\delta(q, X ) = (p, Y, D)$ 表示状态从q到p，读写头所指的字符X被改为Y，读写头向D方向移动； $q_0$ 是初始状态； $B$ 是空格符，一个特殊的符号； $F$ 是终结状态集；例：构造TM识别 $L = { a^nb^nc^n | n \\ge 0 }$初始状态：最终状态：构造的图灵机：$M=({q_0,q_1,q_2,q_3,q_4},{a,b,c},{a,b,c,B,X,Y,Z},\\delta, q0,B,{q_4})$ 上图表示的是确定的图灵机，删除 $q_6$ 得到的是不确定的图灵机，也可以识别语言 L1 瞬时描述用 $X_1… X_{i-1}qX_i X_{i+1}…X_n$ 的形式表示图灵机在某一时刻所处的格局，q表示图灵机所处的状态，读写头指向的位置为状态符q右侧的字符，即 $X_i$ 。如上的图灵机识别字符串 $aabbcc$ 的过程描述如下：$q_0aabbcc┝Xq_1abbcc┝ Xaq_1bbcc┝XaYq_2bccXaYbq_2cc┝X aYq_3bZc┝X aq_3YbZc┝Xq_3aYbZc┝q_3XaYbZc┝Xq_0aYbZc┝XXq_1YbZc┝XXYq_1bZc ┝XXYYq_2Zc┝XXYYZq_2c┝XXYYq_3ZZ┝…┝XXYYZZq_3$2 停机读了某个字符X之后，图灵机仍在状态q，不做任何动作，没有进行状态转移，简言之就是在状态q读入X没有相应的状态转移函数 。 不知道读写头向左/右移动； 不知道X应该被改成什么； 不知道转移到哪个状态；2 构造例：设计一个TM计算两个正整数x和y的和，即 x+y。思路：用x个1表示x，用y个1表示y，中间用0分隔。运算过程为，从左到右移动读写头，经过0则把它改成1，右移到B则左移一次，把1改成B，结束。状态转移图如下：例：设计TM计算 $f(w)=ww，w\\in {1}^+$ 。思路：用0分隔原来的w和复制得到的w，读一个1写一个1，并把读过的1改成X，复制结束后把X改回1，最后把左边的1右移一格，或者把右边的1左移一格即可（使用上题的方式）。例：设计TM计算 $f(w)=ww，w\\in {0,1}^+$ 。思路：用字符A分隔原来的w和复制得到的w，用状态表示所读的是1还是0，读0则到q0状态，读1则到q1状态，然后根据所处的状态决定是写0还是写1。其余的参照上题的思路。例：设计一个TM计算两个正整数m和n的积，即 m×n。思路：做m个n相加，每加一个n，抹掉一个m的1，直到m的1全部被抹除。最后把与结果无关的全都抹除。3 双栈自动机 (Two Stack Machine)状态转移函数：$\\delta(q, a, X , Y ) = (p, \\alpha, \\beta)$ 图示：例：构造双栈自动机识别 $L={a^nb^nc^n| n\\ge 0}$解：就是把所有的a先压栈，读b把b压栈的同时将a弹栈，最后用c把b弹栈4 图灵机编码1 字符串排序枚举对 $w\\in {0,1}^*$ 按照长度排序：$\\varepsilon,0,1,00,01,10,11,000,001,010,011,…$把上面的每个字符串前面用1连接得到：$1,10,11,100,101,110,111,1000,1001,1010,1011,…$则可发现，若把 $1w$ 视为二进制数，则如果 $w$ 是第 $i$ 个字符串就有 $1w=i$2 编码对于TM $M = (Q, {0,1}, \\Gamma, \\delta, q_1, B, {q_2})$，其中 $Q ={q_1,q_2, …,q_r}$，$\\Gamma={X_1,X_2,X_3, …,X_s}$，并规定 $X_1=0， X_2=1，X_3=B，D_1=L，D_2=R$，$q_1$ 是初始状态，$q_2$ 是终结状态。将转移函数编码为：$\\delta (q_i, X_j) = (q_k, X_m, D_n)\\Rightarrow 0^i10^j10^k10^m10^n$。用 1 隔开则M可编码为：$C_111 C_211 C_311 … C_{n-1}11 C_n$，其中的 $C_i$ 表示状态转移函数的编码。用 11 隔开 $C_i$ 之间是无序的，所以一个TM可以有不同的编码例：编码如下TM解：$\\delta(q_1,0)=(q_3,0,\\rightarrow) \\Rightarrow 010100010100\\ \\delta(q_3,1) =(q_3,1,\\rightarrow)\\Rightarrow 0001001000100100\\ \\delta(q_3,B) =(q_2,B,\\rightarrow)\\Rightarrow 00010001001000100$故 $TM \\Rightarrow 010100010100 \\;11\\; 0001001000100100 \\;11\\; 00010001001000100$因为图灵机编码成了01字符串，而01字符串是可以枚举的，于是我们就可以称被编码的图灵机为第 i 个图灵机，记为 $M_i$ 。5. TM接受的语言1 递归可枚举语言能够由图灵机接受的语言称为递归可枚举语言(recursively enumerable language)：$L={w\\;|\\; q_0w┝^* \\alpha p\\beta,\\; p\\in F,\\; \\alpha,\\;\\beta\\in \\Gamma^*}$ 所有的正则语言都是递归可枚举语言，所有的上下文无关语言都是递归可枚举语言。2 非递归可枚举语言定理：$L_d={ w_i \\;|\\; w_i \\in L(M_i) }$ 就是一个非递归可枚举语言(not-recursively enumerable language)，即没有TM接受它。证明：假设 $L_d$ 是以一个TM $M$ 的接受的语言 $L(M)$，则我们可以假设 $M$ 的编码为 $w_i$ ，即 $M=M_i$ 。然后判断 $w_i$ 是否在 $L_d$ 里： $w_i \\in L_d$：由假设可知，$M_i$ 接受 $L_d$，则一定接受其中的每个字符串，可得 $M_i$ 接受 $w_i$，由 $L_d$ 定义进而得 $w_i \\notin L_d$； $w_i \\notin L_d$：由假设可知，$M_i$ 接受的是 $L_d$，由于 $w_i \\notin L_d$ 则 $M_i$ 不接受 $w_i$，由 $L_d$ 定义进而得 $w_i \\in L_d$；所以推出矛盾，假设错误。3 递归语言如果存在TM $M$ 接受 $L$ 且满足下面两个条件，则称 $L$ 是递归语言 (Recursive languages)。 $w \\in L\\Rightarrow M$ 接受 $w$ 并停机 (停在终结状态)； $w \\notin L\\Rightarrow M$ 停机 (停在非终结状态)；定理：如果 $L$ 是递归语言，那么 $\\overline L$ 也是。证明：假设 $L=L(M), M=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,B,\\,F)$，令 $\\overline M=(Q\\cup{r},\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,B,\\,{r})$，其中 r 是一个新的状态，不在Q中； 对于任意的 $q\\in Q-F$ 和 $a\\in \\Sigma$，如果 $\\delta(q,a)=\\phi$，则有 $\\delta(q,a)=(r,a,\\rightarrow)$；定理：如果 $L$ 和 $\\overline L$ 都是递归可枚举语言，那么 $L$ 就是递归语言。证明：假设 $M_1=(Q_1,\\,\\Sigma,\\,\\Gamma,\\,\\delta_1,\\,q_1,B,\\,F_1), M_2=(Q_2,\\,\\Sigma,\\,\\Gamma,\\,\\delta_2,\\,q_2,B,\\,F_2)$ 分别接受 $L$ 和 $\\overline L$，则令 $M = (Q_1\\times Q_2, \\Sigma,\\,\\Gamma, \\delta, (q_1,q_2), B, F_1\\times (Q_2-F_2))，\\delta((q,a),(a,b))=(\\delta_1(p,a),\\delta_2(q,b))$ 即可用递归的方式接受 $L$ ，也就是读 $L$ 中的 $w$ 停在终结状态，读 $\\overline L$ 中的 $w$ 停在非终结状态。 这个定理证明的时候构造的是一个有两个tape的图灵机。4 通用语言一个语言 $L$ ，它是递归可枚举的但不是递归的，即如果 $w\\in L$ 则对应的 $M$ 接受它，但如果 $w\\notin L$ 则 $M$ 不接受它且不会停机，则称它为通用语言 (Universal language)。$L_u = { (M,w) | w \\in L(M) }$ 就是一个通用语言，其中 $M$ 是对应图灵机的编码，$w$ 是图灵机接受的字符串，连接成 $Mw$，记为 $(M,w)$。通用图灵机：四条tape，以 $L(M) = {0}{1}^*$ 为例 Tape1：图灵机的编码+111+接受的字符串；例：010100010100 11 0001001000100100 11 00010001001000100 111 011 Tape2：接受的字符串编码；例：10100100，以1开头，用一个0表示0，两个0表示1 Tape3：图灵机的状态；例：0，用0的个数表示状态 Tape4：模拟图灵机的处理过程；5 语言的范畴6 乔姆斯基文法乔姆斯基文法一共分为四型： Type 0：短语文法 phrase structure grammar(PSG) —— 没有任何约束 $\\quad\\alpha \\rightarrow \\beta;\\;\\; \\alpha\\in(V\\cup T)^V (V\\cup T)^, \\beta\\in(V\\cup T)^*$ Type 1：上下文有关文法 context sensitive grammar(CSG) —- A左右为约定的字符串 $\\quad\\alpha A\\beta \\rightarrow \\alpha\\omega\\beta;\\;\\; A\\in V,\\; \\alpha,\\omega,\\beta\\in(V\\cup T)^*$ Type 2：上下文无关文法 context free grammar(CFG) —- A左右都为空串 $\\quad A\\rightarrow \\omega;\\;\\; A\\in V,\\;\\omega\\in(V\\cup T)^*$ Type 3：正则文法 regular grammar(RG) —- A只能生成终结符或有一个变元且都在左(右)侧的式子 右线性文法 $A \\rightarrow \\alpha|\\alpha B;\\;\\; A,B\\in V,\\;\\alpha\\in T^$ 或左线性文法 $A \\rightarrow \\alpha|B\\alpha;\\;\\; A,B\\in V,\\;\\alpha\\in T^$ 上下文有关文法对应上下文有关语言和线性有界自动机 (把图灵机中的空格符用 “[” 和 “]” 替换，处理的过程中读写头不能越过它们限定的范围)。" }, { "title": "上下文无关文法和下推自动机", "url": "/posts/3-CFGandPDA/", "categories": "学习笔记, 形式语言与自动机", "tags": "形式语言与自动机, HIT-FLAA, 2020春", "date": "2020-07-13 22:50:28 +0800", "snippet": "1 上下文无关文法 (CFG)1 形式化定义上下文无关文法 (Context-Free Grammars)：CFG是一个四元组，如：$G=(V,T,S,P)$，其中 $V$：变元的集合，是一个有限集；（变量） $T$：终结符的集合，是一个有限集，且 $V \\cap T = \\phi$；（值） $S$：开始变元，$S \\in V$； $P$：产生式的集合，是一个有穷集，其中的每个元素都有形式：$A \\rightarrow \\alpha$，其中 $A \\in V, \\alpha \\in (V \\cup T)^*$派生：由产生式生成字符串的过程。 最左派生：每次选取派生式的最左的变元派生替换。 最右派生：每次选取派生式的最右变元派生替换。 例如：$L=\\{a^{2n}b^m | n \\ge 0, m \\ge 0 \\}$ 的产生式为：$S\\rightarrow AB,\\, A\\rightarrow \\varepsilon | aaA,\\, B\\rightarrow \\varepsilon | Bb$ 对于字符串 $w=aabb$ 来说，派生式如下： $S\\Rightarrow AB \\Rightarrow aaAB \\Rightarrow aaABb \\Rightarrow aaBb \\Rightarrow aaBbb \\Rightarrow aabb$ 最左派生：$S\\Rightarrow AB\\Rightarrow aaAB\\Rightarrow aaB\\Rightarrow aaBb\\Rightarrow aaBbb \\Rightarrow aabb$ 最右派生：$S\\Rightarrow AB\\Rightarrow ABb\\Rightarrow ABbb\\Rightarrow Abb\\Rightarrow aaAbb\\Rightarrow aabb$ 上下文无关语言 (CFL)：$G=(V,T,S,P)$ 是一个CFG，则 $L(G)=\\{w\\;|\\;w\\in T^* \\; and\\; S \\stackrel{*} {\\Longrightarrow} w\\}$2 语法分析树语法分析树：$G=(V,T,S,P)$ 是一个CFG，一个G的语法分析树如下： 每个内节点都标了一个 $V$ 中的变元； 每个叶节点都标了一个 $T\\cup \\{\\varepsilon\\}$ 中的符号，所有被 ε 标记的叶节点都是其父节点的唯一子节点； 如果一个内节点标记为A，它的子节点(从左到右)标记为 $x_1,x_2, …, x_k$，则 $A\\rightarrow x_1,x_2, …, x_k \\in P$例：$L=\\{ w\\; |\\; w\\in \\{0,1\\}^*\\; and\\; w = w^R \\}$ 产生式为 $S \\rightarrow \\varepsilon\\, |\\, 0\\, |\\, 1\\, |\\, 0S0\\, |\\, 1S1$ 两个语法分析树如下：3 二义性对于一个CFG：$G=(\\{E,I\\}, \\{a, b, (, ), +, \\}, E, P)$，产生式为 $E\\rightarrow I\\; |\\; E+E |\\;EE\\;|\\;(E)$，$ I\\rightarrow a\\;|\\;b$对于字符串 $w=a+a*a$ 的两种最左派生如下：$E\\Rightarrow EE\\Rightarrow E+EE\\Rightarrow I+EE\\Rightarrow a+EE\\Rightarrow a+aaE\\Rightarrow E+E\\Rightarrow I+E\\Rightarrow a+E\\Rightarrow a+EE\\Rightarrow a+a*a$对应的语法分析树如下，发现一个先算的是加法，一个先算的是乘法，出现了歧义。重新构造产生式以消除歧义：先算乘法的：$E\\rightarrow I\\; |\\; E+E\\; |\\; E*E\\; |\\; (E),\\; I\\rightarrow a\\; |\\; b$先算加法的：$E\\rightarrow T\\; |\\; E+T,\\; T\\rightarrow F\\; |\\; T*F,\\; F\\rightarrow I\\; |\\;(E),\\; I\\rightarrow a\\;|\\;b\\;|\\;Ia\\;|\\;Ib$ 定义同样的语言可以有多个文法，如果一个CFL的所有文法都是歧义的，那么它是固有二义性的4 CFG的化简 去掉 ε 产生式； 去掉单元产生式； 去掉无用的产生式；5 乔姆斯基范式(CNF)乔姆斯基范式(Chomsky Normal Form)：一个CFG的所有的产生式都有如下两种形式之一： $A\\rightarrow BC$，$A,B,C\\in V$ $A\\rightarrow a$，$a\\in T$CFG可以转换为CNF的形式，如下例子。例：将 $S\\rightarrow ABa , A\\rightarrow aab , B \\rightarrow Ac$ 转化为CNF的形式解：$S\\rightarrow AC,A\\rightarrow DE,B\\rightarrow AF,C\\rightarrow BD,D\\rightarrow a,F\\rightarrow c,E\\rightarrow DG,G\\rightarrow b$2 下推自动机(PDA) 由于FA有局限性，可以识别$M=\\{0^n1^m | n \\ge 0, m \\ge 0 \\}$，但不能识别$L=\\{ 0^n1^n | n \\ge 0 \\}$，所以有了PDA1 形式化定义下推自动机(Pushdown Automata)：PDA是一个七元组$P=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,\\,z_0,\\,F)$，其中， $Q$ 是有限的状态集； $\\Sigma$ 是有限的输入字符集； $\\Gamma$ 是有限的栈字符集； $\\delta$ 是状态转移函数，是一个映射 $Q\\times (\\Sigma\\cup\\{\\varepsilon\\})\\times \\Gamma \\Rightarrow 2^Q\\times \\Gamma^*$； $q_0$ 是初始状态； $z_0$ 是初始栈符，表示栈是空的； $F$ 是终结状态集；例：构造PDA识别 $L=\\{ww^R|w\\in\\{0,1\\}^*\\}$解：第一步，把 $w$ 入栈\\(\\delta(q,0,z_0)=(q,0z_0),\\quad \\delta(q,1,z_0)=(q,1z_0)\\\\\\delta(q,0,0)=(q,00),\\quad \\delta(q,1,0)=(q,10)\\\\\\delta(q,0,1)=(q,01),\\quad \\delta(q,1,1)=(q,11)\\)第二步，从栈中弹出 $w^R$\\(\\delta(q,1,1)=(p,\\varepsilon),\\quad \\delta(q,0,0)=(q,\\varepsilon)\\\\\\delta(p,1,1)=(p,\\varepsilon),\\quad \\delta(p,0,0)=(q,\\varepsilon)\\)第三步，转移到终结状态 $\\delta(p,\\varepsilon, z_0)=(r,z_0)$图示如下，这是一个不确定的PDA2 确定的PDA如果一个PDA $P=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,\\,z_0,\\,F)$ 是确定的，那么它满足下面的条件： $\\forall q\\in Q,\\forall a\\in \\Sigma \\cup \\{\\varepsilon\\},\\forall X\\in \\Gamma$，$\\delta(q,a,X)$ 的结果是唯一的； $\\delta(q,a,X)$ 和 $\\delta(q,\\varepsilon ,X)$ 只能有一个有定义，因为对于状态$q$来说，读 $\\varepsilon$ 意味着不读 $a$，而另一个意味着读 $a$，所以读与不读就产生了不确定性。例：构造确定的PDA识别 $L = \\{ 0^n1^n | n &amp;gt; 0 \\}$解：这就是一个DPDA3 PDA的瞬时描述用一个三元组 $(q,w,\\alpha)$ 来描述一个PDA在某一时刻的格局，其中， $q$ 是PDA此时的状态； $w$ 是剩余的待读入字符串； $\\alpha$ 是栈中的字符串。例：用格局序列描述2中构造的 $L = \\{ 0^n1^n | n &amp;gt; 0 \\}$ 的PDA接受 $w=0011$ 的过程。解：$(q,0011,z_0)┝(q,011,0z_0)┝(q,11,00z_0)┝(p,1,0z_0)┝(p,\\varepsilon,z_0)┝(r,\\varepsilon,z_0)$简记为 $(q,0011,z_0)┝^* (r,\\varepsilon,z_0)$4 PDA接受的语言能够由PDA接受(CFG构造)的语言称为上下文无关语言(CFL)，PDA可以用两种方式描述接受语言： 用终结状态来描述：$L(P) = \\{w\\,|\\, (q_0, w, z_0)┝^* (q, \\varepsilon, \\alpha), q\\in F\\}$ 用空栈状态来描述：$N(P) = \\{w\\,|\\, (q_0, w, z_0)┝^* (q, \\varepsilon, \\alpha)\\}$ 这两种描述方式是等价的，即 $L(P) \\Leftrightarrow N(p)$例如2中构造的 $L = \\{ 0^n1^n | n &amp;gt; 0 \\}$ 的PDA就是用终结状态接受的，也可用空栈状态来描述，如下但是并不是所有的PDA都可以用两种方式构造 (针对DPDA)，当 $L$ 可以被终结状态的DPDA接受并且 $L$ 有前缀性的时候，$L$ 才能被空栈状态的DPDA接受。 语言的前缀性：该语言中没有两个不同的字符串x和y，使得x是y的前缀。 如：语言 0* 就没有前缀性，因为0是00的前缀。3 CFG和PDA的等价性对于一个给定的上下文无关语言 $L$，存在一个CFG生成 $L$，且存在一个PDA识别 $L$。1 CFG $\\Rightarrow$ PDA把CFG $G=(V,T,S,P)$ 转化为PDA，则对应的PDA为 $B=(\\{q\\},T,V\\cup T,\\delta,q,S,\\{\\,\\})$，其中， $\\delta(q, \\varepsilon, A) =\\{(q, \\alpha ) | A\\rightarrow \\alpha \\in P \\}$ $\\delta(q, a, a) =(q, \\varepsilon)$例：将CFG $G=(\\{S\\},\\{0,1\\}, \\{S\\rightarrow 0S1, S\\rightarrow SS, S\\rightarrow \\varepsilon \\}, S)$ 转化为PDA。解：PDA为 $P=(\\{q\\}, \\{0,1\\}, \\{0,1,S\\}, \\delta, q, S, \\{\\,\\})$，其中 $\\delta$ 定义如下： $\\delta(q,\\varepsilon, S)=\\{(q,0S1), (q,SS), (q,\\varepsilon)\\}$ $\\delta (q,0,0)=\\{(q,\\varepsilon )\\}$ $\\delta (q,1,1)=\\{(q,\\varepsilon )\\}$用图表示该PDA识别字符串 $w=0011$ 的过程：$(q,0011,S)┝(q,0011,0S1)┝(q,011,S1)┝(q,011,0S11)┝(q,11,S11)┝(q,11,11)┝(q,1,1)┝(q,\\varepsilon,\\varepsilon)$对应的CFG派生序列：$S \\Rightarrow 0S1 \\Rightarrow 00S11 \\Rightarrow 0011$ 转化出的PDA实际上是在模拟CFG的派生过程，所以PDA一定能就识别CFG生成的字符串2 PDA $\\Rightarrow$ CFG把PDA $P=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,\\,z_0,\\,F)$ 转化为CFG，则对应的CFG为 $G=(V,\\Sigma,S,R)$，其中， $V$ ：包括开始变元 $S$，这个变元和PDA没有关系，就是强行规定的；还有其他形如 $[qXp]$ 的符号，其中$\\forall q,p \\in Q, X\\in \\Gamma$ 符号 $[qXp]$ 的意义是在 $q$ 状态下，可以使栈中的 $X$ 弹出并转移到 $p$ 状态的字符串，例如有状态转移函数 $\\delta(q_0, \\varepsilon, z_0) = (p, \\varepsilon)$，则 $[q_0z_0p]\\rightarrow \\varepsilon$，于是对于下面 $R$ 的第一条产生式规则，就有$S\\rightarrow [q_0z_0p]$ $R$ ：包括 $\\forall p\\in Q$，$S\\rightarrow [q_0z_0p]$；还有 $[q X r_k]\\rightarrow a[rY_1r_1][r_1Y_2r_2]… [r_{k-1}Y_kr_k]$，对于 $(r, Y_1Y_2…Y_k)\\in \\delta (q,a,X)$ 第一条产生式规则已经在上一条中描述了，下面是关于第二条产生式规则。对于状态转移函数 $\\delta(q, a, X) = (r,Y_1Y_2…Y_k)$，因为 $[qXr_k]$ 表示的是把 $X$ 全pop掉所需要的字符串，而状态转移函数读入字符串 $a$ 之后栈中的元素是 $Y_1Y_2…Y_k$，所以需要把这些元素也pop掉，因此最后的状态就不是 $r$ 而是 $r_k$，而第二条产生式规则的body部分 $a$ 之后的部分就是做这个的。 例：还是用 2.2确定的PDA 中的例子，将其转化成CFG解：$P=(Q,\\,\\Sigma,\\,\\Gamma,\\,\\delta,\\,q_0,\\,z_0,\\,F)\\Rightarrow G=(V,\\Sigma,S,R)$，其中 $V=\\{S,[qz_0q], [qz_0p], [q0q], [q0p], [q1q], [q1p],[pz_0q], [pz_0p], [p0q], [p0p], [p1q], [p1p] \\}$然后根据转移函数导出产生式 $R$ $\\delta (q, 0, z_0) = (q, 0z_0)\\Rightarrow [qz_0r_2]\\rightarrow 0[q0r_1][r_1z_0r_2], \\forall r_1,r_2\\in Q \\Rightarrow[qz_0q] \\rightarrow 0[q0q][qz_0q]\\; |\\; 0[q0p][pz_0q][qz_0p] \\rightarrow 0[q0q][qz_0p]\\; |\\; 0[q0p][pz_0p]$ $\\delta (q, 0, 0) = (q, 00)\\Rightarrow [q0r_2] \\rightarrow 0[q0r_1][r_10r_2], \\forall r_1,r_2\\in Q \\Rightarrow [q0q] \\rightarrow 0[q0q][q0q]\\; |\\; 0[q0p][p0q] [q0p] \\rightarrow 0[q0q][q0p]\\; |\\; 0[q0p][p0p]$ $\\delta(q, \\varepsilon, z_0)=(p,z_0) \\Rightarrow [qz_0r_1] \\rightarrow [pz_0r_1], \\forall r_1\\in Q \\Rightarrow [qz_0q] \\rightarrow [pz_0q][qz_0p] \\rightarrow [pz_0p]$ $\\delta(q, 1, 0) = (p,\\varepsilon) \\Rightarrow [q0p] \\rightarrow 1$ $\\delta(p, 1, 0) = (p,\\varepsilon) \\Rightarrow [p0p] \\rightarrow 1$ $\\delta(p, \\varepsilon, z_0) = (p,\\varepsilon) \\Rightarrow [pz_0p] \\rightarrow \\varepsilon$把得到的产生式整合在一起得到 $R$\\(R = \\\\{\\quad S \\rightarrow [qz_0q]\\,\\, \\|\\,\\, [qz_0p],\\\\[qz_0q] \\rightarrow 0[q0q][qz_0q] \\,\\,\\|\\,\\, 0[q0p][pz_0q],\\\\[qz_0p] \\rightarrow 0[q0q][qz_0p] \\,\\,\\|\\,\\, 0[q0p][pz_0p],\\\\[q0q] \\rightarrow 0[q0q][q0q] \\,\\,\\|\\,\\, 0[q0p][p0q],\\\\[q0p] \\rightarrow 0[q0q][q0p] \\,\\,\\|\\,\\, 0[q0p][p0p],\\\\[qz_0q] \\rightarrow [pz_0q]，\\;[qz_0p] \\rightarrow[pz_0p],\\\\[q0p] \\rightarrow 1,\\; [p0p] \\rightarrow 1,\\; [pz_0p] \\rightarrow \\varepsilon \\quad\\\\}\\)最后把 $R$ 按如下规则化简一下： 消除含有没有终结符的变元的产生式，如：含有 $[pz_0q]$ 的产生式； 消除死循环的产生式，如：$[q0q]$ 的第一个产生式，因为它的第二个产生式由于 $[p0q]$ 满足第一条化简规则，所以它只剩下第一个产生式，所以它死循环了； 消除含有由于前两条规则导致的无用变元的产生式，如：因为 $[q0q]$ 无用，所以含有它的产生式也无用。最终得到\\(R = \\\\{\\quad S \\rightarrow [qz_0p],\\;[qz_0p] \\rightarrow 0[q0p][pz_0p],\\\\[q0p] \\rightarrow 0[q0p][p0p],\\; [qz_0p] \\rightarrow[pz_0p],\\\\[q0p] \\rightarrow 1,\\; [p0p] \\rightarrow 1,\\; [pz_0p] \\rightarrow \\varepsilon \\quad\\\\}\\)看起来不太方便，于是令$A=[qz_0p], B=[q0p], C=[p0p], D=[pz_0p]$，得到$R = \\{ S \\rightarrow A,\\; A\\rightarrow 0BD|D,\\; B\\rightarrow1|0BC,\\; C\\rightarrow1,\\; D\\rightarrow \\varepsilon \\}$再次化简得到：$R = \\{ S\\rightarrow 0B|\\varepsilon,\\; B\\rightarrow 1| 0BC,\\; C\\rightarrow1 \\}$4 上下文无关语言的性质1 泵引理上下文无关语言的泵引理：$L$ 是一个CFL，则 $\\exist n$，对 $\\forall w\\in L$，若 $|w|\\ge n$，则 $w$ 可以划分为 $w=uvxyz$，其中 $|vxy| \\le n$ $|vy| \\ge 1$，(要是vy同时为空就出现 $A\\rightarrow A$ 这种没有意义的产生式了) $uv^ixy^iz\\in L,\\;\\,\\forall i=0,1,2,…$ n的取法：令 $m=|V|$，$k=max\\{ |\\alpha| \\forall A\\rightarrow \\alpha \\}$，则 $n=k^m$派生过程：$S\\stackrel\\Rightarrow uAz \\stackrel\\Rightarrow uvAyz\\stackrel*\\Rightarrow w$，语法解析树如下，对于重复出现的 A 来说，则可用子树的A代替父节点，此时失去的就是一对vy节点。例：证明 $L=\\{ww|w\\in \\{0,1\\}^*\\}$ 不是CFL。解：假设L是CFL。则由泵引理可知，存在一个常数n，对于L中长度不小于n的字符串w就可以划分为五个部分，$w=uvxyz$，其中 $|vxy| \\le n$，$vy \\ne \\varepsilon$，$uv^kxy^kz\\in L$。取 $w=0^n1^n0^n1^n\\in L$，则 $uvxyz=0^n1^n0^n1^n$(如果要推出矛盾，就需要推出 $uxz\\notin L$)。v和y不能同时为空串且 $|vxy| \\le n$，所以它们的取值情况可以分为7种情况，这七种情况又可以分为两类： 第一类：vxy在同一类字符里，即同在开始的n个0、同时在开始的n个1里、同时在结束的n个0里，同时在结束的n个1里。这四种情况是等价的，而显然在第一种情况下有 $uxz\\notin L$，因为开始的0的个数不足n了。 第二类：vxy在连续的两类字符里，即在前半部分的 $0^n1^n$ 中、在中间的 $1^n0^n$ 中、在后半部分的 $0^n1^n$中。这三种情况是等价的，而显然在第一种情况下有 $uxz\\notin L$，因为开始的0和1的个数都不足n了。所有的情况都推出了矛盾，所以假设错误，即 L 不是CFL。2 封闭性CFL在并、连接、星、反转、交、同态、逆同态运算下是封闭的，而在交、补运算下不是封闭的。 对于两个CFL $L_1$ 和 $L_2$，令 $G(L_1)=(V_1,T_1,R_1,S_1), G(L_2)=(V_2,T_2,R_2,S_2)$ 并：$G(L_1 \\cup L_2 ) = (V_1\\cup V_2\\cup \\{S\\},T_1\\cup T_2, R,S)$，$R= \\{S\\rightarrow S_1 | S_2\\} \\cup R_1\\cup R_2$ 连接：$G(L_1 \\cup L_2 ) = (V_1\\cup V_2\\cup \\{S\\},T_1\\cup T_2, R,S)$，$R= \\{S\\rightarrow S_1 S_2\\} \\cup R_1\\cup R_2$ 星：$G(L_1^*) = (V_1,T_1, \\{S_1\\rightarrow S_1S_1|\\varepsilon\\}\\cup R_1,S_1)$ 反转：$G(L_1^R)=(V_1,T_1, \\{A\\rightarrow \\alpha^R|A\\rightarrow \\alpha R_1\\},S_1)$ 交运算不封闭，例如：$L_1 =\\{a^nb^nc^m | n\\ge 0, m\\ge 0\\},\\;L_2 =\\{a^nb^mc^m | n\\ge 0, m\\ge 0\\}$ 是两个CFL，它们的交就是 $L_1 \\cup L_2 =\\{ a^nb^nc^n | n\\ge 0\\}$，这不是CFL，可以按照上面的方式用泵引理证明。 但是一个CFL和一个RL做交运算之后得到的还是CFL，这个条件下它是封闭的。" }, { "title": "正则表达式 (Regular Expression)", "url": "/posts/2-RegularExpression/", "categories": "学习笔记, 形式语言与自动机", "tags": "形式语言与自动机, HIT-FLAA, 2020春", "date": "2020-07-13 22:49:56 +0800", "snippet": "1 正则表达式正则表达式的递归定义： $\\varepsilon$ 是一个正则表达式，表示语言 ${\\varepsilon}$ ; $\\phi$ 是一个正则表达式，表示空语言 $\\phi$ ; $\\forall a \\in \\Sigma$，$a$ 是一个正则表达式, 表示语言 ${a}$ ; 如果 $E$ 和 $F$ 是正则表达式，表示的语言分别是 $L(E)$ 和 $L(F)$，则 $E+F,\\;EF,\\;E^$ 都是正则表达式，分别表示的语言是 $L(E)\\cup L(F),\\; L(E)L(F),\\;(L(E))^$ ; 如果 $E$ 是正则表达式，则 $(E)$ 也是。 运算符优先级：括号 &amp;gt; 星 &amp;gt; 连接 &amp;gt; 加 每一个正则表达式都对应一个正则语言。 例：$L={w\\; |\\; w \\in { 0, 1 }^* \\;and \\;w \\;has \\;no \\;pair \\;of \\;consecutive \\;0’s }$解：$1^* ( 0 1 1^* )^* ( 0 + \\varepsilon)$ 或 $(1+01)^*(0 + \\varepsilon)$ 练习：RegExp for ($\\Sigma={0,1}$) {w | w has exactly a single 1 } {w | w contains 001 } {w | length(w) ≥ 3 and the third symbol is 0 } What language does the RegExp $\\phi^*$ represent ? 2 正则表达式和FA的等价性1 等价性 有穷自动机可以识别正则语言 正则表达式可以生成正则语言 故 有穷自动机和正则表达式等价2 正则表达式$\\Rightarrow$FA正则表达式三种运算的转换：通过空转移 加：R+S 连接：RS 星：R* 例：将 (0+1)*1(0+1) 转化为FA3 FA$\\Rightarrow$正则表达式一些题目可以直接“看“出来，像这样：**状态消去法**但是题目太复杂了，容易丢三落四，于是使用状态消去法。过程如下：然后每次消去一个状态，并将该状态表示的表达式添加在弧上最后弧上得到的表达式就是该FA对应的正则表达式。**归纳法** 将状态标记为 Q={1, 2, 3, ……, n} $R_{ij}^{(k)}\\;其中0 \\le k \\le n$：i 到 j 路径的正则表达式，且路径上没有标记超过 k 的状态过程：按照k=0，i=j 的公式算出不经过中间状态的正则表达式，然后递推套k≥1的公式就行。3 正则语言的性质1 泵引理 (Pumping lemma) 泵引理用于证明某个语言不是正则的，它是正则语言应满足的必要条件 要证明是正则的可以使用构造DFA、NFA、ε-NFA、正则表达式的方法正则语言的泵引理：假设 L 的是正则的，则 $\\exists n$，对 $\\forall w \\in L$，若$|w|\\ge n $，则可将 w 划分为 $w=xyz$，其中 $|xy|\\le n$ $y \\ne \\varepsilon (|y|\\ge 1)$ $\\forall k\\ge 0,\\, xy^kz \\in L$例：证明 $L={0^n1^n \\, | \\, n\\ge 0}$ 不是正则的解：假设它是正则的。由泵引理可知，一定存在一个常数n，对每个长度不小于n的$w\\in L$，可以被分成3的子串 $w=xyz$，且$|xy|\\le n$，$y \\ne \\varepsilon$，$xy^kz \\in L$取 $w=0^n1^n \\in L$，则 $w=0^n1^n=xyz$，由于$|xy|\\le n$，故只能有 $y=0^m$，所以有 $xz=0^{n-|y|}1^n \\in L$。显然xz不是L中的字符串，所以矛盾，所以L不是正则的。 解题方法：上手先假设L是正则的，根据泵引理，选一个字符串w (最好是在开始的某个字符上重复了n次，即最开始是一个 $a^n$)，然后就可以泵掉 |y| 个 a，然后就不属于L了，就推出矛盾2 封闭性正则语言经某些运算后得到的新语言仍是正则语言，称正则语言在这些运算下封闭。 并：$L \\cup M$ 交：$L\\cap M$ 补：$\\overline L$ 差：$L - M$ 反：$L^R$ 闭包(星)：$L^*$ 连接：$LM$ 同态：$h:\\; \\Sigma^* \\rightarrow \\Gamma^*\\qquad h(L)={ h(w)\\, |\\, w \\in L }$ 逆同态" }, { "title": "有穷自动机 (Finite Automata)", "url": "/posts/1-FiniteAutomata/", "categories": "学习笔记, 形式语言与自动机", "tags": "形式语言与自动机, HIT-FLAA, 2020春", "date": "2020-07-13 22:48:55 +0800", "snippet": "1 确定的有穷自动机 (DFA)1 形式化定义确定的有穷自动机 (Deterministic Finite Automata)：DFA是一个五元组，如：$M=(Q,\\; \\Sigma,\\; \\delta,\\;q_0,\\; F)$ ，其中， $Q$ 是有限的状态集，包含DFA中所有的状态； $\\Sigma$ 是有限的输入字符集，也就是DFA的字母表； $q_0$ 是初始状态，并且 $q_0\\in Q$； $F$ 是终结状态的集合，并且 $F \\in Q$； $\\delta$ 是状态转移函数，它是一个映射：$Q \\times \\Sigma \\to Q $ $\\delta$ 要对 $Q$ 中所有的状态和 $\\Sigma$ 中所有的状态的组合都要有定义，也就是笛卡尔积是一个单射例：以自动门为例，使用 $0$ 表示关门信号，$1$ 表示开门信号，$p$ 表示关门状态，$q$ 表示开门状态，则DFA如下： 状态集：${p,\\; q}$ 输入字符集：${0,\\;1}$ 初始状态：$p$ 终结状态：$p$ 状态转移函数：$\\delta$\\(\\delta(p,\\; 0)=p\\\\\\delta(p,\\; 1)=q\\\\\\delta(q,\\; 1)=q\\\\\\delta(q,\\; 0)=p\\)故该DFA的定义为：${ {p,\\; q},\\;{0,\\;1},\\;\\delta,\\;\\;p,\\;{p}}$ 用图表示：单线圈表示普通状态，双线圈表示终结状态，弧表示状态转移函数用表格表示：用 $\\to$ 标识出初始状态，用 $*$ 标识出终结状态   0 1 $\\to*p$ $p$ $q$ $\\qquad q$ $p$ $q$ DFA的目的是区分字符串，于是，按照如上例子构造的DFA就把字符串分成了两类：$L_1={ w\\in{0,1}^* \\;|\\; w \\; end \\; with \\; 0 }\\cup {\\,\\varepsilon\\,} L_2={ w\\in{0,1}^* \\;|\\; w \\; end \\; with \\; 1 }$而 $L_1$ 就是该DFA所接受的字符串集合，就能够判断任意的字符串 $w$，$w \\in L_1$ 是否成立。2 构造构造一个DFA的一般步骤： $w \\in L$ 指的是哪些 $w$ 根据能够产生的字符串划分等价类 根据划分的等价类设置状态 添加状态转移例：构造DFA接受 $L = {x01y\\; |\\; x\\; and\\; y\\; are\\; consists\\; of\\; any\\; number\\; of\\; 0’s\\; and\\; 1’s }$ { ε,0,1,00,==01==,10,11,000,==001==,==010==,100,==011==,==101==,110,111,0000,==0001==,==0010==,==0100==,1000,==0011==,==0101==,==1001==, …} 高亮的是 $L$ 应该接受的字符串 观察这些字符串，有如下发现： 没有0出现的时候，也就是都是1的时候效果是同样的，所以可以划分为一个类； 有0出现，但没有1出现的时候等待1出现就可以了，所以这不同于上一类，又可以划分为一类； 有0出现，有1出现，就有了01子串，而之后无论再出现什么都是会被接受的了，所以这是一类； 根据上面划分的3类可以设置三个状态 $q0,\\;q1,\\;q2$ 添加状态转移得到结果： 定义：若 $ A = (Q, Σ, δ, q_0, F )$ 是一个 DFA，则 D 接受的语言为 $L(A) = {w \\in Σ^∗\\; |\\; \\hatδ(q_0, w) \\in F}$ 。3 正则语言定义：如果存在一个DFA接受 $L$，那么就称 $L$ 是一个正则语言。这类 $L$ 就被称为正则语言。 练习：Construct DFA for following languages : a) ${\\, 0\\, }^*$ b) ${\\,w\\; |\\; w \\in {0,1}^*\\; and\\; begin\\; with\\; 0\\, }$ c) ${\\, w\\;|\\; w\\; consists\\; of\\; any\\; number\\; of\\; 0’s\\; followed\\; by \\;any\\; number \\;of \\;1’s }$ d) ${\\, \\varepsilon\\, }$ e) $\\phi$2 非确定的有穷自动机 (NFA)形式化定义非确定的有穷自动机 (Nondeterministic finite automaton)：NFA是一个五元组，如：$M=(Q,\\; \\Sigma,\\; \\delta,\\;q_0,\\; F)$ ，其中， $Q$ 是有限的状态集，包含NFA中所有的状态； $\\Sigma$ 是有限的输入字符集，也就是NFA的字母表； $q_0$ 是初始状态，并且 $q_0\\in Q$； $F$ 是终结状态的集合，并且 $F \\in Q$； $\\delta$ 是状态转移函数，它是一个映射：$Q \\times \\Sigma \\to 2^Q $ 与DFA唯一的不同就是 $\\delta$ 的象集是 $Q$ 的幂集，结果是一个集合例：构造NFA接受 $L_{x01} = { x01\\; |\\; x \\;is \\;any \\;strings \\;of \\;0’s \\;and \\;1’s\\, }$可以看到，$\\delta(q0,\\, 0)={q0,\\,q1}$，得到的就是一个集合。$\\delta(q1,\\, 0)=\\phi$ 表明NFA不接受这个输入，NFA可以简化这种记法，但DFA不行。定义：若 $A = (Q, Σ, δ, q_0, F )$ 是一个 NFA，则 D 接受的语言为 $L(A) = {w\\; |\\; \\hatδ(q_0, w) \\cap F \\ne \\phi\\,}$ 。 只需要有一条路能够让 $w$ 从 $q_0$ 走到终结状态就可以说NFA接受 $w$。这也是为什么它是非确定的。3 DFA和NFA的等价性如果一个DFA和一个NFA接受的是同一个语言，那么就称这两个FA是等价的。而对于能构造一个DFA来接受它的语言来说，也必定能构造一个NFA来接受它，反之亦然。所以，所有的DFA和对应的NFA都是等价的。 证明： 显然，如果有一个DFA接受L，则必定有一个NFA接受L； 给定一个DFA：$A=(Q_D,\\;\\Sigma,\\;\\delta_D,\\; q_0,\\;F_D)$，构造一个对应的NFA：$B= (Q_N,\\;\\Sigma,\\;\\delta_N,\\;q_0,\\;F_N)$ 则 $Q_N=Q_D$， $\\delta_N(q, a)={\\delta_D(q,\\, a)}$ ， $F_N=F_D$。 再证，如果有一个NFA接受L，则必定有一个DFA接受L。 给定一个NFA：$A= (Q_N,\\;\\Sigma,\\;\\delta_N ,\\; q_0,\\;F_N)$，构造一个对应的DFA：$B=(Q_D,\\;\\Sigma,\\;\\delta_D,\\;q_0,\\;F_D)$ 令 $Q_D=2^{Q_N}={S\\; | \\;S \\subseteq Q_N}$ 则 $\\delta_D(S,\\, a) = \\bigcup\\limits_{p\\in S}\\delta_N(p,\\,a)$，因为$S$ 是 $Q_N$ 的一个子集，所以把 $S$ 中的每个元素在 $a$ 下确定状态后合并即可。 则 $F_D={S\\;|\\;S\\subseteq Q_N \\;and \\;S\\cap F_N \\ne \\phi}$。注：显然 $F_D$有可能不仅有一个元素。 例：用上一节 (2) 中 $L_{x01}$ 的例子来看，NFA已经构造好了，用已有的NFA构造DFA如下：图中可以看出左半部分的 ${q_0,\\,q_1,\\,q_2}$ 这个状态显然是不可达的，没有意义，可以删去，右半部分同理也可删去。就简化成了如下的样子：转化的另一个办法，子集构造法(Sub-set construction)，惰性计算，走一步看一步，较上面的办法清爽许多。基本过程是从初始状态开始，看它可能走到哪些状态，然后看它走到的状态又分别能走到哪些状态，如此循环直到没有新的状态出现。还是用上面的例子做说明： 解题方法：因为NFA的行为更接近于人的思维，所以构造DFA的题可以先构造NFA然后转化成DFA4 ε-NFA和最小化DFA1 ε-NFA的形式化定义带有空转移的非确定有穷自动机：ε-NFA是一个五元组，如：$M=(Q,\\; \\Sigma,\\; \\delta,\\;q_0,\\; F)$ ，其中， $Q$ 是有限的状态集，包含NFA中所有的状态； $\\Sigma$ 是有限的输入字符集，也就是NFA的字母表； $q_0$ 是初始状态，并且 $q_0\\in Q$； $F$ 是终结状态的集合，并且 $F \\in Q$； $\\delta$ 是状态转移函数，它是一个映射：$Q \\times {\\Sigma \\cup {\\varepsilon}} \\to 2^Q $ 与NFA唯一的不同在于 $\\delta$ 多了一个 $\\varepsilon$ 输入 ，因而多了一个空转移行为。2 ε-闭包ε-闭包：状态q可以通过 (一次或多次) ε空转移到达的状态构成的集合就是q的ε-闭包，记为ECLOSE(q)，或更简单的E(q)。自己到自己也是空转移！！！例：在状态 $q$ 读了字符串 $w $ 可以到达的状态： NFA：$\\hat\\delta(q,\\, w)={\\,p_1,\\, p_2,\\, …,\\, p_k\\,}$ ε-NFA：$\\hat\\delta(q,\\, w)=\\bigcup\\limits_{i=1}^m E(r_i)$ 定义：若 $A = (Q, Σ, δ, q_0, F )$ 是一个 ε-NFA，则 D 接受的语言为 $L(A) = {w\\; |\\; \\hatδ(q_0, w) \\cap F \\ne \\phi\\,}$ 。 其实和NFA接受的语言是一样的3 DFA的最小化问题 最小化DFA就是找到一个等价的状态数最少的DFA对于两个状态，一定是 等价 / 可区分 的。 等价：$\\forall w \\in \\Sigma^*,\\, \\hat\\delta(p,\\, w)\\in F \\Leftrightarrow \\hat\\delta(q,\\, w)\\in F$ 注意：表明的是对于一个输入，两个状态都转移到终结状态或都转移到非终结状态，并不一定相同！ 可区分：$\\exist w\\in \\Sigma^*,\\, \\hat\\delta(p,\\, w)\\in F \\Leftrightarrow \\neg \\hat\\delta(q,\\, w)\\in F $ 当两个状态为可区分时，存在至少一个输入符，转移后状态不都为终结状态或不都为非终结状态。 例：—— Table-filling algorithm ——-把所有的状态对画成一张表，逐个检查所有的状态对，如果可区分，则把该格子标记，直到填完，剩下的没有标记的格子就是不可区分（等价）的状态对。 判断两个状态对可区分的策略： 终结状态和非终结状态一定是可区分的 两个状态读相同的字符，一个到了终结状态，一个到了非终结状态，则是可区分的 所以，要找让一个状态到终结状态的输入串，看在这个串下另一个状态是不是到了非终结状态，如果是就能很快判断了。上例用 Table-filling algorithm 得到的结果：最后把等价的状态捏在一起就好了，就得到了最小化后的DFA。" } ]
